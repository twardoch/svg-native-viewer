This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.circleci/
  config.yml
.github/
  CODEOWNERS
  CONTRIBUTING.md
svgnative/
  cmake/
    FindCairo.cmake
    FindSkia.cmake
  example/
    testC/
      CMakeLists.txt
      TestMain.c
      TestMain.h
    testCairo/
      CMakeLists.txt
      TestCairo.cpp
      TestCairo.h
    testCocoaCG/
      AppDelegate.h
      AppDelegate.mm
      CMakeLists.txt
      Document.h
      Document.mm
      Document.xib
      Info.plist
      main.mm
      MainMenu.xib
      SVGNSView.h
      SVGNSView.mm
    testD2D/
      basewin.h
      CMakeLists.txt
      TestD2D.cpp
      TestD2D.h
    testGDIPlus/
      CMakeLists.txt
      TestGDIPlus.cpp
      TestGDIPlus.h
    testSkia/
      CMakeLists.txt
      TestSkia.cpp
      TestSkia.h
    testText/
      CMakeLists.txt
      TestMain.cpp
      TestMain.h
  include/
    svgnative/
      ports/
        cairo/
          CairoSVGRenderer.h
        cg/
          CGSVGRenderer.h
        d2d/
          D2DSVGRenderer.h
        gdiplus/
          GDIPlusSVGRenderer.h
        skia/
          SkiaSVGRenderer.h
        string/
          StringSVGRenderer.h
      Config.h
      Rect.h
      SVGDocument.h
      SVGNativeCWrapper.h
      SVGRenderer.h
  script/
    runTest.py
  src/
    ports/
      cairo/
        CairoImageInfo.c
        CairoImageInfo.h
        CairoSVGRenderer.cpp
        CairoSVGRenderer.h
      cg/
        CGSVGRenderer.cpp
        CGSVGRenderer.h
      d2d/
        D2DSVGRenderer.cpp
      gdiplus/
        GDIPlusSVGRenderer.cpp
        GDIPlusSVGRenderer.h
      qt/
        QPainterSVGRenderer.h
      skia/
        SkiaSVGRenderer.cpp
        SkiaSVGRenderer.h
      string/
        StringSVGRenderer.cpp
        StringSVGRenderer.h
    win/
      version.rc
    xml/
      ExpatXMLParser.cpp
      ExpatXMLParser.h
      LibXMLParser.cpp
      LibXMLParser.h
      RapidXMLParser.cpp
      RapidXMLParser.h
      XMLParser.h
    Constants.h
    CSSColorKeywords.h
    DeprecatedSVGDocumentImpl.cpp
    DeprecatedSVGDocumentImpl.h
    Interval.cpp
    Interval.h
    Rect.cpp
    Rect.h
    SVGDocument.cpp
    SVGDocument.h
    SVGDocumentImpl.cpp
    SVGDocumentImpl.h
    SVGNativeCWrapper.cpp
    SVGNativeCWrapper.h
    SVGParserArcToCurve.cpp
    SVGParserArcToCurve.h
    SVGStringParser.cpp
    SVGStringParser.h
  test/
    clipping.svg
    clipping.txt
    dash-array.svg
    dash-array.txt
    elem-currentColor.svg
    elem-currentColor.txt
    elem-defs.svg
    elem-defs.txt
    elem-transform-on-parent.svg
    elem-transform-on-parent.txt
    gradient-outside-defs.svg
    gradient-outside-defs.txt
    gradient.svg
    gradient.txt
    image.svg
    image.txt
    paint.svg
    paint.txt
    path.svg
    path.txt
    properties.svg
    properties.txt
    recursion.svg
    recursion.txt
    shapes.svg
    shapes.txt
    svgLength.svg
    svgLength.txt
    symboles.svg
    symboles.txt
    transform.svg
    transform.txt
  tests/
    bound-tests-svgs/
      arcs.svg
      audi-clipping.svg
      audi.svg
      clipping.svg
      curves.svg
      dot.svg
      ellipses-combined.svg
      fill-rule.svg
      images.svg
      line.svg
      polygon.svg
      polyline.svg
      rectangle-rounded-rotated-circle.svg
      rectangles-combined-viewbox.svg
      rectangles-combined.svg
      stroke-caps.svg
      stroke-linejoin-bevel.svg
      stroke-linejoin-miter-over.svg
      stroke-linejoin-miter.svg
      stroke-linejoin-round.svg
      transform-concat.svg
      transforms.svg
      use.svg
      zero-stroke.svg
    librsvg-bounds-generator/
      .gitignore
      Makefile
      script.cpp
      script.h
    bounds-tests.cpp
    bounds-tests.h
    CMakeLists.txt
    interval-tests.cpp
    interval-tests.h
    rectangle-tests.cpp
    rectangle-tests.h
    svg-bounds.txt
    svg-filenames.txt
  CMakeLists.txt
  SVGNativeViewerLib-uninstalled.pc.in
  SVGNativeViewerLib.pc.in
tools/
  cminify.py
  makeheaders.c
  think.sh
.aider.chat.history.md
.aider.input.history
.gitignore
.gitmodules
CODE_OF_CONDUCT.md
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/CODEOWNERS">
*   @dirkschulze
</file>

<file path=".github/CONTRIBUTING.md">
# Contributing

Thanks for choosing to contribute!

The following are a set of guidelines to follow when contributing to this project.

## Code Of Conduct

This project adheres to the Adobe [code of conduct](../CODE_OF_CONDUCT.md). By participating,
you are expected to uphold this code. Please report unacceptable behavior to
[Grp-opensourceoffice@adobe.com](mailto:Grp-opensourceoffice@adobe.com).

## Have A Question?

Start by filing an issue. The existing committers on this project work to reach
consensus around project direction and issue solutions within issue threads
(when appropriate).

## Contributor License Agreement

All third-party contributions to this project must be accompanied by a signed contributor
license agreement. This gives Adobe permission to redistribute your contributions
as part of the project. [Sign our CLA](http://opensource.adobe.com/cla.html). You
only need to submit an Adobe CLA one time, so if you have submitted one previously,
you are good to go!

## Code Reviews

All submissions should come in the form of pull requests and need to be reviewed
by project committers. Read [GitHub's pull request documentation](https://help.github.com/articles/about-pull-requests/)
for more information on sending pull requests.

Lastly, please follow the [pull request template](PULL_REQUEST_TEMPLATE.md) when
submitting a pull request!

## From Contributor To Committer

We love contributions from our community! If you'd like to go a step beyond contributor
and become a committer with full write access and a say in the project, you must
be invited to the project. The existing committers employ an internal nomination
process that must reach lazy consensus (silence is approval) before invitations
are issued. If you feel you are qualified and want to get more deeply involved,
feel free to reach out to existing committers to have a conversation about that.

## Security Issues

Security issues shouldn't be reported on this issue tracker. Instead, [file an issue to our security experts](https://helpx.adobe.com/security/alertus.html)
</file>

<file path="svgnative/example/testCocoaCG/AppDelegate.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import <Cocoa/Cocoa.h>

@interface AppDelegate : NSObject <NSApplicationDelegate>


@end
</file>

<file path="svgnative/example/testCocoaCG/AppDelegate.mm">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import "AppDelegate.h"

@interface AppDelegate ()

@end

@implementation AppDelegate

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
	// Insert code here to initialize your application
}


- (void)applicationWillTerminate:(NSNotification *)aNotification {
	// Insert code here to tear down your application
}


@end
</file>

<file path="svgnative/example/testCocoaCG/CMakeLists.txt">
add_executable(testCocoaCG MACOSX_BUNDLE
    AppDelegate.h
    AppDelegate.mm
    Document.h
    Document.mm
    SVGNSView.h
    SVGNSView.mm
    main.mm
    MainMenu.xib
    Document.xib
)

set_source_files_properties(MainMenu.xib PROPERTIES MACOSX_PACKAGE_LOCATION Resources)
set_source_files_properties(Document.xib PROPERTIES MACOSX_PACKAGE_LOCATION Resources)

set_target_properties(testCocoaCG PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_LIST_DIR}/Info.plist)

target_link_libraries(testCocoaCG PUBLIC SVGNativeViewerLib)
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -framework AppKit")
</file>

<file path="svgnative/example/testCocoaCG/Document.xib">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14313.18" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14313.18"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="Document">
            <connections>
                <outlet property="window" destination="xOd-HO-29H" id="JIz-fz-R2o"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application"/>
        <window title="Window" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" visibleAtLaunch="NO" animationBehavior="default" id="xOd-HO-29H" userLabel="Window">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <windowPositionMask key="initialPositionMask" leftStrut="YES" rightStrut="YES" topStrut="YES" bottomStrut="YES"/>
            <rect key="contentRect" x="133" y="235" width="507" height="413"/>
            <rect key="screenRect" x="0.0" y="0.0" width="1680" height="1027"/>
            <value key="minSize" type="size" width="94" height="86"/>
            <view key="contentView" wantsLayer="YES" id="gIp-Ho-8D9" customClass="SVGNSView">
                <rect key="frame" x="0.0" y="0.0" width="507" height="413"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
            <connections>
                <outlet property="delegate" destination="-2" id="0bl-1N-x8E"/>
            </connections>
        </window>
    </objects>
</document>
</file>

<file path="svgnative/example/testCocoaCG/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>svg</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string></string>
			<key>CFBundleTypeName</key>
			<string>DocumentType</string>
			<key>CFBundleTypeOSTypes</key>
			<array>
				<string>????</string>
			</array>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>NSDocumentClass</key>
			<string>Document</string>
		</dict>
	</array>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright © 2019 Adobe. All rights reserved.</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>
</file>

<file path="svgnative/example/testCocoaCG/main.mm">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import <Cocoa/Cocoa.h>

int main(int argc, const char * argv[]) {
	return NSApplicationMain(argc, argv);
}
</file>

<file path="svgnative/example/testCocoaCG/MainMenu.xib">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="11134" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="11134"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSApplication"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModuleProvider=""/>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="SVGNativeViewer" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="SVGNativeViewer" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About SVGNativeViewer" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide SVGNativeViewer" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit SVGNativeViewer" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="File" id="dMs-cI-mzQ">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="File" id="bib-Uj-vzu">
                        <items>
                            <menuItem title="Open…" keyEquivalent="o" id="IAo-SY-fd9">
                                <connections>
                                    <action selector="openDocument:" target="-1" id="bVn-NM-KNZ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Open Recent" id="tXI-mr-wws">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Open Recent" systemMenu="recentDocuments" id="oas-Oc-fiZ">
                                    <items>
                                        <menuItem title="Clear Menu" id="vNY-rz-j42">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="clearRecentDocuments:" target="-1" id="Daa-9d-B3U"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="m54-Is-iLE"/>
                            <menuItem title="Close" keyEquivalent="w" id="DVo-aG-piG">
                                <connections>
                                    <action selector="performClose:" target="-1" id="HmO-Ls-i7Q"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Show Toolbar" keyEquivalent="t" id="snW-S8-Cw5">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleToolbarShown:" target="-1" id="BXY-wc-z0C"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Customize Toolbar…" id="1UK-8n-QPP">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="runToolbarCustomizationPalette:" target="-1" id="pQI-g3-MTW"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="hB3-LF-h0Y"/>
                            <menuItem title="Show Sidebar" keyEquivalent="s" id="kIP-vf-haE">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleSourceList:" target="-1" id="iwa-gc-5KM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="wpr-3q-Mcd">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="F2S-fz-NVQ">
                        <items>
                            <menuItem title="SVGNativeViewer Help" keyEquivalent="?" id="FKE-Sm-Kum">
                                <connections>
                                    <action selector="showHelp:" target="-1" id="y7X-2Q-9no"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
            </items>
        </menu>
    </objects>
</document>
</file>

<file path="svgnative/example/testCocoaCG/SVGNSView.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import <Cocoa/Cocoa.h>

NS_ASSUME_NONNULL_BEGIN

@interface SVGNSView : NSView

@end

NS_ASSUME_NONNULL_END
</file>

<file path="svgnative/example/testCocoaCG/SVGNSView.mm">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import "SVGNSView.h"
#import "Document.h"

#include "svgnative/ports/cg/CGSVGRenderer.h"

@implementation SVGNSView

- (void)drawRect:(NSRect)dirtyRect {
    [super drawRect:dirtyRect];
	
	Document* d = [[[self window] windowController] document];
	SVGNative::SVGDocument* doc = [d getSVGDocument];
	if (!doc)
		return;
	
	NSGraphicsContext* nsGraphicsContext = [NSGraphicsContext currentContext];
	CGContextRef ctx = (CGContextRef) [nsGraphicsContext CGContext];
	SVGNative::CGSVGRenderer* renderer = static_cast<SVGNative::CGSVGRenderer*>(doc->Renderer());

	CGRect r(dirtyRect);
	
	CGAffineTransform m = {1.0, 0.0, 0.0, -1.0, 0.0, r.size.height};
	CGContextConcatCTM(ctx, m);

	renderer->SetGraphicsContext(ctx);
	
	doc->Render(r.size.width, r.size.height);
	
	renderer->ReleaseGraphicsContext();
}

@end
</file>

<file path="svgnative/example/testText/CMakeLists.txt">
add_executable(testSVGNative TestMain.cpp)

target_link_libraries(testSVGNative PUBLIC SVGNativeViewerLib)
</file>

<file path="svgnative/test/clipping.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="250" viewBox="0 0 200 250">
    <defs>
        <!-- ClipPath w/o content -->
        <clipPath id="c1">
        </clipPath>
        <!-- ClipPath w/ different shapes -->
        <clipPath id="c2">
            <circle cx="60" cy="20" r="20"/>
        </clipPath>
        <clipPath id="c3">
            <ellipse cx="100" cy="20" rx="20" ry="15"/>
        </clipPath>
        <clipPath id="c4">
            <rect x="130" y="10" width="20" height="20" rx="5" ry="5"/>
        </clipPath>
        <clipPath id="c5">
            <path d="M180 10 L190 35 L170 35"/>
        </clipPath>
        <clipPath id="c6">
            <polyline points="20,50 30,75 10,75"/>
        </clipPath>
        <clipPath id="c7">
            <circle cx="20" cy="20" r="20" transform="translate(40, 40)"/>
        </clipPath>
        <!-- Invalid content -->
        <clipPath id="c8">
            <g>
                <circle cx="100" cy="60" r="20"/>
            </g>
        </clipPath>
        <clipPath id="c9">
            <circle cx="140" cy="60" r="20"/>
            <g>
                <rect x="-200" y="-200" width="200" height="200"/>
            </g>
        </clipPath>
        <clipPath id="c10">
            <g>
                <rect x="-200" y="-200" width="200" height="200"/>
            </g>
            <circle cx="180" cy="60" r="20"/>
        </clipPath>
        <clipPath id="c11">
            <circle cx="20" cy="100" r="20"/>
            <rect x="-200" y="-200" width="200" height="200"/>
        </clipPath>
        <!-- clip related properties and attributes -->
        <clipPath id="c12">
            <circle cx="60" cy="100" r="20" clip-rule="evenodd"/>
        </clipPath>
        <clipPath id="c13" clip-rule="evenodd">
            <circle cx="100" cy="100" r="20"/>
        </clipPath>
    </defs>
    <defs clip-rule="evenodd">
        <clipPath id="c14">
            <circle cx="140" cy="100" r="20"/>
        </clipPath>
    </defs>
    <defs>
        <clipPath id="c15">
            <circle cx="180" cy="100" r="20"/>
        </clipPath>
        <!-- clipping paths operate in the coordinate space of the referencing element -->
        <clipPath id="c16">
            <circle cx="20" cy="20" r="20"/>
        </clipPath>
    </defs>
    <rect width="40" height="40" x="0" y="0" clip-path="url(#c1)"/>
    <rect width="40" height="40" x="40" y="0" clip-path="url(#c2)"/>
    <rect width="40" height="40" x="80" y="0" clip-path="url(#c3)"/>
    <rect width="40" height="40" x="120" y="0" clip-path="url(#c4)"/>
    <rect width="40" height="40" x="160" y="0" clip-path="url(#c5)"/>
    <rect width="40" height="40" x="0" y="40" clip-path="url(#c6)"/>
    <rect width="40" height="40" x="40" y="40" clip-path="url(#c7)"/>
    <rect width="40" height="40" x="80" y="40" clip-path="url(#c8)"/>
    <rect width="40" height="40" x="120" y="40" clip-path="url(#c9)"/>
    <rect width="40" height="40" x="160" y="40" clip-path="url(#c10)"/>
    <rect width="40" height="40" x="0" y="80" clip-path="url(#c11)"/>
    <rect width="40" height="40" x="40" y="80" clip-path="url(#c12)"/>
    <rect width="40" height="40" x="80" y="80" clip-path="url(#c13)"/>
    <rect width="40" height="40" x="120" y="80" clip-path="url(#c14)"/>
    <rect width="40" height="40" x="160" y="80" clip-path="url(#c15)" clip-rule="evenodd"/>
    <rect width="40" height="40" x="0" y="0" clip-path="url(#c16)" transform="translate(0, 120)"/>
</svg>
</file>

<file path="svgnative/test/dash-array.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200">
    <line x2="200" y1="5" y2="5" stroke="black" stroke-width="5" stroke-dasharray="20"/>
    <line x2="200" y1="10" y2="10" stroke="black" stroke-width="5" stroke-dasharray="20 10"/>
    <line x2="200" y1="15" y2="15" stroke="black" stroke-width="5" stroke-dasharray="20 0 0 0 10"/>
    <line x2="200" y1="20" y2="20" stroke="black" stroke-width="5" stroke-dasharray=".99.99.99.99"/>
    <line x2="200" y1="25" y2="25" stroke="black" stroke-width="5" stroke-dasharray="5px 1pt 0.5pc"/>
    <line x2="200" y1="30" y2="30" stroke="black" stroke-width="5" stroke-dasharray="2mm , 
    0.2cm"/>
    <line x2="200" y1="35" y2="35" stroke="black" stroke-width="5" stroke-dasharray=".99e1.2e2.1e2.9.9"/>
    <line x2="200" y1="40" y2="40" stroke="black" stroke-width="5" stroke-dasharray="5% 10%"/>

    <!-- invalid values -->
    <line x2="200" y1="100" y2="100" stroke="black" stroke-width="5" stroke-dasharray="20, 10, 20,"/>
    <line x2="200" y1="105" y2="105" stroke="black" stroke-width="5" stroke-dasharray="20,, 10"/>
    <line x2="200" y1="110" y2="110" stroke="black" stroke-width="5" stroke-dasharray="20   ,    , 10"/>
    <line x2="200" y1="115" y2="115" stroke="black" stroke-width="5" stroke-dasharray="-10 -5"/>

    <!-- stroke-dashoffset -->
    <line x2="200" y1="130" y2="130" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="5"/>
    <line x2="200" y1="135" y2="135" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="5px"/>
    <line x2="200" y1="140" y2="140" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="5pt"/>
    <line x2="200" y1="145" y2="145" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="1pc"/>
    <line x2="200" y1="150" y2="150" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="11mm"/>
    <line x2="200" y1="155" y2="155" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="1.1cm"/>
    <line x2="200" y1="160" y2="160" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="5%"/>
    <line x2="200" y1="165" y2="165" stroke="black" stroke-dasharray="20 10" stroke-dashoffset=".9e2"/>
    <line x2="200" y1="170" y2="170" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="   
    .9e2   "/>
    <line x2="200" y1="175" y2="175" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="2000.0e-3"/>
    <line x2="200" y1="180" y2="180" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="-3.0e2"/>
    <line x2="200" y1="185" y2="185" stroke="black" stroke-dasharray="20 10" stroke-dashoffset="-300.0e-2"/>
</svg>
</file>

<file path="svgnative/test/gradient.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="150" height="250" viewBox="0 0 150 250">
    <defs>
        <!-- Linear gradient without color stops -->
        <linearGradient id="g1" gradientUnits="userSpaceOnUse">
        </linearGradient>
        <!-- Radial gradient without color stops -->
        <radialGradient id="g2" gradientUnits="userSpaceOnUse">
        </radialGradient>
        <!-- Linear gradient with start/end color stop -->
        <linearGradient id="g3" gradientUnits="userSpaceOnUse">
            <stop stop-color="#0000FF" offset="0"/>
            <stop stop-color="#00FF00" offset="1"/>
        </linearGradient>
        <!-- Radial gradient with start/end color stop -->
        <radialGradient id="g4" gradientUnits="userSpaceOnUse">
            <stop stop-color="#0000FF" offset="0"/>
            <stop stop-color="#00FF00" offset="1"/>
        </radialGradient>
        <!-- One color stop in the middle -->
        <radialGradient id="g5" gradientUnits="userSpaceOnUse">
            <stop stop-color="#00FF00" offset="0.5"/>
        </radialGradient>
        <!-- Multiple color stops with stop opacity -->
        <linearGradient id="g6" gradientUnits="userSpaceOnUse">
            <stop stop-color="#000000" stop-opacity="0" offset="0"/>
            <stop stop-color="#0FF000" stop-opacity="0.25" offset="0.25"/>
            <stop stop-color="#000FF0" stop-opacity="0.75" offset="0.75"/>
            <stop stop-color="#0000FF" stop-opacity="1" offset="1"/>
        </linearGradient>
        <!-- Color stops with unordered offsets -->
        <radialGradient id="g7" gradientUnits="userSpaceOnUse">
            <stop stop-color="#000000" offset="0"/>
            <stop stop-color="#0FF000" offset="0.75"/>
            <stop stop-color="#00FF00" offset="0.6"/>
            <stop stop-color="#000FF0" offset="0.5"/>
            <stop stop-color="#0000FF" offset="1"/>
        </radialGradient>
        <!-- Color stops not reaching 0% or 100% -->
        <radialGradient id="g8" gradientUnits="userSpaceOnUse">
            <stop stop-color="#0000FF" offset="0.25"/>
            <stop stop-color="#00FF00" offset="0.75"/>
        </radialGradient>
        <!-- Referencing gradients -->
        <linearGradient id="ref1-1" x1="15" y1="15" gradientUnits="userSpaceOnUse">
            <stop stop-color="#FF0000" offset="0"/>
            <stop stop-color="#FF0000" offset="1"/>
        </linearGradient>
        <linearGradient id="ref1-2" xlink:href="#ref1-1" x2="0" y2="0" gradientUnits="userSpaceOnUse">
            <stop stop-color="#00FF00" offset="0"/>
            <stop stop-color="#00DD00" offset="1"/>
        </linearGradient>
        <linearGradient id="ref1-3" xlink:href="#ref1-2" x2="185" y2="35" gradientUnits="userSpaceOnUse">
        </linearGradient>
        <linearGradient id="g9" xlink:href="#ref1-3" y2="185" gradientUnits="userSpaceOnUse">
        </linearGradient>
        <!-- Referencing future gradient -->
        <linearGradient id="g10" xlink:href="#future" y2="185" gradientUnits="userSpaceOnUse">
            <stop stop-color="#00FF00" offset="0"/>
            <stop stop-color="#00FF00" offset="1"/>
        </linearGradient>
        <linearGradient id="future" gradientUnits="userSpaceOnUse">
            <stop stop-color="#FF0000" offset="0"/>
            <stop stop-color="#FF0000" offset="1"/>
        </linearGradient>
        <!-- Referencing cross gradient types -->
        <linearGradient id="ref2-1" x1="5" y1="5" x2="195" y2="195" gradientUnits="userSpaceOnUse">
            <stop stop-color="#FF0000" offset="0"/>
            <stop stop-color="#FF0000" offset="1"/>
        </linearGradient>
        <radialGradient id="ref2-2" xlink:href="#ref2-1" cx="50" cy="50" r="25" spreadMethod="reflect" gradientUnits="userSpaceOnUse">
            <stop stop-color="#00FF00" offset="0"/>
            <stop stop-color="#00FF00" offset="1"/>
        </radialGradient>
        <linearGradient id="g11" xlink:href="#ref2-2" gradientUnits="userSpaceOnUse">
        </linearGradient>
        <!-- Referencing cross gradient types 2 -->
        <radialGradient id="ref3-1" cx="0" cy="50" r="25" gradientUnits="userSpaceOnUse">
            <stop stop-color="#FF0000" offset="0"/>
            <stop stop-color="#FF0000" offset="1"/>
        </radialGradient>
        <linearGradient id="ref3-2" xlink:href="#ref3-1" cx="50" cy="50" r="25" gradientTransform="scale(2) translate(20)" gradientUnits="userSpaceOnUse">
            <stop stop-color="#00FF00" offset="0"/>
            <stop stop-color="#00FF00" offset="1"/>
        </linearGradient>
        <radialGradient id="g12" xlink:href="#ref3-2" cx="50" gradientUnits="userSpaceOnUse">
        </radialGradient>
        <!-- Referencing cross gradient types 3 -->
        <linearGradient id="ref4-1" gradientUnits="userSpaceOnUse">
            <stop stop-color="#00FF00" offset="0"/>
            <stop stop-color="#00FF00" offset="1"/>
        </linearGradient>
        <radialGradient id="g13" xlink:href="#ref4-1" gradientUnits="userSpaceOnUse">
        </radialGradient>
        <!-- Variables as color stops -->
        <linearGradient id="g14" gradientUnits="userSpaceOnUse">
            <stop stop-color="var(--test-green, #F00)" offset="0"/>
            <stop stop-color="var(--test-blue, #F00)" offset="1"/>
        </linearGradient>
        <linearGradient id="g15" gradientUnits="userSpaceOnUse">
            <stop stop-color="var(--test-green, #F00)" offset="0"/>
            <stop stop-color="var(--missing, #00F)" offset="1"/>
        </linearGradient>
        <linearGradient id="g16" gradientUnits="userSpaceOnUse">
            <stop stop-color="var(--test-green, #F00)" offset="0"/>
            <stop stop-color="var(invalid)" offset="1"/>
        </linearGradient>
        <!-- Test currentColor -->
        <linearGradient id="g17" gradientUnits="userSpaceOnUse">
            <stop color="green" stop-color="currentColor" offset="0"/>
            <stop stop-color="green" offset="1"/>
        </linearGradient>
        <linearGradient id="g18" gradientUnits="userSpaceOnUse" color="green">
            <stop stop-color="currentColor" offset="0"/>
            <stop stop-color="green" offset="1"/>
        </linearGradient>
    </defs>
    <defs color="green">
        <linearGradient id="g20" gradientUnits="userSpaceOnUse">
            <stop stop-color="currentColor" offset="0"/>
            <stop stop-color="green" offset="1"/>
        </linearGradient>
    </defs>
    <rect width="150" height="10" fill="url(#g1)"/>
    <rect width="150" height="10" fill="url(#g2)" y="10"/>
    <rect width="150" height="10" fill="url(#g3)" y="20"/>
    <rect width="150" height="10" fill="url(#g4)" y="30"/>
    <rect width="150" height="10" fill="url(#g5)" y="40"/>
    <rect width="150" height="10" fill="url(#g6)" y="50"/>
    <rect width="150" height="10" fill="url(#g7)" y="60"/>
    <rect width="150" height="10" fill="url(#g8)" y="70"/>
    <rect width="150" height="10" fill="url(#g9)" y="80"/>
    <rect width="150" height="10" fill="url(#g10)" y="90"/>
    <rect width="150" height="10" fill="url(#g11)" y="100"/>
    <rect width="150" height="10" fill="url(#g12)" y="110"/>
    <rect width="150" height="10" fill="url(#g13)" y="120"/>
    <rect width="150" height="10" fill="url(#g14)" y="130"/>
    <rect width="150" height="10" fill="url(#g15)" y="140"/>
    <rect width="150" height="10" fill="url(#g16)" y="150"/>
    <rect width="150" height="10" fill="url(#g17)" y="160"/>
    <rect width="150" height="10" fill="url(#g18)" y="170"/>
    <rect width="150" height="10" fill="url(#g19)" y="180"/>
    <rect width="150" height="10" color="red" fill="url(#g20)" y="190"/>
</svg>
</file>

<file path="svgnative/test/image.svg">
<svg width="450px" height="300px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- based on preserveAspectRatio example from https://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute -->
    <defs>
        <image id="smile" width="30" height="40"
            xlink:href="data:image/png;base64,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" />
    </defs>


    <text x="10" y="30">SVG to fit</text>
    <g transform="translate(20,40)">
        <image id="smile" width="30" height="40"
            xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==" />
    </g>

    <text x="10" y="110">Viewport 1</text>
    <g transform="translate(10,120)">
        <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />
    </g>

    <text x="10" y="180">Viewport 2</text>
    <g transform="translate(20,190)">
        <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
    </g>

    <g id="meet-group-1" transform="translate(100, 60)">
        <text x="0" y="-30">--------------- meet ---------------</text>
        <g>
            <text y="-10">xMin*</text>
            <image preserveAspectRatio="xMinYMin meet" width="50" height="30"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />
        </g>
        <g transform="translate(70,0)">
            <text y="-10">xMid*</text>
            <image preserveAspectRatio="xMidYMid meet" width="50" height="30"
                xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==" />
            <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />

        </g>
        <g transform="translate(0,70)">
            <text y="-10">xMax*</text>
            <image preserveAspectRatio="xMaxYMax meet" width="50" height="30"
                xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==" />
            <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />
        </g>
    </g>

    <g id="meet-group-2" transform="translate(250, 60)">
        <text x="0" y="-30">---------- meet ----------</text>
        <g>
            <text y="-10">*YMin</text>
            <image preserveAspectRatio="xMinYMin meet" width="30" height="60"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
        </g>
        <g transform="translate(50, 0)">
            <text y="-10">*YMid</text>
            <image preserveAspectRatio="xMidYMid meet" width="30" height="60"
                xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==" />
            <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
        </g>
        <g transform="translate(100, 0)">
            <text y="-10">*YMax</text>
            <image preserveAspectRatio="xMaxYMax meet" width="30" height="60"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
        </g>
    </g>

    <g id="slice-group-1" transform="translate(100, 220)">
        <text x="0" y="-30">---------- slice ----------</text>
        <g>
            <text y="-10">xMin*</text>
            <image preserveAspectRatio="xMinYMin slice" width="30" height="60"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
        </g>
        <g transform="translate(50,0)">
            <text y="-10">xMid*</text>
            <image preserveAspectRatio="xMidYMid slice" width="30" height="60"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
        </g>
        <g transform="translate(100,0)">
            <text y="-10">xMax*</text>
            <image preserveAspectRatio="xMaxYMax slice" width="30" height="60"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='29' height='59' fill="none" stroke="black" />
        </g>
    </g>

    <g id="slice-group-2" transform="translate(250, 220)">
        <text x="0" y="-30">--------------- slice ---------------</text>
        <g>
            <text y="-10">*YMin</text>
            <image preserveAspectRatio="xMinYMin slice" width="50" height="30"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />
        </g>
        <g transform="translate(70,0)">
            <text y="-10">*YMid</text>
            <image preserveAspectRatio="xMidYMid slice" width="50" height="30"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />
        </g>
        <g transform="translate(140,0)">
            <text y="-10">*YMax</text>
            <image preserveAspectRatio="xMaxYMax slice" width="50" height="30"
                xlink:href="data:image/png;base64,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" />
            <rect x='.5' y='.5' width='49' height='29' fill="none" stroke="black" />
        </g>
    </g>
</svg>
</file>

<file path="CODE_OF_CONDUCT.md">
# Adobe Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of experience,
nationality, personal appearance, race, religion, or sexual identity and
orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at Grp-opensourceoffice@adobe.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at [https://contributor-covenant.org/version/1/4][version]

[homepage]: https://contributor-covenant.org
[version]: https://contributor-covenant.org/version/1/4/
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="svgnative/cmake/FindCairo.cmake">
# - Try to find Cairo
# Once done, this will define
#
#  CAIRO_FOUND - system has Cairo
#  CAIRO_INCLUDE_DIRS - the Cairo include directories
#  CAIRO_LIBRARIES - link these to use Cairo
#
# Copyright (C) 2012 Raphael Kubo da Costa <rakuco@webkit.org>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND ITS CONTRIBUTORS ``AS
# IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR ITS
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

FIND_PACKAGE(PkgConfig)
PKG_CHECK_MODULES(PC_CAIRO cairo) # FIXME: After we require CMake 2.8.2 we can pass QUIET to this call.

FIND_PATH(CAIRO_INCLUDE_DIRS
    NAMES cairo.h
    HINTS ${PC_CAIRO_INCLUDEDIR}
          ${PC_CAIRO_INCLUDE_DIRS}
    PATH_SUFFIXES cairo
)

FIND_LIBRARY(CAIRO_LIBRARIES
    NAMES cairo
    HINTS ${PC_CAIRO_LIBDIR}
          ${PC_CAIRO_LIBRARY_DIRS}
)

IF (CAIRO_INCLUDE_DIRS)
    IF (EXISTS "${CAIRO_INCLUDE_DIRS}/cairo-version.h")
        FILE(READ "${CAIRO_INCLUDE_DIRS}/cairo-version.h" CAIRO_VERSION_CONTENT)

        STRING(REGEX MATCH "#define +CAIRO_VERSION_MAJOR +([0-9]+)" _dummy "${CAIRO_VERSION_CONTENT}")
        SET(CAIRO_VERSION_MAJOR "${CMAKE_MATCH_1}")

        STRING(REGEX MATCH "#define +CAIRO_VERSION_MINOR +([0-9]+)" _dummy "${CAIRO_VERSION_CONTENT}")
        SET(CAIRO_VERSION_MINOR "${CMAKE_MATCH_1}")

        STRING(REGEX MATCH "#define +CAIRO_VERSION_MICRO +([0-9]+)" _dummy "${CAIRO_VERSION_CONTENT}")
        SET(CAIRO_VERSION_MICRO "${CMAKE_MATCH_1}")

        SET(CAIRO_VERSION "${CAIRO_VERSION_MAJOR}.${CAIRO_VERSION_MINOR}.${CAIRO_VERSION_MICRO}")
    ENDIF ()
ENDIF ()

# FIXME: Should not be needed anymore once we start depending on CMake 2.8.3
SET(VERSION_OK TRUE)
IF (Cairo_FIND_VERSION)
    IF (Cairo_FIND_VERSION_EXACT)
        IF ("${Cairo_FIND_VERSION}" VERSION_EQUAL "${CAIRO_VERSION}")
            # FIXME: Use IF (NOT ...) with CMake 2.8.2+ to get rid of the ELSE block
        ELSE ()
            SET(VERSION_OK FALSE)
        ENDIF ()
    ELSE ()
        IF ("${Cairo_FIND_VERSION}" VERSION_GREATER "${CAIRO_VERSION}")
            SET(VERSION_OK FALSE)
        ENDIF ()
    ENDIF ()
ENDIF ()

INCLUDE(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(Cairo DEFAULT_MSG CAIRO_INCLUDE_DIRS CAIRO_LIBRARIES VERSION_OK)
</file>

<file path="svgnative/cmake/FindSkia.cmake">
# - Try to find the Skia library to be linked with,
# and prepare a few variables for linker flags.
#
# ----------------------------------------------------------------------------
#
# Copyright (C) 2020 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>
#
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.
#
# ----------------------------------------------------------------------------
#
# SKIA_AVAILABLE
#     a boolean that usable Skia library is found or not.
#
# SKIA_LIBRARY_PATH
#     the full-path of the Skia library to be linked.
#     to use Skia DLL, the pathname of .dll.lib file
#     instead of .dll file should be given.
#
# SKIA_LIBRARY_DIR
#     the directory which the Skia library locates.
#
# SKIA_LIBRARY_LDFLAGS
#     the flags to link Skia, to be recorded in pkg-config file.
#
# WIN32_OBJECT_TYPE
#     the flag *for MSVC* to control whether the object
#     files would be sharable or non-sharable. It is set
#     to match with the format of found or specified Skia
#     library. It is deduced from the extention of the
#     found or specified library.
#
# By default, following positions would be searched.
#
# macOS: third_party/skia/lib/osx/libskia.a
# Win:   third_party/skia/lib/skia.lib
#

set(SKIA_AVAILABLE OFF)
if (NOT DEFINED SKIA_LIBRARY_PATH)
    if (APPLE)
        set(SKIA_LIBRARY_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/skia/lib/osx/libskia.a")
    elseif (MSVC)
        set(SKIA_LIBRARY_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/skia/lib/skia.lib")
    else()
        message(STATUS "No usable Skia library was found, please specify -DSKIA_LIBRARY_PATH=XXX.")
    endif()
endif()

if (DEFINED SKIA_LIBRARY_PATH)
    if (EXISTS "${SKIA_LIBRARY_PATH}")
        set(SKIA_AVAILABLE ON)
        message(STATUS "Skia library at ${SKIA_LIBRARY_PATH} would be used")
    else()
        message(STATUS "No usable Skia library was found at ${SKIA_LIBRARY_PATH}")
    endif()
endif()

if (SKIA_AVAILABLE)
    get_filename_component(SKIA_LIBRARY_DIR ${SKIA_LIBRARY_PATH} DIRECTORY)
    set(SKIA_LIBRARY_LDFLAGS "-L${SKIA_LIBRARY_DIR} -lskia")
    if (MSVC AND NOT DEFINED WIN32_OBJECT_TYPE)
        string(TOLOWER ${SKIA_LIBRARY_PATH} SKIA_LIBRARY_PATH_LOW)
        if (${SKIA_LIBRARY_PATH_LOW} MATCHES "\.lib$" AND NOT ${SKIA_LIBRARY_PATH_LOW} MATCHES "\.dll\.lib$")
            message(STATUS "Skia library might be static, set object type to /MT (cannot be dynamic-linked).")
            set(WIN32_OBJECT_TYPE "/MT")
        endif()
    endif()
endif()
</file>

<file path="svgnative/example/testC/TestMain.h">
#ifndef SVG_NATIVE_HEADER_H
#define SVG_NATIVE_HEADER_H
#include<stdlib.h>
#include<stdio.h>
#include<stddef.h>
#include "svgnative/SVGNativeCWrapper.h"
char*read_svg_input(const char*pathname);size_t write_data(const char*pathname,const char*buff_output,size_t size_output);
#endif
</file>

<file path="svgnative/example/testCairo/CMakeLists.txt">
add_executable(testCairo TestCairo.cpp)

target_link_libraries(testCairo PUBLIC SVGNativeViewerLib)
target_link_libraries(testCairo PUBLIC "${CAIRO_LIBRARIES}")
</file>

<file path="svgnative/example/testCairo/TestCairo.h">
#ifndef HEADER_FILE_H
#define HEADER_FILE_H
#include "svgnative/SVGDocument.h"
#include<list>
#include "svgnative/ports/cairo/CairoSVGRenderer.h"
#include "cairo.h"
#if CAIRO_HAS_SCRIPT_SURFACE
#include "cairo-script.h"
#endif
#if CAIRO_HAS_SVG_SURFACE
#include "cairo-svg.h"
#endif
#if CAIRO_HAS_XML_SURFACE
#include "cairo-xml.h"
#endif
#include<fstream>
#include<iostream>
#include<string>
#include<cctype>
void shutdown_cairo_surface(cairo_surface_t*cairo_surface){cairo_surface_flush(cairo_surface);cairo_surface_finish(cairo_surface);cairo_surface_destroy(cairo_surface);}void shutdown_cairo_device(cairo_device_t*cairo_device){cairo_device_flush(cairo_device);cairo_device_finish(cairo_device);cairo_device_destroy(cairo_device);}bool try_emit_svg(const char*pathSvg,int width,int height,cairo_surface_t*cairoRecSurface){assert(pathSvg);assert(cairoRecSurface);
#ifndef CAIRO_HAS_SVG_SURFACE
return false;
#else 
auto cairoSvgSurface=cairo_svg_surface_create(pathSvg,width,height);auto cairoSvgCtx=cairo_create(cairoSvgSurface);cairo_set_source_surface(cairoSvgCtx,cairoRecSurface,0,0);shutdown_cairo_surface(cairoRecSurface);cairo_paint(cairoSvgCtx);cairo_show_page(cairoSvgCtx);cairo_destroy(cairoSvgCtx);shutdown_cairo_surface(cairoSvgSurface);return true;
#endif
}bool try_emit_xml(const char*pathXml,cairo_surface_t*cairoRecSurface){assert(pathXml);assert(cairoRecSurface);
#ifndef CAIRO_HAS_XML_SURFACE
return false;
#else 
auto cairoXmlDev=cairo_xml_create(pathXml);cairo_xml_for_recording_surface(cairoXmlDev,cairoRecSurface);shutdown_cairo_device(cairoXmlDev);return true;
#endif
}bool try_emit_cairo_script(const char*pathCairoScript,cairo_surface_t*cairoRecSurface){assert(pathCairoScript);assert(cairoRecSurface);
#ifndef CAIRO_HAS_SCRIPT_SURFACE
return false;
#else 
auto cairoScriptDev=cairo_script_create(pathCairoScript);cairo_script_from_recording_surface(cairoScriptDev,cairoRecSurface);shutdown_cairo_device(cairoScriptDev);return true;
#endif
}bool try_emit_png(const char*pathPng,cairo_surface_t*cairoRecSurface){assert(pathPng);assert(cairoRecSurface);
#ifndef CAIRO_HAS_PNG_FUNCTIONS
return false;
#else 
cairo_surface_write_to_png(cairoRecSurface,pathPng);return true;
#endif
}int main(int argc,char*const argv[]){if(argc<3){std::cerr<<argv[0]<<"<input.svg><output1.png>[<output2.xml><output3.cs><output4.svg>...]"<<std::endl;return 0;}std::string svgInput{};std::ifstream input(argv[1]);if(!input){std::cerr<<"Error!Could not open input file."<<std::endl;exit(EXIT_FAILURE);}for(std::string line;std::getline(input,line);){svgInput.append(line);}input.close();auto renderer=std::make_shared<SVGNative::CairoSVGRenderer>();auto doc=std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(),renderer));cairo_rectangle_t docExtents{0,0,0,0};docExtents.width=doc->Width();docExtents.height=doc->Height();for(int i=2;i<argc;i++){std::string outPath=argv[i];std::string suffix=outPath.substr(outPath.rfind('.')+1).c_str();std::transform(suffix.begin(),suffix.end(),suffix.begin(),::tolower);cairo_surface_t*cairoRecSurface=cairo_recording_surface_create(CAIRO_CONTENT_COLOR_ALPHA,&docExtents);auto cairoRecContext=cairo_create(cairoRecSurface);renderer->SetCairo(cairoRecContext);doc->Render();cairo_destroy(cairoRecContext);if(suffix=="svg"&&try_emit_svg(outPath.c_str(),doc->Width(),doc->Height(),cairoRecSurface)){continue;}if(suffix=="xml"&&try_emit_xml(outPath.c_str(),cairoRecSurface)){continue;}if(suffix=="cs"&&try_emit_cairo_script(outPath.c_str(),cairoRecSurface)){continue;}if(suffix=="png"&&try_emit_png(outPath.c_str(),cairoRecSurface)){continue;}std::cerr<<"Specified format "<<suffix<<" does not match any output format available in linked Cairo"<<std::endl;shutdown_cairo_surface(cairoRecSurface);}doc.reset();renderer.reset();return 0;}
#endif
</file>

<file path="svgnative/example/testCocoaCG/Document.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import <Cocoa/Cocoa.h>

#include "svgnative/SVGDocument.h"

@interface Document : NSDocument
{
	NSLock *arrayLock;
	
	SVGNative::SVGDocument* mSVGDocument;
}

- (SVGNative::SVGDocument*)getSVGDocument;
- (void)Lock;
- (void)Unlock;

@end
</file>

<file path="svgnative/example/testCocoaCG/Document.mm">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#import "Document.h"
#include "svgnative/ports/cg/CGSVGRenderer.h"
#include "svgnative/SVGDocument.h"

#include <stdexcept>

@interface Document ()

@end

@implementation Document

- (instancetype)init {
	self = [super init];
	arrayLock = [NSLock new] ;
	if (self)
		mSVGDocument = nil;
	return self;
}

- (void) dealloc
{
	[arrayLock lock];
	if (mSVGDocument)
	{
		delete mSVGDocument;
		mSVGDocument = nil;
	}
	[arrayLock unlock];
}

+ (BOOL)autosavesInPlace {
	return YES;
}


- (NSString *)windowNibName {
	// Override returning the nib file name of the document
	// If you need to use a subclass of NSWindowController or if your document supports multiple NSWindowControllers, you should remove this method and override -makeWindowControllers instead.
	return @"Document";
}

- (void)windowControllerDidLoadNib:(NSWindowController *)aController {
	[super windowControllerDidLoadNib:aController];
	// Add any code here that needs to be executed once the windowController has loaded the document's window.
	
	if (!mSVGDocument)
		return;
	
	NSSize size;
	size.height = mSVGDocument->Height();
	size.width = mSVGDocument->Width();
	
	[[aController window] setContentSize:size];
	
	NSRect allBounds= [aController window].frame;
	
	allBounds.origin.x = 0;
	allBounds.origin.y = 0;
	allBounds.size.width = mSVGDocument->Width();
	allBounds.size.height = mSVGDocument->Height();
	[[aController window] setFrame:allBounds display:YES animate:TRUE];
}

- (NSData *)dataOfType:(NSString *)typeName error:(NSError **)outError {
	// Insert code here to write your document to data of the specified type. If outError != NULL, ensure that you create and set an appropriate error if you return nil.
	// Alternatively, you could remove this method and override -fileWrapperOfType:error:, -writeToURL:ofType:error:, or -writeToURL:ofType:forSaveOperation:originalContentsURL:error: instead.
	[NSException raise:@"UnimplementedMethod" format:@"%@ is unimplemented", NSStringFromSelector(_cmd)];
	return nil;
}


- (BOOL)readFromData:(NSData *)data ofType:(NSString *)typeName error:(NSError **)outError {
	// Insert code here to read your document from the given data of the specified type. If outError != NULL, ensure that you create and set an appropriate error if you return NO.
	// Alternatively, you could remove this method and override -readFromFileWrapper:ofType:error: or -readFromURL:ofType:error: instead.
	// If you do, you should also override -isEntireFileLoaded to return NO if the contents are lazily loaded.
	std::shared_ptr<SVGNative::CGSVGRenderer> renderer = std::make_shared<SVGNative::CGSVGRenderer>();
	NSString* myString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
	mSVGDocument = SVGNative::SVGDocument::CreateSVGDocument([myString UTF8String], renderer).release();

	return YES;
}

- (SVGNative::SVGDocument*)getSVGDocument
{
	return mSVGDocument;
}

- (void)Lock
{
	[arrayLock lock];
}

- (void)Unlock
{
	[arrayLock unlock];
}

@end
</file>

<file path="svgnative/example/testD2D/basewin.h">
#pragma once

template <class DERIVED_TYPE>
class BaseWindow
{
public:
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        DERIVED_TYPE* pThis = NULL;

        if (uMsg == WM_NCCREATE)
        {
            CREATESTRUCT* pCreate = (CREATESTRUCT*)lParam;
            pThis = (DERIVED_TYPE*)pCreate->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);

            pThis->m_hwnd = hwnd;
        }
        else
        {
            pThis = (DERIVED_TYPE*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        }
        if (pThis)
        {
            return pThis->HandleMessage(uMsg, wParam, lParam);
        }
        else
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    BaseWindow() : m_hwnd(NULL) { }

    BOOL Create(
        PCWSTR lpWindowName,
        DWORD dwStyle,
        DWORD dwExStyle = 0,
        int x = CW_USEDEFAULT,
        int y = CW_USEDEFAULT,
        int nWidth = CW_USEDEFAULT,
        int nHeight = CW_USEDEFAULT,
        HWND hWndParent = 0,
        HMENU hMenu = 0
    )
    {
        WNDCLASS wc = { 0 };

        wc.lpfnWndProc = DERIVED_TYPE::WindowProc;
        wc.hInstance = GetModuleHandle(NULL);
        wc.lpszClassName = ClassName();

        RegisterClass(&wc);

        m_hwnd = CreateWindowEx(
            dwExStyle, ClassName(), lpWindowName, dwStyle, x, y,
            nWidth, nHeight, hWndParent, hMenu, GetModuleHandle(NULL), this
        );

        return (m_hwnd ? TRUE : FALSE);
    }

    HWND Window() const { return m_hwnd; }

protected:

    virtual PCWSTR  ClassName() const = 0;
    virtual LRESULT HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;

    HWND m_hwnd;
};
</file>

<file path="svgnative/example/testD2D/CMakeLists.txt">
add_definitions(-DUNICODE -D_UNICODE)
add_definitions(-D_WIN32_IE=0x0501 -D_WIN32_WINNT=0x0501 -DWINVER=_WIN32_WINNT)

set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO")
add_definitions(/D_CRT_SECURE_NO_WARNINGS)
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /MTd")
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /MT")
set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELEASE} /MT")
set(CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_RELEASE} /MT")

add_executable("testD2D" WIN32 "TestD2D.cpp")
target_link_libraries("testD2D" PUBLIC SVGNativeViewerLib)
target_include_directories("testD2D" PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../" "${CMAKE_CURRENT_SOURCE_DIR}/../../ports/d2d")
</file>

<file path="svgnative/example/testD2D/TestD2D.cpp">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <Wincodec.h> // Windows Imaging Component (WIC)
#include <atlbase.h> // CComPtr
#include <d2d1.h>
#pragma comment(lib, "d2d1")
#pragma comment(lib, "Windowscodecs")

#include "basewin.h"
#include "svgnative/SVGDocument.h"
#include "svgnative/ports/d2d/D2DSVGRenderer.h"

namespace
{
const std::string gSVGString = R"SVG(<svg viewBox="0 0 200 200">
    <rect width="20" height="20" fill="yellow"/>
    <g transform="translate(20, 20) scale(2)" opacity="0.5">
    <rect transform="rotate(15)" width="20" height="20" fill="green"/>
    </g>
    <rect x="60" y="60" width="140" height="80" rx="40" ry="30" fill="blue"/>
    <ellipse cx="140" cy="100" rx="40" ry="20" fill="purple"/>
    <image x="60" y="40" width="129" height="24" transform="rotate(-10)" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAa4AAAAwCAAAAABshcHBAAAABGdBTUEAAw1AShHhyQAAAHJJREFUeNrt0TERwCAABLAeQ4dOnVGADNTUF0qpgR9Y4RILKTMYyRf0pAU1eYMnuVeV411sRJcudKFLF7rQpQtd6NKFLnTpQhe6dKELXbrQhS5d6EKXLnShSxe60KULXejShS506UIXunShC1260IWuc/2e+TjGRf4i2gAAAABJRU5ErkJggg=="/>
    </svg>)SVG";
}

using namespace SVGNative;

class MainWindow : public BaseWindow<MainWindow>
{
    CComPtr<IWICImagingFactory> pWICFactory;
    CComPtr<ID2D1Factory> pFactory;
    CComPtr<ID2D1HwndRenderTarget> pRenderTarget;

    CComPtr<ID2D1SolidColorBrush> pBrush;

    std::shared_ptr<SVGNative::SVGDocument> pSVGDocument;

    void    CalculateLayout();
    HRESULT CreateGraphicsResources();
    void    DiscardGraphicsResources();
    void    OnPaint();
    void    Resize();

public:

    MainWindow() = default;

    PCWSTR  ClassName() const { return L"SVGRenderer Window Class"; }
    LRESULT HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
};

// Recalculate drawing layout when the size of the window changes.

void MainWindow::CalculateLayout()
{
    if (pRenderTarget)
    {
        // Layout changes (size) for the SVGRenderer are applied in OnPaint()
    }
}

HRESULT MainWindow::CreateGraphicsResources()
{
    HRESULT hr = S_OK;
    if (!pRenderTarget)
    {
        RECT rc;
        GetClientRect(m_hwnd, &rc);

        D2D1_SIZE_U size = D2D1::SizeU(rc.right, rc.bottom);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(m_hwnd, size),
            &pRenderTarget);

        if (SUCCEEDED(hr))
        {
            pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::DarkGray), &pBrush);
        }

        if (SUCCEEDED(hr))
        {
            if (pSVGDocument)
            {
                auto renderer = static_cast<D2DSVGRenderer*>(pSVGDocument->Renderer());
                renderer->SetGraphicsContext(pWICFactory, pFactory, pRenderTarget);
            }
            else
            {
                auto renderer = std::shared_ptr<D2DSVGRenderer>(new D2DSVGRenderer);
                renderer->SetGraphicsContext(pWICFactory, pFactory, pRenderTarget);
                pSVGDocument = SVGDocument::CreateSVGDocument(gSVGString.c_str(), renderer);
            }

            CalculateLayout();
        }
    }
    return hr;
}

void MainWindow::DiscardGraphicsResources()
{
    pBrush.Release();
    pRenderTarget.Release();
}

void MainWindow::OnPaint()
{
    HRESULT hr = CreateGraphicsResources();
    if (SUCCEEDED(hr))
    {
        PAINTSTRUCT ps;
        BeginPaint(m_hwnd, &ps);

        pRenderTarget->BeginDraw();
        pRenderTarget->SetTransform(D2D1::Matrix3x2F::Identity());
        pRenderTarget->Clear(D2D1::ColorF(D2D1::ColorF::LightGray, 0.0f));

        D2D1_SIZE_F size = pRenderTarget->GetSize();
        D2D1_RECT_F clientRect = D2D1::RectF(0.0f, 0.0f, size.width, size.height);
        pRenderTarget->DrawRectangle(clientRect, pBrush);

        D2D1_POINT_2F inset = D2D1::Point2F(15.0f, 15.0f);
        D2D1_RECT_F rect = D2D1::RectF(inset.x, inset.y, size.width - inset.x, size.height - inset.y);
        pRenderTarget->DrawRectangle(rect, pBrush);
        pRenderTarget->SetTransform(D2D1::Matrix3x2F::Translation(inset.x, inset.y));
        pSVGDocument->Render(size.width - 2 * inset.x, size.height - 2 * inset.y);

        hr = pRenderTarget->EndDraw();
        if (FAILED(hr) || hr == D2DERR_RECREATE_TARGET)
        {
            DiscardGraphicsResources();
        }
        EndPaint(m_hwnd, &ps);
    }
}

void MainWindow::Resize()
{
    if (pRenderTarget)
    {
        RECT rc;
        GetClientRect(m_hwnd, &rc);

        D2D1_SIZE_U size = D2D1::SizeU(rc.right, rc.bottom);

        pRenderTarget->Resize(size);
        CalculateLayout();
        InvalidateRect(m_hwnd, NULL, FALSE);
    }
}

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow)
{
    MainWindow win;

    if (!win.Create(L"D2DSVGRenderer", WS_OVERLAPPEDWINDOW))
    {
        return 0;
    }

    ShowWindow(win.Window(), nCmdShow);

    // Run the message loop.

    MSG msg = { };
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}

LRESULT MainWindow::HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CREATE:
        {
            constexpr D2D1_FACTORY_OPTIONS factoryOptions{ D2D1_DEBUG_LEVEL_NONE };
            HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, factoryOptions, &pFactory);
            if (SUCCEEDED(hr))
            {
                CoInitializeEx(NULL, COINIT_MULTITHREADED);
                hr = CoCreateInstance(
                    CLSID_WICImagingFactory1,
                    nullptr,
                    CLSCTX_INPROC_SERVER,
                    IID_IWICImagingFactory,
                    (void**)&pWICFactory);
            }
            return SUCCEEDED(hr) ? 0 : -1;  // Fail CreateWindowEx
        }
    case WM_DESTROY:
        DiscardGraphicsResources();
        pSVGDocument.reset();
        pWICFactory.Release();
        CoUninitialize();
        pFactory.Release();
        PostQuitMessage(0);
        return 0;

    case WM_PAINT:
        OnPaint();
        return 0;

        // Other messages not shown...

    case WM_SIZE:
        Resize();
        return 0;
    }
    return DefWindowProc(m_hwnd, uMsg, wParam, lParam);
}
</file>

<file path="svgnative/example/testD2D/TestD2D.h">
#ifndef SVG_RENDERER_H
#define SVG_RENDERER_H
#define WIN32_LEAN_AND_MEAN
#include<windows.h>
#include<Wincodec.h>
#include<atlbase.h>
#include<d2d1.h>
#pragma comment(lib,"d2d1")
#pragma comment(lib,"Windowscodecs")
#include "basewin.h"
#include "svgnative/SVGDocument.h"
#include "svgnative/ports/d2d/D2DSVGRenderer.h"
namespace{const std::string gSVGString=R"SVG(<svg viewBox="0 0 200 200"><rect width="20" height="20" fill="yellow"/><g transform="translate(20,20)scale(2)" opacity="0.5"><rect transform="rotate(15)" width="20" height="20" fill="green"/></g><rect x="60" y="60" width="140" height="80" rx="40" ry="30" fill="blue"/><ellipse cx="140" cy="100" rx="40" ry="20" fill="purple"/><image x="60" y="40" width="129" height="24" transform="rotate(-10)" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAa4AAAAwCAAAAABshcHBAAAABGdBTUEAAw1AShHhyQAAAHJJREFUeNrt0TERwCAABLAeQ4dOnVGADNTUF0qpgR9Y4RILKTMYyRf0pAU1eYMnuVeV411sRJcudKFLF7rQpQtd6NKFLnTpQhe6dKELXbrQhS5d6EKXLnShSxe60KULXejShS506UIXunShC1260IWuc/2e+TjGRf4i2gAAAABJRU5ErkJggg=="/></svg>)SVG";}using namespace SVGNative;class MainWindow:public BaseWindow<MainWindow>{CComPtr<IWICImagingFactory>pWICFactory;CComPtr<ID2D1Factory>pFactory;CComPtr<ID2D1HwndRenderTarget>pRenderTarget;CComPtr<ID2D1SolidColorBrush>pBrush;std::shared_ptr<SVGNative::SVGDocument>pSVGDocument;void CalculateLayout();HRESULT CreateGraphicsResources();void DiscardGraphicsResources();void OnPaint();void Resize();public:MainWindow()=default;PCWSTR ClassName()const{return L"SVGRenderer Window Class";}LRESULT HandleMessage(UINT uMsg,WPARAM wParam,LPARAM lParam);};void MainWindow::CalculateLayout(){if(pRenderTarget){}}HRESULT MainWindow::CreateGraphicsResources(){HRESULT hr=S_OK;if(!pRenderTarget){RECT rc;GetClientRect(m_hwnd,&rc);D2D1_SIZE_U size=D2D1::SizeU(rc.right,rc.bottom);hr=pFactory->CreateHwndRenderTarget(D2D1::RenderTargetProperties(),D2D1::HwndRenderTargetProperties(m_hwnd,size),&pRenderTarget);if(SUCCEEDED(hr)){pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::DarkGray),&pBrush);}if(SUCCEEDED(hr)){if(pSVGDocument){auto renderer=static_cast<D2DSVGRenderer*>(pSVGDocument->Renderer());renderer->SetGraphicsContext(pWICFactory,pFactory,pRenderTarget);}else{auto renderer=std::shared_ptr<D2DSVGRenderer>(new D2DSVGRenderer);renderer->SetGraphicsContext(pWICFactory,pFactory,pRenderTarget);pSVGDocument=SVGDocument::CreateSVGDocument(gSVGString.c_str(),renderer);}CalculateLayout();}}return hr;}void MainWindow::DiscardGraphicsResources(){pBrush.Release();pRenderTarget.Release();}void MainWindow::OnPaint(){HRESULT hr=CreateGraphicsResources();if(SUCCEEDED(hr)){PAINTSTRUCT ps;BeginPaint(m_hwnd,&ps);pRenderTarget->BeginDraw();pRenderTarget->SetTransform(D2D1::Matrix3x2F::Identity());pRenderTarget->Clear(D2D1::ColorF(D2D1::ColorF::LightGray,0.0f));D2D1_SIZE_F size=pRenderTarget->GetSize();D2D1_RECT_F clientRect=D2D1::RectF(0.0f,0.0f,size.width,size.height);pRenderTarget->DrawRectangle(clientRect,pBrush);D2D1_POINT_2F inset=D2D1::Point2F(15.0f,15.0f);D2D1_RECT_F rect=D2D1::RectF(inset.x,inset.y,size.width-inset.x,size.height-inset.y);pRenderTarget->DrawRectangle(rect,pBrush);pRenderTarget->SetTransform(D2D1::Matrix3x2F::Translation(inset.x,inset.y));pSVGDocument->Render(size.width-2*inset.x,size.height-2*inset.y);hr=pRenderTarget->EndDraw();if(FAILED(hr)||hr==D2DERR_RECREATE_TARGET){DiscardGraphicsResources();}EndPaint(m_hwnd,&ps);}}void MainWindow::Resize(){if(pRenderTarget){RECT rc;GetClientRect(m_hwnd,&rc);D2D1_SIZE_U size=D2D1::SizeU(rc.right,rc.bottom);pRenderTarget->Resize(size);CalculateLayout();InvalidateRect(m_hwnd,NULL,FALSE);}}int WINAPI wWinMain(HINSTANCE hInstance,HINSTANCE,PWSTR,int nCmdShow){MainWindow win;if(!win.Create(L"D2DSVGRenderer",WS_OVERLAPPEDWINDOW)){return 0;}ShowWindow(win.Window(),nCmdShow);MSG msg={};while(GetMessage(&msg,NULL,0,0)){TranslateMessage(&msg);DispatchMessage(&msg);}return 0;}LRESULT MainWindow::HandleMessage(UINT uMsg,WPARAM wParam,LPARAM lParam){switch(uMsg){case WM_CREATE:{constexpr D2D1_FACTORY_OPTIONS factoryOptions{D2D1_DEBUG_LEVEL_NONE};HRESULT hr=D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED,factoryOptions,&pFactory);if(SUCCEEDED(hr)){CoInitializeEx(NULL,COINIT_MULTITHREADED);hr=CoCreateInstance(CLSID_WICImagingFactory1,nullptr,CLSCTX_INPROC_SERVER,IID_IWICImagingFactory,(void**)&pWICFactory);}return SUCCEEDED(hr)?0:-1;}case WM_DESTROY:DiscardGraphicsResources();pSVGDocument.reset();pWICFactory.Release();CoUninitialize();pFactory.Release();PostQuitMessage(0);return 0;case WM_PAINT:OnPaint();return 0;case WM_SIZE:Resize();return 0;}return DefWindowProc(m_hwnd,uMsg,wParam,lParam);}
#endif
</file>

<file path="svgnative/example/testGDIPlus/TestGDIPlus.h">
#define WIN32_LEAN_AND_MEAN
#include<tchar.h>
#include<windows.h>
#include<unknwn.h>
#include<Gdiplus.h>
#include<memory>
#include "svgnative/SVGDocument.h"
#include "svgnative/ports/gdiplus/GDIPlusSVGRenderer.h"
#pragma comment(lib,"Gdiplus.lib")
using namespace Gdiplus;using namespace SVGNative;static HWND hwndMain=NULL;static const std::string gSVGString="<svg viewBox=\"0 0 200 200\"><circle cx=\"100\" cy=\"100\" r=\"100\" fill=\"yellow\"/></svg>";static void MainWinPaintToCanvas(HDC hdc){Graphics graphics(hdc);auto renderer=std::shared_ptr<GDIPlusSVGRenderer>(new GDIPlusSVGRenderer);renderer->SetGraphicsContext(&graphics);auto svgDocument=SVGDocument::CreateSVGDocument(gSVGString.c_str(),renderer);svgDocument->Render();}static LRESULT CALLBACK MainWinProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam){switch(uMsg){case WM_PAINT:{PAINTSTRUCT ps;HDC hdc;hdc=BeginPaint(hwndMain,&ps);MainWinPaintToCanvas(hdc);EndPaint(hwndMain,&ps);return 0;}case WM_PRINTCLIENT:PostQuitMessage(0);return 0;case WM_DESTROY:PostQuitMessage(0);return 0;}return DefWindowProc(hwnd,uMsg,wParam,lParam);}int APIENTRY_tWinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPTSTR lpCmdLine,int nCmdShow){WNDCLASS wc={0};MSG msg;GdiplusStartupInput gdiplusStartupInput;ULONG_PTR gdiplusToken;GdiplusStartup(&gdiplusToken,&gdiplusStartupInput,NULL);wc.lpfnWndProc=MainWinProc;wc.hInstance=hInstance;wc.hCursor=LoadCursor(NULL,IDC_ARROW);wc.hbrBackground=(HBRUSH)(COLOR_BTNFACE+1);wc.lpszClassName=_T("main_window");RegisterClass(&wc);hwndMain=CreateWindow(_T("main_window"),_T("LibWinDraw Example:Simple Draw"),WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,550,350,NULL,NULL,hInstance,NULL);SendMessage(hwndMain,WM_SETFONT,(WPARAM)GetStockObject(DEFAULT_GUI_FONT),MAKELPARAM(TRUE,0));ShowWindow(hwndMain,nCmdShow);while(GetMessage(&msg,NULL,0,0)){if(IsDialogMessage(hwndMain,&msg))continue;TranslateMessage(&msg);DispatchMessage(&msg);}GdiplusShutdown(gdiplusToken);return(int)msg.wParam;}
</file>

<file path="svgnative/example/testSkia/CMakeLists.txt">
add_executable(testSkia TestSkia.cpp)

target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/stylesheet/include")
target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/skia/include/config")
target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/skia/include/core")
target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/skia/include/effects")
target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/skia/include/encode")
target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/skia/include/gpu")
target_include_directories(testSkia PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../ports/skia")

target_link_libraries(testSkia PUBLIC SVGNativeViewerLib "${SKIA_LIBRARY_PATH}")
if(APPLE)
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -framework Cocoa")
endif()
</file>

<file path="svgnative/example/testSkia/TestSkia.h">
#ifndef HEADER_FILE_H
#define HEADER_FILE_H
#include "svgnative/SVGDocument.h"
#include "SkData.h"
#include "SkEncodedImageFormat.h"
#include "SkImage.h"
#include "SkStream.h"
#include "SkSurface.h"
#include "svgnative/ports/skia/SkiaSVGRenderer.h"
#include<fstream>
#include<iostream>
#include<string>
int main(int argc,char*const argv[]){if(argc!=3){std::cout<<"Incorrect number of arguments."<<std::endl;return 0;}std::string svgInput{};std::ifstream input(argv[1]);if(!input){std::cout<<"Error!Could not open input file."<<std::endl;exit(EXIT_FAILURE);}for(std::string line;std::getline(input,line);)svgInput.append(line);input.close();auto renderer=std::make_shared<SVGNative::SkiaSVGRenderer>();auto doc=std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(),renderer));{auto skRasterSurface=SkSurface::MakeRasterN32Premul(doc->Width(),doc->Height());auto skRasterCanvas=skRasterSurface->getCanvas();renderer->SetSkCanvas(skRasterCanvas);SVGNative::Rect bounds{0,0,0,0};doc->GetBoundingBox(bounds);}auto skRasterSurface=SkSurface::MakeRasterN32Premul(doc->Width(),doc->Height());auto skRasterCanvas=skRasterSurface->getCanvas();renderer->SetSkCanvas(skRasterCanvas);doc->Render();auto skImage=skRasterSurface->makeImageSnapshot();if(!skImage)return 0;sk_sp<SkData>pngData(skImage->encodeToData(SkEncodedImageFormat::kPNG,100));if(!pngData)return 0;SkFILEWStream out(argv[2]);(void)out.write(pngData->data(),pngData->size());return 0;}
#endif
</file>

<file path="svgnative/example/testText/TestMain.h">
#ifndef SVG_HEADER_H
#define SVG_HEADER_H
#include "svgnative/SVGDocument.h"
#include "svgnative/ports/string/StringSVGRenderer.h"
#include<fstream>
#include<iostream>
#include<string>
int main(int argc,char*const argv[]){if(argc!=3&&argc!=4){std::cout<<"Incorrect number of arguments."<<std::endl;return 0;}std::string svgInput{};std::ifstream input(argv[1]);if(!input){std::cout<<"Error!Could not open input file."<<std::endl;exit(EXIT_FAILURE);}for(std::string line;std::getline(input,line);)svgInput.append(line);input.close();SVGNative::ColorMap colorMap={{"test-red",{{0.502,0.0,0.0,1.0}}},{"test-green",{{0.0,0.502,0.0,1.0}}},{"test-blue",{{0.0,0.0,1.0,1.0}}}};auto renderer=std::make_shared<SVGNative::StringSVGRenderer>();auto doc=std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(),renderer));if(!doc){std::cout<<"Error!Could not parse document."<<std::endl;exit(EXIT_FAILURE);}if(argc==3)doc->Render(colorMap);else{std::string id{argv[3]};doc->Render(id.c_str(),colorMap);}std::fstream outputStream;outputStream.open(argv[2],std::fstream::out);if(!outputStream){std::cout<<"Error!Could not write file."<<std::endl;exit(EXIT_FAILURE);}std::string outputString{renderer->String()};outputStream<<outputString;outputStream.close();return 0;}
#endif
</file>

<file path="svgnative/include/svgnative/ports/cairo/CairoSVGRenderer.h">
/*
Copyright 2019 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_CairoSVGRenderer_h
#define SVGViewer_CairoSVGRenderer_h

#include <list>
#include "svgnative/SVGRenderer.h"
#include "cairo.h"

namespace SVGNative
{

  // SkiaSVGPath object is able to be amended, but Cairo has no API to append something
  // to existing cairo_path_t object. Thus, we hold cairo_t object. Its surface could
  // be retrieved in later, by cairo_get_target().

class CairoSVGPath final : public Path
{
public:
    CairoSVGPath();
    ~CairoSVGPath();

    void Rect(float x, float y, float width, float height) override;
    void RoundedRect(float x, float y, float width, float height, float rx, float ry) override;
    void Ellipse(float cx, float cy, float rx, float ry) override;

    void MoveTo(float x, float y) override;
    void LineTo(float x, float y) override;
    void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) override;
    void CurveToV(float x2, float y2, float x3, float y3) override;
    void ClosePath() override;

    cairo_t* mPathCtx{};

private:
    float mCurrentX{};
    float mCurrentY{};
};

class CairoSVGTransform final : public Transform
{
public:
    CairoSVGTransform(float a, float b, float c, float d, float tx, float ty);

    void Set(float a, float b, float c, float d, float tx, float ty) override;
    void Rotate(float r) override;
    void Translate(float tx, float ty) override;
    void Scale(float sx, float sy) override;
    void Concat(float a, float b, float c, float d, float tx, float ty) override;

    cairo_matrix_t mMatrix;
};

class CairoSVGImageData final : public ImageData
{
public:
    CairoSVGImageData(const std::string& base64, ImageEncoding encoding);
    ~CairoSVGImageData();

    float Width() const override;

    float Height() const override;


    cairo_surface_t* mImageData{};
};

class SVG_IMP_EXP CairoSVGRenderer final : public SVGRenderer
{
public:
    CairoSVGRenderer();
    ~CairoSVGRenderer();

    std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding encoding) override { return std::unique_ptr<CairoSVGImageData>(new CairoSVGImageData(base64, encoding)); }

    std::unique_ptr<Path> CreatePath() override { return std::unique_ptr<CairoSVGPath>(new CairoSVGPath); }

    std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) override
    {
        return std::unique_ptr<CairoSVGTransform>(new CairoSVGTransform(a, b, c, d, tx, ty));
    }

    void Save(const GraphicStyle& graphicStyle) override;
    void Restore() override;

    void DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;
    void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) override;

    void SetCairo(cairo_t* cairo);

private:
    cairo_t* mCairo{};
};

} // namespace SVGNative

#endif // SVGViewer_CairoSVGRenderer_h
</file>

<file path="svgnative/include/svgnative/ports/cg/CGSVGRenderer.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_CGSVGRenderer_h
#define SVGViewer_CGSVGRenderer_h

#include "svgnative/SVGRenderer.h"
#include <CoreGraphics/CoreGraphics.h>

namespace SVGNative
{
class CGSVGPath final : public Path
{
public:
    CGSVGPath();
    ~CGSVGPath();

    void Rect(float x, float y, float width, float height) override;
    void RoundedRect(float x, float y, float width, float height, float rx, float ry) override;
    void Ellipse(float cx, float cy, float rx, float ry) override;

    void MoveTo(float x, float y) override;
    void LineTo(float x, float y) override;
    void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) override;
    void CurveToV(float x2, float y2, float x3, float y3) override;
    void ClosePath() override;

    CGMutablePathRef mPath;

private:
    float mCurrentX{};
    float mCurrentY{};
};

class CGSVGTransform final : public Transform
{
public:
    CGSVGTransform(float a, float b, float c, float d, float tx, float ty);

    void Set(float a, float b, float c, float d, float tx, float ty) override;
    void Rotate(float r) override;
    void Translate(float tx, float ty) override;
    void Scale(float sx, float sy) override;
    void Concat(float a, float b, float c, float d, float tx, float ty) override;

    CGAffineTransform mTransform;
};

class CGSVGImageData final : public ImageData
{
public:
    CGSVGImageData(const std::string& base64, ImageEncoding encoding);

    ~CGSVGImageData();

    float Width() const override;

    float Height() const override;

    CGImageRef mImage{};
};

class SVG_IMP_EXP CGSVGRenderer final : public SVGRenderer
{
public:
    CGSVGRenderer();

    virtual ~CGSVGRenderer() { ReleaseGraphicsContext(); }

    std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding encoding) override { return std::unique_ptr<CGSVGImageData>(new CGSVGImageData(base64, encoding)); }

    std::unique_ptr<Path> CreatePath() override { return std::unique_ptr<CGSVGPath>(new CGSVGPath); }

    std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) override
    {
        return std::unique_ptr<CGSVGTransform>(new CGSVGTransform(a, b, c, d, tx, ty));
    }

    void Save(const GraphicStyle& graphicStyle) override;
    void Restore() override;

    void DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;
    void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) override;

    void SetGraphicsContext(CGContextRef context)
    {
        ReleaseGraphicsContext();
        mContext = CGContextRetain(context);
    }

    void ReleaseGraphicsContext()
    {
        if (!mContext)
            return;

        CGContextRelease(mContext);
        mContext = nullptr;
    }

private:
    void DrawGradientToContext(const Gradient& gradient, float opacity);

    CGContextRef mContext{};
};

} // namespace SVGNative

#endif // SVGViewer_CGSVGRenderer_h
</file>

<file path="svgnative/include/svgnative/ports/d2d/D2DSVGRenderer.h">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_D2DSVGRenderer_h
#define SVGViewer_D2DSVGRenderer_h

#include "svgnative/SVGRenderer.h"
#include <d2d1.h>
#include <Wincodec.h> // Windows Imaging Component (WIC)
#include <stack>
#include <atlbase.h> // CComPtr

namespace SVGNative
{
class D2DSVGPath final : public Path
{
public:
    D2DSVGPath(CComPtr<ID2D1Factory>);
    ~D2DSVGPath();

    void Rect(float x, float y, float width, float height) override;
    void RoundedRect(float x, float y, float width, float height, float rx, float ry) override;
    void Ellipse(float cx, float cy, float rx, float ry) override;

    void MoveTo(float x, float y) override;
    void LineTo(float x, float y) override;
    void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) override;
    void CurveToV(float x2, float y2, float x3, float y3) override;
    void ClosePath() override;

    CComPtr<ID2D1PathGeometry> GetGraphicsPath();

private:
    void AddArc(float x, float y, float dx, float dy);
    void ClosePathSink();

private:
    CComPtr<ID2D1PathGeometry> mPath;
    CComPtr<ID2D1GeometrySink> mSink;
    bool mHasOpenFigure{ false };
    float mCurrentX{};
    float mCurrentY{};
};

class D2DSVGTransform final : public Transform
{
public:
    D2DSVGTransform(float a, float b, float c, float d, float tx, float ty);

    void Set(float a, float b, float c, float d, float tx, float ty) override;
    void Rotate(float r) override;
    void Translate(float tx, float ty) override;
    void Scale(float sx, float sy) override;
    void Concat(float a, float b, float c, float d, float tx, float ty) override;

    const D2D1::Matrix3x2F& GetMatrix() const;

private:
    D2D1::Matrix3x2F mTransform;
};

class D2DSVGImageData final : public ImageData
{
public:
    D2DSVGImageData(CComPtr<IWICBitmapSource> bitmapSource);
    ~D2DSVGImageData();

    float Width() const override;
    float Height() const override;

    CComPtr<IWICBitmapSource> GetBitmapSource() const;

private:
    float mWidth{};
    float mHeight{};
    CComPtr<IWICBitmapSource> mBitmapSource;
};

class SVG_IMP_EXP D2DSVGRenderer final : public SVGRenderer
{
public:
    D2DSVGRenderer();

    virtual ~D2DSVGRenderer()
    { 
    }

    std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding encoding) override;

    std::unique_ptr<Path> CreatePath() override;

    std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) override;

    void Save(const GraphicStyle& graphicStyle) override;
    void Restore() override;

    void DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;
    void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) override;

    void SetGraphicsContext(IWICImagingFactory* pWICFactory, ID2D1Factory* pD2DFactory, ID2D1RenderTarget* renderTarget)
    {
        mWICFactory = pWICFactory;
        mD2DFactory = pD2DFactory;
        mContext = renderTarget;
    }

    void ReleaseGraphicsContext()
    {
        mD2DFactory.Release();
        mWICFactory.Release();
    }

private:
    CComPtr<ID2D1Brush> D2DSVGRenderer::CreateBrush(const Paint& paint);

    CComPtr<ID2D1RenderTarget> mContext;
    CComPtr<ID2D1Factory> mD2DFactory;
    CComPtr<IWICImagingFactory> mWICFactory;

    std::stack<D2D1_MATRIX_3X2_F> mContextTransform;
};

} // namespace SVGNative

#endif // SVGViewer_D2DSVGRenderer_h
</file>

<file path="svgnative/include/svgnative/ports/string/StringSVGRenderer.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_StringSVGRenderer_h
#define SVGViewer_StringSVGRenderer_h

#include "svgnative/SVGRenderer.h"

#include <iostream>
#include <sstream>
#include <string>

namespace SVGNative
{
class StringSVGPath final : public Path
{
public:
    StringSVGPath();

    void Rect(float x, float y, float width, float height) override;
    void RoundedRect(float x, float y, float width, float height, float rx, float ry) override;
    void Ellipse(float cx, float cy, float rx, float ry) override;

    void MoveTo(float x, float y) override;
    void LineTo(float x, float y) override;
    void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) override;
    void CurveToV(float x2, float y2, float x3, float y3) override;
    void ClosePath() override;

    std::string String() const;

private:
    std::ostringstream mStringStream;
};

class StringSVGTransform final : public Transform
{
public:
    struct AffineTransform
    {
        AffineTransform() = default;
        AffineTransform(float aA, float aB, float aC, float aD, float aE, float aF)
            : a{aA}
            , b{aB}
            , c{aC}
            , d{aD}
            , e{aE}
            , f{aF}
        {
        }
        float a{1};
        float b{0};
        float c{0};
        float d{1};
        float e{0};
        float f{0};
    };

    StringSVGTransform(float a, float b, float c, float d, float tx, float ty);

    void Set(float a, float b, float c, float d, float tx, float ty) override;
    void Rotate(float r) override;
    void Translate(float tx, float ty) override;
    void Scale(float sx, float sy) override;
    void Concat(float a, float b, float c, float d, float tx, float ty) override;

    std::string String() const;

private:
    void Multiply(const AffineTransform& o);

private:
    AffineTransform mTransform{};
};

class StringSVGImageData final : public ImageData
{
public:
    StringSVGImageData(const std::string& base64, ImageEncoding encoding)
        : mBase64{base64}
    {
        mBase64.insert(0, encoding == ImageEncoding::kPNG ? "(PNG) " : "(JPEG) ");
    }

    // We are not able to encode PNG images here so we return a fixed size.
    float Width() const override { return 160.0f; }

    float Height() const override { return 110.0f; }

    std::string String() const { return mBase64; }

private:
    std::string mBase64;
};

class SVG_IMP_EXP StringSVGRenderer final : public SVGRenderer
{
public:
    StringSVGRenderer();

    std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding encoding) override { return std::unique_ptr<StringSVGImageData>(new StringSVGImageData(base64, encoding)); }

    std::unique_ptr<Path> CreatePath() override;

    std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) override;

    void Save(const GraphicStyle& graphicStyle) override;
    void Restore() override;

    void DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;
    void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) override;

    std::string String() const;

private:
    void IncIndent();
    void DecIndent();

    void WriteNewline();
    void WriteIndent();

    void WriteFill(const FillStyle& fillStyle);
    void WriteStroke(const StrokeStyle& strokeStyle);
    void WriteGraphic(const GraphicStyle& graphicStyle);
    void WritePaint(const Paint& paint);

    size_t mIndent{};
    std::ostringstream mStringStream;
};

} // namespace SVGNative

#endif // SVGViewer_StringSVGRenderer_h
</file>

<file path="svgnative/include/svgnative/SVGNativeCWrapper.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_CWrapper_h
#define SVGViewer_CWrapper_h

#include "Config.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>

/**
 * A renderer type used by an SVG Native context.
 */
typedef enum svg_native_renderer_type_t_ {
    SVG_RENDERER_UNKNOWN,
    SVG_RENDERER_CAIRO,
    SVG_RENDERER_CG,
    SVG_RENDERER_GDIPLUS,
    SVG_RENDERER_SKIA,
    SVG_RENDERER_STRING
} svg_native_renderer_type_t;

typedef struct svg_native_t_ svg_native_t;
typedef struct svg_native_color_map_t_ svg_native_color_map_t;
typedef void svg_native_renderer_t;

/**
 * Create a new color map. Multiple color maps can be created in parallel.
 * @return Pointer to the newly created color map. May be NULL on error.
 */
SVG_IMP_EXP svg_native_color_map_t* svg_native_color_map_create();
/**
 * Add a color with the given name key and the float values for red, green, blue and alpha
 * to the given color map.
 * If the name key is in use already, no color gets added.
 * All color values should be in the range [0..1].
 * @param color_map A pointer to an existing color map.
 * @param color_key The nama key for the new color to add.
 * @param red A float value in the range [0..1].
 * @param blue A float value in the range [0..1].
 * @param green A float value in the range [0..1].
 * @param alpha A float value in the range [0..1].
 */
SVG_IMP_EXP void svg_native_color_map_add(svg_native_color_map_t* color_map, const char* color_key, float red, float green, float blue, float alpha);
/**
 * Cleans up the color map with the given pointer. Do not use the pointer afterwards.
 */
SVG_IMP_EXP void svg_native_color_map_destroy(svg_native_color_map_t* color_map);


/**
 * Creates a new SVG Native context.
 * @param render_type The renderer type used for this SVG Native context instance.
 * @param document_string The SVG document to parse as string. Should be UTF8 encoded. UTF16 maybe supported.
 * @return The pointer to the newly created SVG Native context. May be NULL on error.
 */
SVG_IMP_EXP svg_native_t* svg_native_create(svg_native_renderer_type_t renderer_type, const char* document_string);

/**
 * Sets a color map to the provided SVG Native context. Only one color map can be used at
 * a time. Calling this function again will replace the currently used color map.
 * @param sn The SVG Native context.
 * @param color_map A pointer to a color map.
 */
SVG_IMP_EXP void svg_native_set_color_map(svg_native_t* sn, svg_native_color_map_t* color_map);
/**
 * Sets the native renderer used for the provided SVG Native context. The renderer
 * must match the renderer type specified for the provided SVG Native context.
 * Native renderers may be of type:
 * - `cairo_t*`
 * - `CGContextRef`
 * - `Gdiplus::Graphics*`
 * - `SkCanvas*`
 *
 * @param sn The SVG Native context.
 * @param renderer A pointer to the native renderer used by the provided SVG Native context.
 */
SVG_IMP_EXP void svg_native_set_renderer(svg_native_t* sn, svg_native_renderer_t* renderer);

/**
 * The horizontal dimension of the SVG canvas.
 * @param sn The SVG Native context.
 * @return The horizonal dimension.
 */
SVG_IMP_EXP float svg_native_canvas_width(svg_native_t* sn);
/**
 * The vertical dimension of the SVG canvas.
 * @param sn The SVG Native context.
 * @return The vertical dimension.
 */
SVG_IMP_EXP float svg_native_canvas_height(svg_native_t* sn);

/**
 * Renders the parsed SVG document of the provided SVG Native context to the
 * renderer of that context.
 * A renderer must be set first.
 * @param sn The SVG Native context.
 */
SVG_IMP_EXP void svg_native_render(svg_native_t* sn);
/**
 * Renders the parsed SVG document of the provided SVG Native context to the
 * renderer of that context. The SVG document will be rendered to fit into
 * the dimensions of the passed width and height arguments.
 * A renderer must be set first.
 * @param sn The SVG Native context.
 * @param width The horizontal dimension the SVG document needs to fit into. Must not be 0 or negetive.
 * @param height The vertical dimension the SVG document needs to fit into. Must not be 0 or negetive.
 */
SVG_IMP_EXP void svg_native_render_size(svg_native_t* sn, float width, float height);

#ifdef USE_TEXT
/**
 * Copy the output of Text port to new buffer.
 * The copied content is NULL-terminated, and the client must free it after using it.
 * @param sn The SVG Native context.
 * @param buff The pointer to store the address to the copied content.
 * @param length The pointer to store the content length without the last NULL.
 */
SVG_IMP_EXP void svg_native_get_output(svg_native_t* sn, char** buff, size_t* length);
#endif

/**
 * Destroys the provided SVG Native context. Do not use the pointer afterwards.
 */
SVG_IMP_EXP void svg_native_destroy(svg_native_t*);

#ifdef __cplusplus
}
#endif

#endif /* SVGViewer_CWrapper_h */
</file>

<file path="svgnative/src/ports/cairo/CairoImageInfo.c">
/*
Copyright 2019 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/* FIXME: this C source should be compiled by the compiler supporting C99 or later,
 *        due to some variable declarations in the middle of the functions
 */

#include "CairoImageInfo.h"
#include <string.h>

/* JPEG (image/jpeg)
 */
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <jpeglib.h>

struct _cairo_jpeg_error_mgr
{
    struct jpeg_error_mgr pub;
    jmp_buf setjmp_buffer;
};

typedef struct _cairo_jpeg_error_mgr * _cairo_jpeg_error_ptr;

METHODDEF(void)
_cairo_jpeg_error_exit(j_common_ptr cinfo)
{
    _cairo_jpeg_error_ptr _cairo_jpeg_err = (_cairo_jpeg_error_ptr)cinfo->err;
    (*cinfo->err->output_message)(cinfo);
    longjmp(_cairo_jpeg_err->setjmp_buffer, 1);
}

cairo_surface_t *
_cairo_image_surface_create_from_jpeg_stream(const unsigned char* data,
                                             unsigned int length)
{
    cairo_surface_t* _cairo_jpeg_surface = NULL;

    struct jpeg_decompress_struct cinfo;
    struct _cairo_jpeg_error_mgr jerr;
    cinfo.err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = _cairo_jpeg_error_exit;

    unsigned char* outBuff = NULL;
    if (setjmp(jerr.setjmp_buffer))
    {
        jpeg_destroy_decompress(&cinfo);
        if (_cairo_jpeg_surface)
        {
            cairo_surface_destroy(_cairo_jpeg_surface);
        };
        return NULL;
    };

    jpeg_create_decompress(&cinfo);
    jpeg_mem_src(&cinfo, data, length);
    jpeg_read_header(&cinfo, TRUE);

    cairo_format_t cairo_color_format;
    switch (cinfo.out_color_space)
    {
    case JCS_GRAYSCALE:
        /* Cairo has no special format for grayscale, we must use RGB24 */
        cairo_color_format = CAIRO_FORMAT_RGB24;
        break;
#ifdef JCS_EXT_ARGB
    case JCS_EXT_ARGB:
        cairo_color_format = CAIRO_FORMAT_ARGB32;
        break;
#endif
    case JCS_RGB:
    default:
        cairo_color_format = CAIRO_FORMAT_RGB24;
    };

    /* cinfo.image_width, cinfo.image_height, cinfo.num_components are already filled, but
     * cinfo.output_width, cinfo.output_height, cinfo.output_components are not, because
     * they are output parameters
     */
    jpeg_start_decompress(&cinfo);

    int jpeg_row_stride = cinfo.output_width * cinfo.output_components;
    int cairo_row_stride = cairo_format_stride_for_width(cairo_color_format, cinfo.output_width);

    size_t outLimit = cairo_row_stride * cinfo.output_height;
    outBuff = (unsigned char*)malloc(outLimit);
    bzero(outBuff, outLimit);
    size_t outCur = 0;

    JSAMPARRAY buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, jpeg_row_stride, 1);

    while (cinfo.output_scanline < cinfo.output_height)
    {
        jpeg_read_scanlines(&cinfo, buffer, 1);
        for (int ipxl = 0; ipxl < cinfo.output_width; ipxl++)
        {
            size_t jpeg_buff_offset = (ipxl * cinfo.output_components); 
            unsigned long rgb = 0;
            for (int iclr = 0; iclr < cinfo.output_components; iclr++)
                rgb = (rgb << 8) | buffer[0][jpeg_buff_offset + iclr];

            /* Assume single component image is grayscale */
            if (cinfo.output_components == 1)
                ((uint32_t*)(outBuff + outCur))[ipxl] = (rgb << 16 | rgb << 8 | rgb);
            else
                ((uint32_t*)(outBuff + outCur))[ipxl] = rgb;
        }
        outCur += cairo_row_stride;
    };
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);

    _cairo_jpeg_surface = cairo_image_surface_create_for_data(outBuff, cairo_color_format, cinfo.output_width, cinfo.output_height, cairo_row_stride);

    /* transfer ownership of pixmap buffer from this caller to the surface,
     * and let the surface free it when the owner surface is being destroyed.
     */
    cairo_surface_set_mime_data(_cairo_jpeg_surface, "image/x-pixmap", outBuff, outLimit, free, (void*)outBuff);

    return _cairo_jpeg_surface;
}

/* PNG (image/png)
 */

cairo_status_t
_png_blob_read_func(void           *closure,
                    unsigned char  *data,
                    unsigned int    length)
{
    _png_blob_closure_t  *png_blob_closure = (_png_blob_closure_t*)closure;
    
    if (png_blob_closure->limit <= png_blob_closure->cur_pos)
        return CAIRO_STATUS_READ_ERROR;

    if (png_blob_closure->limit <= png_blob_closure->cur_pos + length)
    {
        memset(data, 0, length); 
        length = png_blob_closure->limit - png_blob_closure->cur_pos;
    }

    memcpy(data, png_blob_closure->blob + png_blob_closure->cur_pos, length); 
    png_blob_closure->cur_pos += length;
    return CAIRO_STATUS_SUCCESS;
}
</file>

<file path="svgnative/src/ports/cairo/CairoImageInfo.h">
/*
Copyright 2019 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <stdint.h>
#include "cairo.h"

cairo_surface_t *
_cairo_image_surface_create_from_jpeg_stream(const unsigned char* data,
                                             unsigned int length);

typedef struct _png_blob_closure
{
    const unsigned char*  blob;
    size_t                cur_pos;
    size_t                limit;
} _png_blob_closure_t;

cairo_status_t
_png_blob_read_func(void           *closure,
                    unsigned char  *data,
                    unsigned int    length);

#ifdef __cplusplus
}
#endif
</file>

<file path="svgnative/src/ports/cairo/CairoSVGRenderer.h">
```cpp
#ifndef CAIRO_SVG_RENDERER_H
#define CAIRO_SVG_RENDERER_H
#include "svgnative/ports/cairo/CairoSVGRenderer.h"
#include "base64.h"
#include "svgnative/Config.h"
#include "cairo.h"
#include<math.h>
#include "CairoImageInfo.h"
namespace SVGNative{class CairoSVGPath{public:CairoSVGPath(){
#if CAIRO_HAS_IMAGE_SURFACE
cairo_surface_t*sf=cairo_image_surface_create(CAIRO_FORMAT_ARGB32,1,1);
#elif CAIRO_HAS_RECORDING_SURFACE
cairo_surface_t*sf=cairo_recording_surface_create(CAIRO_CONTENT_COLOR_ALPHA,NULL);
#endif
mPathCtx=cairo_create(sf);}~CairoSVGPath(){cairo_surface_t*sf=cairo_get_target(mPathCtx);cairo_destroy(mPathCtx);cairo_surface_finish(sf);cairo_surface_destroy(sf);}void Rect(float x,float y,float width,float height){cairo_rectangle(mPathCtx,x,y,width,height);cairo_close_path(mPathCtx);}inline double deg2rad(double deg){return(deg*M_PI/180.0);}inline void cairo_arc_rx_ry(cairo_t*cr,float cx,float cy,float rx,float ry,float rad1,float rad2){if(rx==ry){cairo_arc(cr,cx,cy,rx,rad1,rad2);}else{cairo_save(cr);cairo_translate(cr,cx,cy);cairo_scale(cr,rx,ry);cairo_arc(cr,0,0,1,rad1,rad2);cairo_restore(cr);}}void RoundedRect(float x,float y,float width,float height,float rx,float ry){cairo_new_sub_path(mPathCtx);cairo_arc
</file>

<file path="svgnative/src/ports/cg/CGSVGRenderer.h">
#ifndef MY_HEADER_H
#define MY_HEADER_H
#include<math.h>
#include "svgnative/ports/cg/CGSVGRenderer.h"
#include "base64.h"
#include "svgnative/Config.h"
namespace SVGNative{class CGSVGPath{public:CGSVGPath();~CGSVGPath();void Rect(float x,float y,float width,float height);void RoundedRect(float x,float y,float width,float height,float rx,float ry);void Ellipse(float cx,float cy,float rx,float ry);void MoveTo(float x,float y);void LineTo(float x,float y);void CurveTo(float x1,float y1,float x2,float y2,float x3,float y3);void CurveToV(float x2,float y2,float x3,float y3);void ClosePath();private:CGMutablePathRef mPath;float mCurrentX;float mCurrentY;};class CGSVGTransform{public:CGSVGTransform(float a,float b,float c,float d,float tx,float ty);void Set(float a,float b,float c,float d,float tx,float ty);void Rotate(float degree);void Translate(float tx,float ty);void Scale(float sx,float sy);void Concat(float a,float b,float c,float d,float tx,float ty);private:CGAffineTransform mTransform;};class CGSVGImageData{public:CGSVGImageData(const std::string&base64,ImageEncoding encoding);~CGSVGImageData();float Width()const;float Height()const;private:CGImageRef mImage;};class CGSVGRenderer{public:CGSVGRenderer();void Save(const GraphicStyle&graphicStyle);void Restore();void DrawGradientToContext(const Gradient&gradient,float opacity);void DrawPath(const Path&path,const GraphicStyle&graphicStyle,const FillStyle&fillStyle,const StrokeStyle&strokeStyle);void DrawImage(const ImageData&image,const GraphicStyle&graphicStyle,const Rect&clipArea,const Rect&fillArea);private:CGContextRef mContext;};}
#endif
</file>

<file path="svgnative/src/ports/gdiplus/GDIPlusSVGRenderer.h">
```cpp
#ifndef SVG_NATIVE_GDIPLUS_SVG_RENDERER_H_
#define SVG_NATIVE_GDIPLUS_SVG_RENDERER_H_
#include<Windows.h>
#include<gdiplus.h>
#include "svgnative/Config.h"
#include "svgnative/ports/gdiplus/GDIPlusSVGRenderer.h"
#include "base64.h"
namespace SVGNative{Gdiplus::Color ColorToGdiplusColor(const Color&inColor){return Gdiplus::Color(static_cast<BYTE>(inColor[3]*255.0),static_cast<BYTE>(inColor[0]*255.0),static_cast<BYTE>(inColor[1]*255.0),static_cast<BYTE>(inColor[2]*255.0));}GDIPlusSVGPath::GDIPlusSVGPath(){}GDIPlusSVGPath::~GDIPlusSVGPath(){}void GDIPlusSVGPath::Rect(float x,float y,float width,float height){mPath.AddRectangle(Gdiplus::RectF(x,y,width,
</file>

<file path="svgnative/src/ports/qt/QPainterSVGRenderer.h">
#ifndef HEADER_H
#define HEADER_H
void function1();int function2(int param1,int param2);float function3(float param);
#endif
</file>

<file path="svgnative/src/ports/skia/SkiaSVGRenderer.h">
```cpp
#ifndef SVG_NATIVE_SVGNATIVE_PORTS_SKIA_SKIASVGRENDERER_H_
#define SVG_NATIVE_SVGNATIVE_PORTS_SKIA_SKIASVGRENDERER_H_
#include "svgnative/ports/skia/SkiaSVGRenderer.h"
#include "base64.h"
#include "svgnative/Config.h"
#include "SkCanvas.h"
#include "SkCodec.h"
#include "SkData.h"
#include "SkEncodedOrigin.h"
#include "SkGradientShader.h"
#include "SkImage.h"
#include "SkPoint.h"
#include "SkRect.h"
#include "SkRRect.h"
#include "SkShader.h"
#include "SkSurface.h"
#include "SkDashPathEffect.h"
#include "SkTypes.h"
#include "SkSamplingOptions.h"
#include<math.h>
namespace SVGNative{class SkiaSVGPath{public:SkiaSVGPath();void Rect(float x,float y,float width,float height);void RoundedRect(float x,float y,float width,float height,float rx,float ry);void Ellipse(float cx,float cy,float rx,float ry);void MoveTo(float x,float y);void LineTo(float x,float y);void CurveTo(float x1,float y1,float x2,float y2,float x3,float y3);void CurveToV(float x2,float y2,float x3,float y3);void ClosePath();SkPath mPath;float mCurrentX;float mCurrentY;};class SkiaSVGTransform{public:SkiaSVGTransform(float a,float b,float c,float d,float tx,float ty);void Set(float a,float b,float c,float d,float tx,float ty);void Rotate(float degree);void Translate(float tx,float ty);void Scale(float sx,float sy);void Concat(float a,float b,float c,float d,float tx,float ty);SkMatrix mMatrix;};inline sk_sp<SkImage>getOrientedImage(sk_sp<SkImage>srcImg,SkEncodedOrigin origin){int width=0,height=0;int offsetX=0,offsetY=0;int rot=0;int centerX=0,centerY=0;switch(origin){case SkEncodedOrigin::kBottomRight_S
</file>

<file path="svgnative/src/ports/string/StringSVGRenderer.h">
```cpp
#ifndef STRING_SVG_RENDERER_H
#define STRING_SVG_RENDERER_H
#include "svgnative/ports/string/StringSVGRenderer.h"
#include<cmath>
#define M_PI 3.14159265358979323846
namespace SVGNative{StringSVGPath::StringSVGPath(){mStringStream.precision(3);}void StringSVGPath::Rect(float x,float y,float width,float height){mStringStream<<" Rect("<<x<<','<<y<<','<<width<<','<<height<<')';}void StringSVGPath::RoundedRect(float x,float y,float width,float height,float rx,float ry){mStringStream<<" RoundedRect("<<x<<','<<y<<','<<width<<','<<height<<','<<rx<<','<<ry<<')';}void StringSVGPath::Ellipse(float cx,float cy,float rx,float ry){mStringStream<<" Ellipse("<<cx<<','<<cy<<','<<rx<<','<<ry<<')';}void StringSVGPath::MoveTo(float x,float y){mStringStream<<" M"<<x<<','<<y;}void StringSVGPath::LineTo(float x,float y){mStringStream<<" L"<<x<<','<<y;}void StringSVGPath::CurveTo(float x1,float y1,float x2,float y2,float x3,float y3){mStringStream<<" C"<<x1<<','<<y1<<','<<x2<<','<<y2<<','<<x3<<','<<y3;}void StringSVGPath::CurveToV(float x2,float y2,float x3,float y3){mStringStream<<" Q"<<x2<<','<<y2<<','<<x3<<','<<y3;}void StringSVGPath::ClosePath(){mStringStream<<" Z";}std::string StringSVGPath::String()const{return mStringStream.str();}float deg2rad(float angle);float deg2rad(float angle){return static_cast<float>(M_PI/180.0*angle);}StringSVGTransform::StringSVGTransform(float a,float b,float c,float d,float tx,float ty){Set(a,b,c,d,tx,ty);}void StringSVGTransform::Set(float a,float b,float c,float d,float tx,float ty){mTransform={a,b,c,d,tx,ty};}void StringSVGTransform::Rotate(float r){r=deg2rad(r);float cosAngle=cos(r);float sinAngle=sin(r);auto rot=AffineTransform{cosAngle,sinAngle,-sinAngle,cosAngle,0,0};Multiply(rot);}void StringSVGTransform::Translate(float tx,float ty){mTransform.e+=tx*mTransform.a+ty*mTransform.c;mTransform.f+=tx*mTransform.b+ty*mTransform.d;}void StringSVGTransform::Scale(float sx,float sy){mTransform.a*=sx;mTransform.b*=sx;mTransform.c*=sy;mTransform.d*=sy;}void StringSVGTransform::Concat(float a,float b,float c,float d,float tx,float ty){AffineTransform other{a,b,c,d,tx,ty};Multiply(other);}std::string StringSVGTransform::String()const{std::ostringstream stringStream;stringStream.precision(3);stringStream<<"matrix("<<mTransform.a<<','<<mTransform.b<<','<<mTransform.c<<','<<mTransform.d<<','<<mTransform.e<<','<<mTransform.f<<')';return stringStream.str();}void StringSVGTransform::Multiply(const AffineTransform&o){AffineTransform newT;newT.a=o.a*mTransform.a+o.b*mTransform.c;newT.b=o.a*mTransform.b+o.b*mTransform.d;newT.c=o.c*mTransform.a+o.d*mTransform.c;newT.d=o.c*mTransform.b+o.d*mTransform.d;newT.e=o.e*mTransform.a+o.f*mTransform.c+mTransform.e;newT.f=o.e*mTransform.b+o.f*mTransform.d+mTransform.f;mTransform=newT;
</file>

<file path="svgnative/src/win/version.rc">
#include <Winver.h>

#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

VS_VERSION_INFO VERSIONINFO
FILEVERSION    	VER_FILEVERSION
PRODUCTVERSION 	VER_PRODUCTVERSION
FILEFLAGSMASK  	VS_FFI_FILEFLAGSMASK
FILEOS         	VOS__WINDOWS32
FILETYPE       	VFT_APP
FILESUBTYPE    	VFT2_UNKNOWN
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName",      "Adobe"
            VALUE "FileDescription",  "SVGNativeViewerLib"
            VALUE "FileVersion",      VER_FILEVERSION_STR
            VALUE "InternalName",     "SVGNativeViewerLib"
            VALUE "LegalCopyright",   "Copyright (c) Adobe"
            VALUE "LegalTrademarks1", ""
            VALUE "LegalTrademarks2", ""
            VALUE "OriginalFilename", "SVGNativeViewerLib"
            VALUE "ProductName",      "SVGNativeViewerLib"
            VALUE "ProductVersion",   VER_PRODUCTVERSION_STR
        END
    END

    BLOCK "VarFileInfo"
    BEGIN
        /* The following line should only be modified for localized versions.     */
        /* It consists of any number of WORD,WORD pairs, with each pair           */
        /* describing a language,codepage combination supported by the file.      */
        /*                                                                        */
        /* For example, a file might have values "0x409,1252" indicating that it  */
        /* supports English language (0x409) in the Windows ANSI codepage (1252). */

        VALUE "Translation", 0x409, 1252

    END
END
</file>

<file path="svgnative/src/xml/ExpatXMLParser.h">
#ifndef XML_HEADER_H
#define XML_HEADER_H
#include "xml/XMLParser.h"
#include "Config.h"
#include<expat.h>
#include<map>
#include<stack>
#include<string>
#include<string.h>
namespace SVGNative{namespace xml{class ExpatXMLNode final:public XMLNode{public:ExpatXMLNode(){}const char*GetName()const override{return mName.c_str();}const char*GetValue()const override{return nullptr;}std::unique_ptr<XMLNode>GetFirstNode()override{return std::move(mChild);}std::unique_ptr<XMLNode>GetNextSibling()override{return std::move(mSibling);}Attribute GetAttribute(const char*attrName,const char*xmlNSPrefix)const override{auto it=mAttributes.find(attrName);if(it!=mAttributes.end()){return{true,it->second.c_str()};}if(xmlNSPrefix){std::string newAttrName{xmlNSPrefix};newAttrName.append(":");newAttrName.append(attrName);it=mAttributes.find(newAttrName);if(it!=mAttributes.end()){return{true,it->second.c_str()};}}return{false,{}};}private:friend class ExpatXMLDocument;std::string mName;std::map<std::string,std::string>mAttributes;std::unique_ptr<ExpatXMLNode>mChild;std::unique_ptr<ExpatXMLNode>mSibling;};class ExpatXMLDocument final:public XMLDocument{public:static std::unique_ptr<XMLDocument>CreateXMLDocument(const char*documentString){auto newDocument=new ExpatXMLDocument(documentString);return std::unique_ptr<XMLDocument>(newDocument);}~ExpatXMLDocument(){}std::unique_ptr<XMLNode>GetFirstNode()override{return std::move(mRootNode);}private:ExpatXMLDocument(const char*documentString){XML_Parser parser=XML_ParserCreate(nullptr);XML_SetUserData(parser,this);XML_SetElementHandler(parser,this->StartElement,this->EndElement);int done{0};if(XML_Parse(parser,documentString,(int)strlen(documentString),done)==XML_STATUS_ERROR||done){mXMLNodeStack={};mRootNode.reset();}mPreviousSilbingXMLNode=nullptr;SVG_ASSERT_MSG(mXMLNodeStack.empty(),"element stack not empty");XML_ParserFree(parser);}static void XMLCALL StartElement(void*userData,const XML_Char*name,const XML_Char**attrs){auto node=new ExpatXMLNode{};node->mName=name;auto&attributes=node->mAttributes;while(*attrs){auto attrName=*attrs++;if(!*attrs)break;auto attrValue=*attrs++;auto it=attributes.find(attrName);if(it==attributes.end()){attributes.insert({attrName,attrValue});}}auto document=static_cast<ExpatXMLDocument*>(userData);if(document->mXMLNodeStack.empty()){document->mRootNode=std::unique_ptr<ExpatXMLNode>(node);}else{if(document->mStartNodeCalled){document->mXMLNodeStack.top()->mChild=std::unique_ptr<ExpatXMLNode>(node);}else{document->mPreviousSilbingXMLNode->mSibling=std::unique_ptr<ExpatXMLNode>(node);}}document->mXMLNodeStack.push(node);document->mStartNodeCalled=true;}static void XMLCALL EndElement(void*userData,const XML_Char*name){auto document=static_cast<ExpatXMLDocument*>(userData);document->mXMLNodeStack.pop();if(!document->mXMLNodeStack.empty()){document->mPreviousSilbingXMLNode=document->mXMLNodeStack.top();}document->mStartNodeCalled=false;}std::unique_ptr<ExpatXMLNode>mRootNode;std::stack<ExpatXMLNode*>mXMLNodeStack;ExpatXMLNode*mPreviousSilbingXMLNode;bool mStartNodeCalled{false};};}}
#endif
</file>

<file path="svgnative/src/xml/LibXMLParser.h">
#ifndef XML_HEADER_H
#define XML_HEADER_H
#include "xml/XMLParser.h"
#include<libxml/tree.h>
#include<libxml/parser.h>
namespace SVGNative{namespace xml{class LibXMLNode final:public XMLNode{public:LibXMLNode(xmlNode*node):mNode{node}{}const char*GetName()const override{if(!mNode)return nullptr;return(const char*)(mNode->name);}const char*GetValue()const override{if(!mNode)return nullptr;return(const char*)(mNode->content);}std::unique_ptr<XMLNode>GetFirstNode()override{if(!mNode)return nullptr;auto children=mNode->children;while(children&&children->type!=XML_ELEMENT_NODE)children=children->next;if(children){auto newNode=new LibXMLNode{children};return std::unique_ptr<XMLNode>(newNode);}return nullptr;}std::unique_ptr<XMLNode>GetNextSibling()override{if(!mNode)return nullptr;auto nextSibling=mNode->next;while(nextSibling&&nextSibling->type!=XML_ELEMENT_NODE)nextSibling=nextSibling->next;if(nextSibling){auto newNode=new LibXMLNode{nextSibling};return std::unique_ptr<XMLNode>(newNode);}return nullptr;}Attribute GetAttribute(const char*attrName,const char*)const override{if(!mNode)return{false,nullptr};auto attr=xmlHasProp(mNode,(const xmlChar*)attrName);if(attr)return{true,(const char*)xmlGetProp(mNode,(const xmlChar*)(attrName))};return{false,nullptr};}private:xmlNode*mNode{};};class LibXMLDocument final:public XMLDocument{public:static std::unique_ptr<XMLDocument>CreateXMLDocument(const char*documentString){auto newDocument=new LibXMLDocument(documentString);return std::unique_ptr<XMLDocument>(newDocument);}LibXMLDocument(const char*documentString){mDocument=xmlReadDoc((const xmlChar*)documentString,nullptr,nullptr,XML_PARSE_RECOVER);}~LibXMLDocument(){xmlFreeDoc(mDocument);xmlCleanupParser();}std::unique_ptr<XMLNode>GetFirstNode()override{if(!mDocument)return nullptr;if(auto firstNode=xmlDocGetRootElement(mDocument)){auto newNode=new LibXMLNode{firstNode};return std::unique_ptr<XMLNode>(newNode);}return nullptr;}private:xmlDocPtr mDocument{};};std::unique_ptr<XMLDocument>XMLDocument::CreateXMLDocument(const char*documentString){return LibXMLDocument::CreateXMLDocument(documentString);}}}
#endif
</file>

<file path="svgnative/src/xml/RapidXMLParser.h">
#ifndef XML_HEADER_H
#define XML_HEADER_H
#include "xml/XMLParser.h"
#include<boost/property_tree/detail/xml_parser_read_rapidxml.hpp>
namespace SVGNative{namespace xml{class RapidXMLNode final:public XMLNode{public:RapidXMLNode(const boost::property_tree::detail::rapidxml::xml_node<>*node):mNode{node}{}const char*GetName()const override{if(!mNode)return nullptr;return mNode->name();}const char*GetValue()const override{if(!mNode)return nullptr;return mNode->value();}std::unique_ptr<XMLNode>GetFirstNode()override{if(!mNode)return nullptr;if(const auto firstChild=mNode->first_node()){auto newNode=new RapidXMLNode{firstChild};return std::unique_ptr<XMLNode>(newNode);}return nullptr;}std::unique_ptr<XMLNode>GetNextSibling()override{if(!mNode)return nullptr;if(const auto nextSibling=mNode->next_sibling()){auto newNode=new RapidXMLNode{nextSibling};return std::unique_ptr<XMLNode>(newNode);}return nullptr;}Attribute GetAttribute(const char*attrName,const char*nsPrefix)const override{if(!mNode)return{false,nullptr};if(const auto attr=mNode->first_attribute(attrName))return{true,attr->value()};if(nsPrefix){std::string newAttrName=nsPrefix;newAttrName.append(":");newAttrName.append(attrName);if(const auto attr=mNode->first_attribute(newAttrName.c_str()))return{true,attr->value()};}return{false,nullptr};}private:const boost::property_tree::detail::rapidxml::xml_node<>*mNode;};class RapidXMLDocument final:public XMLDocument{public:static std::unique_ptr<XMLDocument>CreateXMLDocument(const char*documentString){auto newDocument=new RapidXMLDocument(documentString);return std::unique_ptr<XMLDocument>(newDocument);}RapidXMLDocument(const char*documentString){mDocument.parse<0>((char*)documentString);}~RapidXMLDocument(){mDocument.clear();}std::unique_ptr<XMLNode>GetFirstNode()override{if(const auto firstNode=mDocument.first_node()){auto newNode=new RapidXMLNode{firstNode};return std::unique_ptr<XMLNode>(newNode);}return nullptr;}private:boost::property_tree::detail::rapidxml::xml_document<>mDocument;};std::unique_ptr<XMLDocument>XMLDocument::CreateXMLDocument(const char*documentString){return RapidXMLDocument::CreateXMLDocument(documentString);}}}
#endif
</file>

<file path="svgnative/src/Constants.h">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#pragma once

namespace SVGNative
{
// Attributes
constexpr const char* kIdAttr{"id"};
constexpr const char* kXAttr{"x"};
constexpr const char* kYAttr{"y"};
constexpr const char* kWidthAttr{"width"};
constexpr const char* kHeightAttr{"height"};
constexpr const char* kRxAttr{"rx"};
constexpr const char* kRyAttr{"ry"};
constexpr const char* kRAttr{"r"};
constexpr const char* kDAttr{"d"};
constexpr const char* kCxAttr{"cx"};
constexpr const char* kCyAttr{"cy"};
constexpr const char* kFxAttr{"fx"};
constexpr const char* kFyAttr{"fy"};
constexpr const char* kX1Attr{"x1"};
constexpr const char* kY1Attr{"y1"};
constexpr const char* kX2Attr{"x2"};
constexpr const char* kY2Attr{"y2"};
constexpr const char* kPointsAttr{"points"};
constexpr const char* kHrefAttr{"href"};
constexpr const char* kTransformAttr{"transform"};
constexpr const char* kGradientTransformAttr{"gradientTransform"};
constexpr const char* kViewBoxAttr{"viewBox"};
constexpr const char* kSpreadMethodAttr{"spreadMethod"};
constexpr const char* kOffsetAttr{"offset"};
#if DEBUG
constexpr const char* kDataNameAttr{"data-name"};
#endif

// Properties
constexpr const char* kColorProp{"color"};
constexpr const char* kClipRuleProp{"clip-rule"};
constexpr const char* kFillProp{"fill"};
constexpr const char* kFillRuleProp{"fill-rule"};
constexpr const char* kFillOpacityProp{"fill-opacity"};
constexpr const char* kStrokeProp{"stroke"};
constexpr const char* kStrokeDasharrayProp{"stroke-dasharray"};
constexpr const char* kStrokeDashoffsetProp{"stroke-dashoffset"};
constexpr const char* kStrokeLinecapProp{"stroke-linecap"};
constexpr const char* kStrokeLinejoinProp{"stroke-linejoin"};
constexpr const char* kStrokeMiterlimitProp{"stroke-miterlimit"};
constexpr const char* kStrokeOpacityProp{"stroke-opacity"};
constexpr const char* kStrokeWidthProp{"stroke-width"};
constexpr const char* kVisibilityProp{"visibility"};
constexpr const char* kClipPathProp{"clip-path"};
constexpr const char* kDisplayProp{"display"};
constexpr const char* kOpacityProp{"opacity"};
constexpr const char* kStopOpacityProp{"stop-opacity"};
constexpr const char* kStopColorProp{"stop-color"};
constexpr const char* kPreserveAspectRatioAttr{"preserveAspectRatio"};

// Elements
constexpr const char* kLineElem{"line"};
constexpr const char* kRectElem{"rect"};
constexpr const char* kPathElem{"path"};
constexpr const char* kPolygonElem{"polygon"};
constexpr const char* kPolylineElem{"polyline"};
constexpr const char* kEllipseElem{"ellipse"};
constexpr const char* kCircleElem{"circle"};
constexpr const char* kGElem{"g"};
constexpr const char* kClipPathElem{"clipPath"};
constexpr const char* kSymbolElem{"symbol"};
constexpr const char* kStyleElem{"style"};
constexpr const char* kLinearGradientElem{"linearGradient"};
constexpr const char* kRadialGradientElem{"radialGradient"};
constexpr const char* kDefsElem{"defs"};
constexpr const char* kUseElem{"use"};
constexpr const char* kImageElem{"image"};
constexpr const char* kStopElem{"stop"};
constexpr const char* kSvgElem{"svg"};

// Values
constexpr const char* kDataUrlPngVal{"data:image/png;base64,"};
constexpr const char* kDataUrlJpgVal{"data:image/jpg;base64,"};
constexpr const char* kDataUrlJpegVal{"data:image/jpeg;base64,"};
constexpr const char* kSliceVal{"slice"};
constexpr const char* kXMinYMinVal{"xMinYMin"};
constexpr const char* kXMidYMinVal{"xMidYMin"};
constexpr const char* kXMaxYMinVal{"xMaxYMin"};
constexpr const char* kXMinYMidVal{"xMinYMid"};
constexpr const char* kXMaxYMidVal{"xMaxYMid"};
constexpr const char* kXMinYMaxVal{"xMinYMax"};
constexpr const char* kXMidYMaxVal{"xMidYMax"};
constexpr const char* kXMaxYMaxVal{"xMaxYMax"};
constexpr const char* kEvenoddVal{"evenodd"};
constexpr const char* kNonzeroVal{"nonzero"};
constexpr const char* kHiddenVal{"hidden"};
constexpr const char* kCollapseVal{"collapse"};
constexpr const char* kVisibleVal{"visible"};
constexpr const char* kRoundVal{"round"};
constexpr const char* kSquareVal{"square"};
constexpr const char* kBevelVal{"bevel"};
constexpr const char* kUrlVal{"url(#"};
constexpr const char* kNoneVal{"none"};
constexpr const char* kPadVal{"pad"};
constexpr const char* kReflectVal{"reflect"};
constexpr const char* kRepeatVal{"repeat"};

// Others
constexpr const char* kXlinkNS{"xlink"};

} // namespace SVGNative
</file>

<file path="svgnative/src/CSSColorKeywords.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#pragma once

#include "svgnative/SVGRenderer.h"
#include <array>

namespace SVGNative
{

struct CSSColorInfo
{
    constexpr CSSColorInfo(const char* aColorName, size_t aLength, Color aColor)
        : colorName{aColorName}
        , length{aLength}
        , color{std::move(aColor)}
    {
    }
    const char* colorName{};
    size_t length{};
    Color color{};
};

// Generated in web browser with following code. ele must be an element embedded in a loaded document.
// var string = '';
// [/*list of all color names*/].forEach(name => {
//     ele.style.fill = name;
//     let rgb = (window.getComputedStyle(ele).fill).match(/\d+/g);
//     string += String('	CSSColorInfo{"' + name + '"').padEnd(25) + ', ' + String(name.length).padEnd(2) + ' , {{'
//         + rgb.map(item => { return String(rgb[0] + '.0f / 255.0f').padStart(13)}).join(', ')
//         + ', 1.0f}}},\n';
// });
constexpr std::array<CSSColorInfo, 148> gCSSNamedColors = {{
    CSSColorInfo{"aliceblue"            , 9  , {{240.0f / 255.0f, 248.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"antiquewhite"         , 12 , {{250.0f / 255.0f, 235.0f / 255.0f, 215.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"aqua"                 , 4  , {{  0.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"aquamarine"           , 10 , {{127.0f / 255.0f, 255.0f / 255.0f, 212.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"azure"                , 5  , {{240.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"beige"                , 5  , {{245.0f / 255.0f, 245.0f / 255.0f, 220.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"bisque"               , 6  , {{255.0f / 255.0f, 228.0f / 255.0f, 196.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"black"                , 5  , {{  0.0f / 255.0f,   0.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"blanchedalmond"       , 14 , {{255.0f / 255.0f, 235.0f / 255.0f, 205.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"blue"                 , 4  , {{  0.0f / 255.0f,   0.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"blueviolet"           , 10 , {{138.0f / 255.0f,  43.0f / 255.0f, 226.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"brown"                , 5  , {{165.0f / 255.0f,  42.0f / 255.0f,  42.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"burlywood"            , 9  , {{222.0f / 255.0f, 184.0f / 255.0f, 135.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"cadetblue"            , 9  , {{ 95.0f / 255.0f, 158.0f / 255.0f, 160.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"chartreuse"           , 10 , {{127.0f / 255.0f, 255.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"chocolate"            , 9  , {{210.0f / 255.0f, 105.0f / 255.0f,  30.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"coral"                , 5  , {{255.0f / 255.0f, 127.0f / 255.0f,  80.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"cornflowerblue"       , 14 , {{100.0f / 255.0f, 149.0f / 255.0f, 237.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"cornsilk"             , 8  , {{255.0f / 255.0f, 248.0f / 255.0f, 220.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"crimson"              , 7  , {{220.0f / 255.0f,  20.0f / 255.0f,  60.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"cyan"                 , 4  , {{  0.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkblue"             , 8  , {{  0.0f / 255.0f,   0.0f / 255.0f, 139.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkcyan"             , 8  , {{  0.0f / 255.0f, 139.0f / 255.0f, 139.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkgoldenrod"        , 13 , {{184.0f / 255.0f, 134.0f / 255.0f,  11.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkgray"             , 8  , {{169.0f / 255.0f, 169.0f / 255.0f, 169.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkgreen"            , 9  , {{  0.0f / 255.0f, 100.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkgrey"             , 8  , {{169.0f / 255.0f, 169.0f / 255.0f, 169.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkkhaki"            , 9  , {{189.0f / 255.0f, 183.0f / 255.0f, 107.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkmagenta"          , 11 , {{139.0f / 255.0f,   0.0f / 255.0f, 139.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkolivegreen"       , 14 , {{ 85.0f / 255.0f, 107.0f / 255.0f,  47.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkorange"           , 10 , {{255.0f / 255.0f, 140.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkorchid"           , 10 , {{153.0f / 255.0f,  50.0f / 255.0f, 204.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkred"              , 7  , {{139.0f / 255.0f,   0.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darksalmon"           , 10 , {{233.0f / 255.0f, 150.0f / 255.0f, 122.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkseagreen"         , 12 , {{143.0f / 255.0f, 188.0f / 255.0f, 143.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkslateblue"        , 13 , {{ 72.0f / 255.0f,  61.0f / 255.0f, 139.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkslategray"        , 13 , {{ 47.0f / 255.0f,  79.0f / 255.0f,  79.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkslategrey"        , 13 , {{ 47.0f / 255.0f,  79.0f / 255.0f,  79.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkturquoise"        , 13 , {{  0.0f / 255.0f, 206.0f / 255.0f, 209.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkviolet"           , 10 , {{148.0f / 255.0f,   0.0f / 255.0f, 211.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"deeppink"             , 8  , {{255.0f / 255.0f,  20.0f / 255.0f, 147.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"deepskyblue"          , 11 , {{  0.0f / 255.0f, 191.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"dimgray"              , 7  , {{105.0f / 255.0f, 105.0f / 255.0f, 105.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"dimgrey"              , 7  , {{105.0f / 255.0f, 105.0f / 255.0f, 105.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"dodgerblue"           , 10 , {{ 30.0f / 255.0f, 144.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"firebrick"            , 9  , {{178.0f / 255.0f,  34.0f / 255.0f,  34.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"floralwhite"          , 11 , {{255.0f / 255.0f, 250.0f / 255.0f, 240.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"forestgreen"          , 11 , {{ 34.0f / 255.0f, 139.0f / 255.0f,  34.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"fuchsia"              , 7  , {{255.0f / 255.0f,   0.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"gainsboro"            , 9  , {{220.0f / 255.0f, 220.0f / 255.0f, 220.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"ghostwhite"           , 10 , {{248.0f / 255.0f, 248.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"gold"                 , 4  , {{255.0f / 255.0f, 215.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"goldenrod"            , 9  , {{218.0f / 255.0f, 165.0f / 255.0f,  32.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"gray"                 , 4  , {{128.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"green"                , 5  , {{  0.0f / 255.0f, 128.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"greenyellow"          , 11 , {{173.0f / 255.0f, 255.0f / 255.0f,  47.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"grey"                 , 4  , {{128.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"honeydew"             , 8  , {{240.0f / 255.0f, 255.0f / 255.0f, 240.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"hotpink"              , 7  , {{255.0f / 255.0f, 105.0f / 255.0f, 180.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"indianred"            , 9  , {{205.0f / 255.0f,  92.0f / 255.0f,  92.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"indigo"               , 6  , {{ 75.0f / 255.0f,   0.0f / 255.0f, 130.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"ivory"                , 5  , {{255.0f / 255.0f, 255.0f / 255.0f, 240.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"khaki"                , 5  , {{240.0f / 255.0f, 230.0f / 255.0f, 140.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lavender"             , 8  , {{230.0f / 255.0f, 230.0f / 255.0f, 250.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lavenderblush"        , 13 , {{255.0f / 255.0f, 240.0f / 255.0f, 245.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lawngreen"            , 9  , {{124.0f / 255.0f, 252.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lemonchiffon"         , 12 , {{255.0f / 255.0f, 250.0f / 255.0f, 205.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"darkslateblue"        , 13 , {{ 72.0f / 255.0f,  61.0f / 255.0f, 139.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightcoral"           , 10 , {{240.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightcyan"            , 9  , {{224.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightgoldenrodyellow" , 20 , {{250.0f / 255.0f, 250.0f / 255.0f, 210.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightgray"            , 9  , {{211.0f / 255.0f, 211.0f / 255.0f, 211.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightgreen"           , 10 , {{144.0f / 255.0f, 238.0f / 255.0f, 144.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightgrey"            , 9  , {{211.0f / 255.0f, 211.0f / 255.0f, 211.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightpink"            , 9  , {{255.0f / 255.0f, 182.0f / 255.0f, 193.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightsalmon"          , 11 , {{255.0f / 255.0f, 160.0f / 255.0f, 122.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightseagreen"        , 13 , {{ 32.0f / 255.0f, 178.0f / 255.0f, 170.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightskyblue"         , 12 , {{135.0f / 255.0f, 206.0f / 255.0f, 250.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightslategray"       , 14 , {{119.0f / 255.0f, 136.0f / 255.0f, 153.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightslategrey"       , 14 , {{119.0f / 255.0f, 136.0f / 255.0f, 153.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightsteelblue"       , 14 , {{176.0f / 255.0f, 196.0f / 255.0f, 222.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lightyellow"          , 11 , {{255.0f / 255.0f, 255.0f / 255.0f, 224.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"lime"                 , 4  , {{  0.0f / 255.0f, 255.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"limegreen"            , 9  , {{ 50.0f / 255.0f, 205.0f / 255.0f,  50.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"linen"                , 5  , {{250.0f / 255.0f, 240.0f / 255.0f, 230.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"magenta"              , 7  , {{255.0f / 255.0f,   0.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"maroon"               , 6  , {{128.0f / 255.0f,   0.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumaquamarine"     , 16 , {{102.0f / 255.0f, 205.0f / 255.0f, 170.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumblue"           , 10 , {{  0.0f / 255.0f,   0.0f / 255.0f, 205.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumorchid"         , 12 , {{186.0f / 255.0f,  85.0f / 255.0f, 211.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumpurple"         , 12 , {{147.0f / 255.0f, 112.0f / 255.0f, 219.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumseagreen"       , 14 , {{ 60.0f / 255.0f, 179.0f / 255.0f, 113.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumslateblue"      , 15 , {{123.0f / 255.0f, 104.0f / 255.0f, 238.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumspringgreen"    , 17 , {{  0.0f / 255.0f, 250.0f / 255.0f, 154.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumturquoise"      , 15 , {{ 72.0f / 255.0f, 209.0f / 255.0f, 204.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mediumvioletred"      , 15 , {{199.0f / 255.0f,  21.0f / 255.0f, 133.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"midnightblue"         , 12 , {{ 25.0f / 255.0f,  25.0f / 255.0f, 112.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mintcream"            , 9  , {{245.0f / 255.0f, 255.0f / 255.0f, 250.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"mistyrose"            , 9  , {{255.0f / 255.0f, 228.0f / 255.0f, 225.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"moccasin"             , 8  , {{255.0f / 255.0f, 228.0f / 255.0f, 181.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"navajowhite"          , 11 , {{255.0f / 255.0f, 222.0f / 255.0f, 173.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"navy"                 , 4  , {{  0.0f / 255.0f,   0.0f / 255.0f, 128.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"oldlace"              , 7  , {{253.0f / 255.0f, 245.0f / 255.0f, 230.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"olive"                , 5  , {{128.0f / 255.0f, 128.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"olivedrab"            , 9  , {{107.0f / 255.0f, 142.0f / 255.0f,  35.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"orange"               , 6  , {{255.0f / 255.0f, 165.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"orangered"            , 9  , {{255.0f / 255.0f,  69.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"orchid"               , 6  , {{218.0f / 255.0f, 112.0f / 255.0f, 214.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"palegoldenrod"        , 13 , {{238.0f / 255.0f, 232.0f / 255.0f, 170.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"palegreen"            , 9  , {{152.0f / 255.0f, 251.0f / 255.0f, 152.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"paleturquoise"        , 13 , {{175.0f / 255.0f, 238.0f / 255.0f, 238.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"palevioletred"        , 13 , {{219.0f / 255.0f, 112.0f / 255.0f, 147.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"papayawhip"           , 10 , {{255.0f / 255.0f, 239.0f / 255.0f, 213.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"peachpuff"            , 9  , {{255.0f / 255.0f, 218.0f / 255.0f, 185.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"peru"                 , 4  , {{205.0f / 255.0f, 133.0f / 255.0f,  63.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"pink"                 , 4  , {{255.0f / 255.0f, 192.0f / 255.0f, 203.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"plum"                 , 4  , {{221.0f / 255.0f, 160.0f / 255.0f, 221.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"powderblue"           , 10 , {{176.0f / 255.0f, 224.0f / 255.0f, 230.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"purple"               , 6  , {{128.0f / 255.0f,   0.0f / 255.0f, 128.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"rebeccapurple"        , 13 , {{102.0f / 255.0f,  51.0f / 255.0f, 153.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"red"                  , 3  , {{255.0f / 255.0f,   0.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"rosybrown"            , 9  , {{188.0f / 255.0f, 143.0f / 255.0f, 143.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"royalblue"            , 9  , {{ 65.0f / 255.0f, 105.0f / 255.0f, 225.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"saddlebrown"          , 11 , {{139.0f / 255.0f,  69.0f / 255.0f,  19.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"salmon"               , 6  , {{250.0f / 255.0f, 128.0f / 255.0f, 114.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"sandybrown"           , 10 , {{244.0f / 255.0f, 164.0f / 255.0f,  96.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"seagreen"             , 8  , {{ 46.0f / 255.0f, 139.0f / 255.0f,  87.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"seashell"             , 8  , {{255.0f / 255.0f, 245.0f / 255.0f, 238.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"sienna"               , 6  , {{160.0f / 255.0f,  82.0f / 255.0f,  45.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"silver"               , 6  , {{192.0f / 255.0f, 192.0f / 255.0f, 192.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"skyblue"              , 7  , {{135.0f / 255.0f, 206.0f / 255.0f, 235.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"slateblue"            , 9  , {{106.0f / 255.0f,  90.0f / 255.0f, 205.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"slategray"            , 9  , {{112.0f / 255.0f, 128.0f / 255.0f, 144.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"slategrey"            , 9  , {{112.0f / 255.0f, 128.0f / 255.0f, 144.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"snow"                 , 4  , {{255.0f / 255.0f, 250.0f / 255.0f, 250.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"springgreen"          , 11 , {{  0.0f / 255.0f, 255.0f / 255.0f, 127.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"steelblue"            , 9  , {{ 70.0f / 255.0f, 130.0f / 255.0f, 180.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"tan"                  , 3  , {{210.0f / 255.0f, 180.0f / 255.0f, 140.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"teal"                 , 4  , {{  0.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"thistle"              , 7  , {{216.0f / 255.0f, 191.0f / 255.0f, 216.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"tomato"               , 6  , {{255.0f / 255.0f,  99.0f / 255.0f,  71.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"turquoise"            , 9  , {{ 64.0f / 255.0f, 224.0f / 255.0f, 208.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"violet"               , 6  , {{238.0f / 255.0f, 130.0f / 255.0f, 238.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"wheat"                , 5  , {{245.0f / 255.0f, 222.0f / 255.0f, 179.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"white"                , 5  , {{255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"whitesmoke"           , 10 , {{245.0f / 255.0f, 245.0f / 255.0f, 245.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"yellow"               , 6  , {{255.0f / 255.0f, 255.0f / 255.0f,   0.0f / 255.0f, 1.0f}}},
    CSSColorInfo{"yellowgreen"          , 11 , {{154.0f / 255.0f, 205.0f / 255.0f,  50.0f / 255.0f, 1.0f}}}
}};

}
</file>

<file path="svgnative/src/DeprecatedSVGDocumentImpl.h">
#ifdef STYLE_SUPPORT
#include "SVGDocumentImpl.h"
#include "svgnative/SVGDocument.h"
#include "xml/XMLParser.h"
using namespace SVGNative::xml;namespace SVGNative{void SVGDocumentImpl::AddCustomCSS(const StyleSheet::CssDocument*cssDocument){mOverrideStyle=cssDocument;}void SVGDocumentImpl::ClearCustomCSS(){const auto elements=mCustomCSSInfo.getElements();for(const auto&element:elements){mCustomCSSInfo.removeElement(element.getSelector());}mOverrideStyle=nullptr;}void SVGDocumentImpl::ParseStyle(const XMLNode*child){SVG_ASSERT(mCSSInfo.getElements().size()==0);std::string styleSheet=std::string(child->GetValue());SVG_CSS_TRACE("ParseStyle INPUT:\n"<<styleSheet);boost::replace_all(styleSheet,"\r\n"," ");boost::replace_all(styleSheet,"\r"," ");boost::replace_all(styleSheet,"\n"," ");boost::trim(styleSheet);boost::replace_all(styleSheet,"}","}\n");SVG_CSS_TRACE("ParseStyle CLEANED:\n"<<styleSheet);std::string output;boost::tokenizer<boost::char_separator<char>>cssLines(styleSheet,boost::char_separator<char>("\n"));for(boost::tokenizer<boost::char_separator<char>>::iterator it=cssLines.begin();it!=cssLines.end();++it){std::string cssLine{*it};boost::trim(cssLine);if(cssLine.find(",")==std::string::npos){output.append(cssLine);output.append("\n");}else{auto dataStart=cssLine.find("{");std::string cssData(cssLine.substr(dataStart,cssLine.find("}")-dataStart+1));std::string cssClasses(cssLine.substr(0,dataStart));boost::tokenizer<boost::char_separator<char>>cssClassTokens(cssClasses,boost::char_separator<char>(","));for(boost::tokenizer<boost::char_separator<char>>::iterator itc=cssClassTokens.begin();itc!=cssClassTokens.end();++itc){output.append(*itc);output.append(" ");output.append(cssData);output.append("\n");}}}SVG_CSS_TRACE("ParseStyle OUTPUT:\n"<<output);mCSSInfo=StyleSheet::CssDocument::parse(output);}void SVGDocumentImpl::ApplyCSSStyle(const std::set<std::string>&classNames,GraphicStyleImpl&graphicStyle,FillStyleImpl&fillStyle,StrokeStyleImpl&strokeStyle){if(!mOverrideStyle)return;for(const auto&className:classNames){auto selector=StyleSheet::CssSelector::CssClassSelector(className);if(!mOverrideStyle->hasSelector(selector))continue;auto cssElement=mOverrideStyle->getElement(selector);auto properties=cssElement.getProperties();ParseGraphicsProperties(graphicStyle,properties);ParseFillProperties(fillStyle,properties);ParseStrokeProperties(strokeStyle,properties);}}void SVGDocumentImpl::ParseStyleAttr(const XMLNode*node,std::vector<PropertySet>&propertySets,std::set<std::string>&classNames){auto attr=node->GetAttribute("style");if(attr.found){auto cssDoc=StyleSheet::CssDocument::parse(attr.value);auto cssElements=cssDoc.getElements();if(!cssElements.empty()){propertySets.push_back(cssElements.front().getProperties());}}attr=node->GetAttribute("class");if(attr.found){boost::char_separator<char>sep("\n\r\t ");std::string cssString=attr.value;boost::tokenizer<boost::char_separator<char>>tok(cssString,sep);for(boost::tokenizer<boost::char_separator<char>>::iterator it=tok.begin();it!=tok.end();++it){classNames.insert(*it);auto selector=StyleSheet::CssSelector::CssClassSelector(*it);auto cssElement=mCSSInfo.getElement(selector);propertySets.push_back(cssElement.getProperties());}}}}
#endif
</file>

<file path="svgnative/src/Interval.cpp">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "Interval.h"
#include <algorithm>

namespace SVGNative {
    Interval::Interval(float u, float v)
    {
        if (u <= v)
        {
            mA = u;
            mB = v;
        }
        else
        {
            mA = v;
            mB = u;
        }
    }

    Interval Interval::operator&(Interval other) const
    {
        // return an empty interval if either of the Intervals is empty
        if ((!*this) || (!other))
            return Interval();

        float u = (std::max)(this->Min(), other.Min());
        float v = (std::min)(this->Max(), other.Max());
        return (u <= v) ? Interval(u, v) : Interval();
    }
    Interval Interval::operator|(Interval other) const
    {
        if (this->IsEmpty() && !other.IsEmpty())
            return other;
        else if(!this->IsEmpty() && other.IsEmpty())
            return *this;
        else if(this->IsEmpty() && other.IsEmpty())
            return Interval();
        else
            return Interval((std::min)(this->Min(), other.Min()), (std::max)(this->Max(), other.Max()));
    }
    bool Interval::Contains(Interval other) const
    {
        if (other.IsEmpty())
            return true;
        else if(this->IsEmpty())
            return false;
        else
            return this->Min() <= other.Min() && this->Max() >= other.Max();
    }
}
</file>

<file path="svgnative/src/Interval.h">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_Interval_h
#define SVGViewer_Interval_h

#include <tuple>

namespace SVGNative {
/**
 * Represents an open interval.
 *
 * TODO: Just remove these mathematical definitions?
 *
 * The following statements hold true for an interval:
 * 1. An interval $I$ is defined as the set of all numbers between two
 * numbers $u$ and $v$ on the number line, but not equal to either of them.
 * 2. If $u$ and $v$ are the same numbers, the set becomes empty and thus
 * the interval is also recognized as empty.
 * 3. An interval $I$ is said to contain an interval $C$ if each element in
 * the set of interval $C$ is also a member of the set of interval $I$.
 * 4. The join of two intervals $A$ and $B$ is defined as an interval whose
 * set is defined as the smallest possible set of *complete* real numbers that
 * contain all members of $A$ as well as $B$. By complete we simply mean that
 * for any possible two members of the set, all real numbers between the two
 * must also be within the set. The word smallest here means that no other proper
 * subset of that set will satisfy all the requirements.
 * 5. The intersection of two intervals $A$ and $B$ is the one whose set is
 * the intersection of the sets of $A$ and $B$.
 */
class Interval
{
  public:
    Interval() = default;
    Interval(float u): Interval(u, u) {}
    Interval(float u, float v);

    /**
     * Returns the greatest possible real number that's small than every
     * member of this interval's set.
     */
    float Min() const { return mA; }

    /**
     * Returns the smallest possible real number that's greater than every
     * member of this interval's set.
     */
    float Max() const { return mB; }
    operator bool() const { return !IsEmpty(); }

    /* Computes the intersection of this interval with another one */
    Interval operator& (Interval other) const;

    /* Computes the join of this interval with another one, think of an interval that
     * contains both the intervals */
    Interval operator| (Interval other) const;

    /* Returns true if one interval contains another one */
    bool Contains (Interval other) const;

    /* Is the interval empty? having no points in its set? */
    bool IsEmpty() const { return mA == mB; }
  private:
    float mA{};
    float mB{};
};


}

#endif
</file>

<file path="svgnative/src/Rect.h">
#ifndef RECT_H
#define RECT_H
#include "svgnative/Rect.h"
#include "Interval.h"
#include<cmath>
#include<stdexcept>
#include<tuple>
namespace SVGNative{Rect::Rect(float aX,float aY,float aWidth,float aHeight){if(aWidth<0||aHeight<0){throw std::invalid_argument("Height or Width of a rectangle can't be negative!");}x=aX;y=aY;width=aWidth;height=aHeight;}bool Rect::IsEmpty()const{IntervalPair rectIntervals=Intervals();return std::get<0>(rectIntervals).IsEmpty()||std::get<1>(rectIntervals).IsEmpty();}bool Rect::Contains(Rect other)const{IntervalPair thisIntervals=Intervals();IntervalPair otherIntervals=other.Intervals();return std::get<0>(thisIntervals).Contains(std::get<0>(otherIntervals))&&std::get<1>(thisIntervals).Contains(std::get<1>(otherIntervals));}bool Rect::operator==(Rect other)const{return x==other.x&&y==other.y&&width==other.width&&height==other.height;}Rect Rect::operator&(Rect other)const{IntervalPair intervalsA=Intervals();IntervalPair intervalsB=other.Intervals();Interval resultX=std::get<0>(intervalsA)&std::get<0>(intervalsB);Interval resultY=std::get<1>(intervalsA)&std::get<1>(intervalsB);if(resultX.IsEmpty()||resultY.IsEmpty())return Rect{0,0,0,0};return Rect(resultX.Min(),resultY.Min(),resultX.Max()-resultX.Min(),resultY.Max()-resultY.Min());}Rect Rect::operator|(Rect other)const{IntervalPair intervalsA=Intervals();IntervalPair intervalsB=other.Intervals();Interval resultX=std::get<0>(intervalsA)|std::get<0>(intervalsB);Interval resultY=std::get<1>(intervalsA)|std::get<1>(intervalsB);if(resultX.IsEmpty()||resultY.IsEmpty())return Rect{0,0,0,0};return Rect(resultX.Min(),resultY.Min(),resultX.Max()-resultX.Min(),resultY.Max()-resultY.Min());}float Rect::MaxDiffVertex(Rect other)const{float topLeftDiff=std::sqrt(std::pow(Left()-other.Left(),2)+std::pow(Top()-other.Top(),2));float topRightDiff=std::sqrt(std::pow(Right()-other.Right(),2)+std::pow(Top()-other.Top(),2));float bottomLeftDiff=std::sqrt(std::pow(Left()-other.Left(),2)+std::pow(Bottom()-other.Bottom(),2));float bottomRightDiff=std::sqrt(std::pow(Right()-other.Right(),2)+std::pow(Bottom()-other.Bottom(),2));float max1=std::max(topLeftDiff,topRightDiff);float max2=std::max(bottomLeftDiff,bottomRightDiff);return std::max(max1,max2);}IntervalPair Rect::Intervals()const{return IntervalPair(Interval(x,x+width),Interval(y,y+height));}}
#endif
</file>

<file path="svgnative/src/SVGDocument.h">
#ifndef SVGDOCUMENT_H
#define SVGDOCUMENT_H
#include "svgnative/SVGDocument.h"
#include "SVGDocumentImpl.h"
#include "svgnative/SVGRenderer.h"
#ifdef STYLE_SUPPORT
#include "StyleSheet/Document.h"
#include "StyleSheet/Parser.h"
#endif
#include "xml/XMLParser.h"
#include<stdexcept>
#include<stdlib.h>
#include<string>
namespace SVGNative{std::unique_ptr<SVGDocument>SVGDocument::CreateSVGDocument(const char*s,std::shared_ptr<SVGRenderer>renderer){try{if(!renderer)return nullptr;auto xmlDocument=xml::XMLDocument::CreateXMLDocument(s);if(!xmlDocument)return nullptr;auto rootNode=xmlDocument->GetFirstNode();if(!rootNode)return nullptr;auto realSVGDoc=std::unique_ptr<SVGDocumentImpl>(new SVGDocumentImpl(renderer));if(!realSVGDoc)return nullptr;realSVGDoc->TraverseSVGTree(rootNode.get());auto retval=new SVGDocument();retval->mDocument=std::move(realSVGDoc);return std::unique_ptr<SVGDocument>(retval);}catch(...){}return nullptr;}SVGDocument::SVGDocument(){}SVGDocument::~SVGDocument(){}void SVGDocument::Render(){if(!mDocument)return;ColorMap colorMap;mDocument->Render(colorMap,mDocument->mViewBox[2],mDocument->mViewBox[3]);}void SVGDocument::Render(float width,float height){if(!mDocument)return;ColorMap colorMap;mDocument->Render(colorMap,width,height);}void SVGDocument::Render(const ColorMap&colorMap){if(!mDocument)return;mDocument->Render(colorMap,mDocument->mViewBox[2],mDocument->mViewBox[3]);}void SVGDocument::Render(const ColorMap&colorMap,float width,float height){if(!mDocument)return;mDocument->Render(colorMap,width,height);}void SVGDocument::Render(const char*id){if(!mDocument)return;ColorMap colorMap;mDocument->Render(id,colorMap,mDocument->mViewBox[2],mDocument->mViewBox[3]);}void SVGDocument::Render(const char*id,float width,float height){if(!mDocument)return;ColorMap colorMap;mDocument->Render(id,colorMap,width,height);}void SVGDocument::Render(const char*id,const ColorMap&colorMap){if(!mDocument)return;mDocument->Render(id,colorMap,mDocument->mViewBox[2],mDocument->mViewBox[3]);}void SVGDocument::Render(const char*id,const ColorMap&colorMap,float width,float height){if(!mDocument)return;mDocument->Render(id,colorMap,width,height);}bool SVGDocument::GetBoundingBox(Rect&bounds){if(!mDocument)return false;return mDocument->GetBoundingBox(bounds);}bool SVGDocument::GetBoundingBox(const char*id,Rect&bounds){if(!mDocument)return false;return mDocument->GetBoundingBox(id,bounds);}void SVGDocument::GetViewBox(Rect&viewBox){viewBox.x=mDocument->mViewBox[0];viewBox.y=mDocument->mViewBox[1];viewBox.width=mDocument->mViewBox[2];viewBox.height=mDocument->mViewBox[3];}
#ifdef DEBUG_API
bool GetSubBoundingBoxes(std::vector<Rect>&bounds){if(!mDocument)return false;return mDocument->GetSubBoundingBoxes(bounds);}
#endif
std::int32_t SVGDocument::Width()const{if(!mDocument)return 0;return static_cast<std::int32_t>(mDocument->mViewBox[2]);}std::int32_t SVGDocument::Height()const{if(!mDocument)return 0;return static_cast<std::int32_t>(mDocument->mViewBox[3]);}SVGRenderer*SVGDocument::Renderer()const{if(!mDocument)return 0;return mDocument->mRenderer.get();}
#ifdef STYLE_SUPPORT
void SVGDocument::AddCustomCSS(const StyleSheet::CssDocument*cssDocument){if(!mDocument)return;mDocument->AddCustomCSS(cssDocument);}void SVGDocument::ClearCustomCSS(){if(!mDocument)return;mDocument->ClearCustomCSS();}
#endif
}
#endif
</file>

<file path="svgnative/src/SVGNativeCWrapper.h">
#ifndef SVG_NATIVE_HEADER_H
#define SVG_NATIVE_HEADER_H
#include "svgnative/SVGNativeCWrapper.h"
#include "svgnative/SVGDocument.h"
#include "svgnative/SVGRenderer.h"
#ifdef USE_CAIRO
#include "svgnative/ports/cairo/CairoSVGRenderer.h"
#endif
#ifdef USE_CG
#include "svgnative/ports/cg/CGSVGRenderer.h"
#include<CoreServices/CoreServices.h>
#include<CoreGraphics/CoreGraphics.h>
#endif
#ifdef USE_SKIA
#include "svgnative/ports/skia/SkiaSVGRenderer.h"
#include "SkCanvas.h"
#include "SkImage.h"
#endif
#ifdef USE_GDIPLUS
#include<windows.h>
#include<Gdiplus.h>
#include "svgnative/ports/gdiplus/GDIPlusSVGRenderer.h"
#endif
#ifdef USE_TEXT
#include "svgnative/ports/string/StringSVGRenderer.h"
#endif
#include<map>
#include<memory>
template<typename T>void ignore(T&&){}struct svg_native_color_map_t_{SVGNative::ColorMap mColorMap;};struct svg_native_t_{std::shared_ptr<SVGNative::SVGRenderer>mRenderer;std::unique_ptr<SVGNative::SVGDocument>mDocument;svg_native_renderer_type_t mRendererType{SVG_RENDERER_UNKNOWN};svg_native_color_map_t*mColorMap{};};svg_native_color_map_t*svg_native_color_map_create(){return reinterpret_cast<svg_native_color_map_t*>(new svg_native_color_map_t_);}void svg_native_color_map_add(svg_native_color_map_t*color_map,const char*color_key,float red,float green,float blue,float alpha){if(auto _color_map=dynamic_cast<svg_native_color_map_t_*>(color_map)){_color_map->mColorMap.insert({color_key,{red,green,blue,alpha}});}}void svg_native_color_map_destroy(svg_native_color_map_t*color_map){if(auto _color_map=dynamic_cast<svg_native_color_map_t_*>(color_map)){delete _color_map;}}svg_native_t*svg_native_create(svg_native_renderer_type_t renderer_type,const char*document_string){auto sn=new svg_native_t_;switch(renderer_type){case SVG_RENDERER_CAIRO:{
#ifdef USE_CAIRO
sn->mRenderer=std::make_shared<SVGNative::CairoSVGRenderer>();sn->mRendererType=renderer_type;
#endif
break;}case SVG_RENDERER_CG:{
#ifdef USE_CG
sn->mRenderer=std::make_shared<SVGNative::CGSVGRenderer>();sn->mRendererType=renderer_type;
#endif
break;}case SVG_RENDERER_GDIPLUS:{
#ifdef USE_GDIPLUS
sn->mRenderer=std::make_shared<SVGNative::GDIPlusSVGRenderer>();sn->mRendererType=renderer_type;
#endif
break;}case SVG_RENDERER_SKIA:{
#ifdef USE_SKIA
sn->mRenderer=std::make_shared<SVGNative::SkiaSVGRenderer>();sn->mRendererType=renderer_type;
#endif
break;}case SVG_RENDERER_STRING:{
#ifdef USE_TEXT
sn->mRenderer=std::make_shared<SVGNative::StringSVGRenderer>();sn->mRendererType=renderer_type;
#endif
break;}default:break;}if(!sn->mRenderer){return nullptr;}sn->mDocument=SVGNative::SVGDocument::CreateSVGDocument(document_string,sn->mRenderer);return reinterpret_cast<svg_native_t*>(sn);}void svg_native_set_color_map(svg_native_t*sn,svg_native_color_map_t*color_map){if(auto _sn=dynamic_cast<svg_native_t_*>(sn)){_sn->mColorMap=color_map;}}void svg_native_set_renderer(svg_native_t*sn,svg_native_renderer_t*renderer){auto _sn=dynamic_cast<svg_native_t_*>(sn);if(!_sn){return;}switch(_sn->mRendererType){case SVG_RENDERER_CAIRO:{
#ifdef USE_CAIRO
if(auto nativeRenderer=static_cast<cairo_t*>(renderer)){if(auto snRenderer=std::dynamic_pointer_cast<SVGNative::CairoSVGRenderer>(_sn->mRenderer)){snRenderer->SetCairo(nativeRenderer);return;}}
#endif
break;}case SVG_RENDERER_CG:{
#ifdef USE_CG
if(auto nativeRenderer=static_cast<CGContextRef>(renderer)){if(auto snRenderer=std::dynamic_pointer_cast<SVGNative::CGSVGRenderer>(_sn->mRenderer)){snRenderer->SetGraphicsContext(nativeRenderer);return;}}
#endif
break;}case SVG_RENDERER_GDIPLUS:{
#ifdef USE_GDIPLUS
if(auto nativeRenderer=static_cast<Gdiplus::Graphics*>(renderer)){if(auto snRenderer=std::dynamic_pointer_cast<SVGNative::GDIPlusSVGRenderer>(_sn->mRenderer)){snRenderer->SetGraphicsContext(nativeRenderer);return;}}
#endif
break;}case SVG_RENDERER_SKIA:{
#ifdef USE_SKIA
if(auto nativeRenderer=static_cast<SkCanvas*>(renderer)){if(auto snRenderer=std::dynamic_pointer_cast<SVGNative::SkiaSVGRenderer>(_sn->mRenderer)){snRenderer->SetSkCanvas(nativeRenderer);return;}}
#endif
break;}default:ignore(renderer);break;}}float svg_native_canvas_width(svg_native_t*sn){auto _sn=dynamic_cast<svg_native_t_*>(sn);if(!_sn||!_sn->mDocument){return 0;}return _sn->mDocument->Width();}float svg_native_canvas_height(svg_native_t*sn){auto _sn=dynamic_cast<svg_native_t_*>(sn);if(!_sn||!_sn->mDocument){return 0;}return _sn->mDocument->Height();}void svg_native_render(svg_native_t*sn){auto _sn=dynamic_cast<svg_native_t_*>(sn);if(!_sn||!_sn->mDocument){return;}if(_sn->mColorMap){_sn->mDocument->Render(_sn->mColorMap->mColorMap);}else{_sn->mDocument->Render();}}void svg_native_render_size(svg_native_t*sn,float width,float height){auto _sn=dynamic_cast<svg_native_t_*>(sn);if(!_sn||!_sn->mDocument){return;}if(_sn->mColorMap){_sn->mDocument->Render(_sn->mColorMap->mColorMap,width,height);}else{_sn->mDocument->Render(width,height);}}
#ifdef USE_TEXT
void svg_native_get_output(svg_native_t*sn,char**buff,size_t*length){if(!buff||!length){return;}*buff=NULL;*length=0;auto _sn=dynamic_cast<svg_native_t_*>(sn);if(!_sn||_sn->mRendererType!=SVG_RENDERER_STRING){return;}auto renderer=std::dynamic_pointer_cast<SVGNative::StringSVGRenderer>(_sn->mRenderer);if(!renderer){return;}const auto&string=renderer->String();auto size=string.length()+1;*buff=(char*)malloc(size*sizeof(char));if(!(*buff)){return;}memcpy(*buff,string.c_str(),size);*length=string.length();return;}
#endif
void svg_native_destroy(svg_native_t*sn){if(auto _sn=dynamic_cast<svg_native_t_*>(sn)){delete _sn;}}
#endif
</file>

<file path="svgnative/src/SVGParserArcToCurve.cpp">
/*
Copyright 2016 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/SVGDocument.h"
#include "svgnative/SVGRenderer.h"

#define _USE_MATH_DEFINES
#include <cmath>
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif

namespace SVGNative
{

void RotatePoint(float& x, float& y, float angle);
void RotatePoint(float& /*x*/, float& /*y*/, float /*angle*/) { SVG_ASSERT(false); }

void AddArcToCurve(SVGNative::Path& path, float startX, float startY, float radiusX, float radiusY, float angle,
    float endX, float endY, float startAngle, float endAngle, float& endControlX, float& endControlY);
void AddArcToCurve(SVGNative::Path& path, float startX, float startY, float radiusX, float radiusY, float /*angle*/,
    float endX, float endY, float startAngle, float endAngle, float& endControlX, float& endControlY)
{
    // trigonometry
    float t = tan((endAngle - startAngle) / 4);
    float hx = radiusX * t * 4 / 3;
    float hy = radiusY * t * 4 / 3;

    // calculate control points
    float startCPX = startX + hx * sin(startAngle);
    float startCPY = startY - hy * cos(startAngle);

    startCPX = 2 * startX - startCPX;
    startCPY = 2 * startY - startCPY;

    float endCPX = endX + hx * sin(endAngle);
    float endCPY = endY - hy * cos(endAngle);

    // !!! don't forget to rotate points back to the original reference frame

    // add curve
    path.CurveTo(startCPX, startCPY, endCPX, endCPY, endX, endY);

    endControlX = endCPX;
    endControlY = endCPY;

    SVG_PARSE_TRACE("AddArcToCurve startAngle=" << (startAngle * 180 / M_PI) << " endAngle=" << (endAngle * 180 / M_PI));
    SVG_PARSE_TRACE("AddArcToCurve startCP=("
        << startCPX << "," << startCPY << ") endCP=(" << endCPX << "," << endCPY << ") EndPoint=(" << endX
        << "," << endY << ")");
}

void ArcToCurve(SVGNative::Path& path, float startX, float startY, float radiusX, float radiusY, float angle, bool sweep,
    float endX, float endY, float startAngle, float endAngle, float centerX, float centerY, float& endControlX,
    float& endControlY);
void ArcToCurve(SVGNative::Path& path, float startX, float startY, float radiusX, float radiusY, float angle, bool sweep,
    float endX, float endY, float startAngle, float endAngle, float centerX, float centerY, float& endControlX,
    float& endControlY)
{
    float angleDiff = endAngle - startAngle;
    if (std::abs(angleDiff) > M_PI * 120.0f / 180.0f)
    {
        // too wide so we need to break it up into multiple curves
        float endAngleNext = endAngle;
        float endXNext = endX;
        float endYNext = endY;

        endAngle = startAngle + (M_PI * 120.0f / 180.0f) * ((sweep && (endAngle > startAngle)) ? 1 : -1);
        endX = centerX + radiusX * cos(endAngle);
        endY = centerY + radiusY * sin(endAngle);

        AddArcToCurve(
            path, startX, startY, radiusX, radiusY, angle, endX, endY, startAngle, endAngle, endControlX, endControlY);
        ArcToCurve(path, endX, endY, radiusX, radiusY, angle, sweep, endXNext, endYNext, endAngle, endAngleNext,
            centerX, centerY, endControlX, endControlY);
    }
    else
    {
        AddArcToCurve(
            path, startX, startY, radiusX, radiusY, angle, endX, endY, startAngle, endAngle, endControlX, endControlY);
    }
}

void ArcToCurve(SVGNative::Path& path, float startX, float startY, float radiusX, float radiusY, float angle, bool large,
    bool sweep, float endX, float endY, float& endControlX, float& endControlY);
void ArcToCurve(SVGNative::Path& path, float startX, float startY, float radiusX, float radiusY, float angle, bool large,
    bool sweep, float endX, float endY, float& endControlX, float& endControlY)
{
    // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes

    SVG_ASSERT(angle == 0); // untested

    if (radiusX == 0 || radiusY == 0)
    {
        // this is actually a line
        path.LineTo(endX, endY);
        return;
    }

    SVG_ASSERT(radiusX == radiusY); // untested

    SVG_ASSERT(radiusX != 0 && radiusY != 0);

    SVG_PARSE_TRACE("ArcToCurve ----------------------------------------------");
    SVG_PARSE_TRACE("parsePathString ArcToCurve: rx="
                          << radiusX << " ry=" << radiusY << " large=" << large << " sweep=" << sweep << " previous=("
                          << startX << "," << startY << ")"
                          << " next=(" << endX << "," << endY << ")");

    angle = M_PI / 180 * angle; // all radians all the time

    if (radiusX != radiusY)
        SVG_PARSE_TRACE("parsePathString ELLIPTICAL: " << angle);

    // handle rotation here and when we plot points to the path.CurveTo !!!
    //	RotatePoint(startX, startY, angle);
    //	RotatePoint(endX, endY, angle);

    // Calculate the whatchamacallit.
    float hx = (startX - endX) / 2;
    float hy = (startY - endY) / 2;

    // correct out of range radii F.6.6
    float validateRadii = (hx * hx) / (radiusX * radiusX) + (hy * hy) / (radiusY * radiusY);
    if (validateRadii > 1)
    {
        radiusX = radiusX * sqrt(validateRadii);
        radiusY = radiusY * sqrt(validateRadii);
    }

    SVG_PARSE_TRACE("ArcToCurve final radii: rx=" << radiusX << " ry=" << radiusY);

    // start calculating
    // F.6.5.2
    float radiusX2(radiusX * radiusX);
    float radiusY2(radiusY * radiusY);
    float HX2(hx * hx);
    float HY2(hy * hy);

    float k = (radiusX2 * radiusY2 - radiusX2 * HY2 - radiusY2 * HX2) / (radiusX2 * HY2 + radiusY2 * HX2);
    k = sqrt(std::abs(k)) * (large == sweep ? -1 : 1);

    float centerX = k * (radiusX * hy / radiusY);
    float centerY = k * (-radiusY * hx / radiusX);

    // F.6.5.3 - center of ellipse
    centerX += (startX + endX) / 2;
    centerY += (startY + endY) / 2;

    SVG_PARSE_TRACE("parsePathString ArcToCurve: center(" << centerX << "," << centerY << ")");
    SVG_PARSE_TRACE("parsePathString ArcToCurve: radius("
                              << sqrt((centerX - startX) * (centerX - startX) + (centerY - startY) * (centerY - startY))
                              << "," << sqrt((centerX - endX) * (centerX - endX) + (centerY - endY) * (centerY - endY))
                              << ")");

    // calculate angles
    // F.6.5.4 to F.6.5.6
    float aS = (startY - centerY) / radiusY;
    float aE = (endY - centerY) / radiusY;

    // preventing out of range errors with asin due to floating point errors
    aS = std::min(aS, 1.0f);
    aS = std::max(aS, -1.0f);

    aE = std::min(aE, 1.0f);
    aE = std::max(aE, -1.0f);

    SVG_ASSERT_MSG(aS >= -1 && aS <= 1, "aS: " << aS);
    SVG_ASSERT_MSG(aE >= -1 && aE <= 1, "aE: " << aE);

    // get the angle
    float startAngle = asin(aS);
    float endAngle = asin(aE);

    if (startX < centerX)
        startAngle = M_PI - startAngle;

    if (endX < centerX)
        endAngle = M_PI - endAngle;

    if (startAngle < 0)
        startAngle = M_PI * 2 + startAngle;

    if (endAngle < 0)
        endAngle = M_PI * 2 + endAngle;

    SVG_PARSE_TRACE(
        "parsePathString ArcToCurve: angles(" << (startAngle * 180 / M_PI) << "," << (endAngle * 180 / M_PI) << ")");

    if (sweep && startAngle > endAngle)
    {
        startAngle = startAngle - M_PI * 2.0f;
    }
    if (!sweep && endAngle > startAngle)
    {
        endAngle = endAngle - M_PI * 2.0f;
    }

    SVG_PARSE_TRACE(
        "parsePathString ArcToCurve: anglesF(" << (startAngle * 180.0f / M_PI) << "," << (endAngle * 180.0f / M_PI) << ")");

    ArcToCurve(path, startX, startY, radiusX, radiusY, angle, sweep, endX, endY, startAngle, endAngle, centerX, centerY,
        endControlX, endControlY);
}

}
</file>

<file path="svgnative/src/SVGParserArcToCurve.h">
```cpp
#ifndef SVGDOCUMENT_H
#define SVGDOCUMENT_H
#include "svgnative/SVGDocument.h"
#include "svgnative/SVGRenderer.h"
#define _USE_MATH_DEFINES
#include<cmath>
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif
namespace SVGNative{void RotatePoint(float&x,float&y,float angle);void RotatePoint(float&){SVG_ASSERT(false);}void AddArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,float endX,float endY,float startAngle,float endAngle,float&endControlX,float&endControlY);void AddArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float,float endX,float endY,float startAngle,float endAngle,float&endControlX,float&endControlY){float t=tan((endAngle-startAngle)/4);float hx=radiusX*t*4/3;float hy=radiusY*t*4/3;float startCPX=startX+hx*sin(startAngle);float startCPY=startY-hy*cos(startAngle);startCPX=2*startX-startCPX;startCPY=2*startY-startCPY;float endCPX=endX+hx*sin(endAngle);float endCPY=endY-hy*cos(endAngle);path.CurveTo(startCPX,startCPY,endCPX,endCPY,endX,endY);endControlX=endCPX;endControlY=endCPY;SVG_PARSE_TRACE("AddArcToCurve startAngle="<<(startAngle*180/M_PI)<<" endAngle="<<(endAngle*180/M_PI));SVG_PARSE_TRACE("AddArcToCurve startCP=("<<startCPX<<","<<startCPY<<")endCP=("<<endCPX<<","<<endCPY<<")EndPoint=("<<endX<<","<<endY<<")");}void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool sweep,float endX,float endY,float startAngle,float endAngle,float centerX,float centerY,float&endControlX,float&endControlY);void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool sweep,float endX,float endY,float startAngle,float endAngle,float centerX,float centerY,float&endControlX,float&endControlY){float angleDiff=endAngle-startAngle;if(std::abs(angleDiff)>M_PI*120.0f/180.0f){float endAngleNext=endAngle;float endXNext=endX;float endYNext=endY;endAngle=startAngle+(M_PI*120.0f/180.0f)*((sweep&&(endAngle>startAngle))?1:-1);endX=centerX+radiusX*cos(endAngle);endY=centerY+radiusY*sin(endAngle);AddArcToCurve(path,startX,startY,radiusX,radiusY,angle,endX,endY,startAngle,endAngle,endControlX,endControlY);ArcToCurve(path,endX,endY,radiusX,radiusY,angle,sweep,endXNext,endYNext,endAngle,endAngleNext,centerX,centerY,endControlX,endControlY);}else{AddArcToCurve(path,startX,startY,radiusX,radiusY,angle,endX,endY,startAngle,endAngle,endControlX,endControlY);}}void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool large,bool sweep,float endX,float endY,float&endControlX,float&endControlY);void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool large,bool sweep,float endX,float endY,float&endControlX,float&endControlY){SVG_ASSERT(angle==0);if(radiusX==0||radiusY==0){path.LineTo(endX,endY);return;}SVG_ASSERT(radiusX==radiusY);SVG_ASSERT(radiusX!=0&&radiusY!=0);SVG_PARSE_TRACE("ArcToCurve----------------------------------------------");SVG_PARSE_TRACE("parsePathString ArcToCurve:rx="<<radiusX<<" ry="<<radiusY<<" large="<<large<<" sweep="<<sweep<<" previous=("<<startX<<","<<startY<<")"<<" next=("<<endX<<","<<endY<<")");angle=M_PI/180*angle;if(radiusX!=radiusY)SVG_PARSE_TRACE("parsePathString ELLIPTICAL:"<<angle);float hx=(startX-endX)/2;float hy=(startY-endY)/2;float validateRadii=(hx*hx)/(radiusX*radiusX)+(hy*hy)/(radiusY*radiusY);if(validateRadii>1){radiusX=radiusX*sqrt(validateRadii);radiusY=radiusY*sqrt(validateRadii);}SVG_PARSE_TRACE("ArcToCurve final radii:rx="<<radiusX<<" ry="<<radiusY);float radiusX2(radiusX*radiusX);float radiusY2(radiusY*radiusY);float HX2(hx*hx);float HY2(hy*hy);float k=(radiusX2*radiusY2-radiusX2*HY2-radiusY2*HX2)/(radiusX2*HY2+radiusY2*HX2);k=sqrt(std::abs(k))*(large==sweep?-1:1);float centerX=k*(radiusX*hy/radiusY);float centerY=k*(-radiusY*hx/radiusX);centerX+=(startX+endX)/2;centerY+=(startY+endY)/2;SVG_PARSE_TRACE("parsePathString ArcToCurve:center("<<centerX<<","<<centerY<<")");SVG_PARSE_TRACE("parsePathString ArcToCurve:radius("<<sqrt((centerX-startX)*(centerX-startX)+(centerY-startY)*(centerY-startY))<<","<<sqrt((centerX-endX)*(centerX-endX)+(centerY-endY)*(centerY-endY))<<")");float aS=(startY-centerY)/radiusY;float aE=(endY-centerY)/radiusY;aS=std::min(aS,1.0f);aS=std::max(aS,-1.0f);aE=std::min(aE,1.0f);aE=std::max(aE,-1.0f);SVG_ASSERT_MSG(aS>=-1&&aS<=1,"aS:"<<aS);SVG_ASSERT_MSG(aE>=-1&&aE<=1,"aE:"<<aE);float startAngle=asin(aS);float endAngle=asin(aE);if(startX<centerX)startAngle
</file>

<file path="svgnative/test/elem-currentColor.svg">
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g color="red">
        <rect id="ref" width="200" height="200" fill="currentColor" />
    </g>
</svg>
</file>

<file path="svgnative/test/elem-currentColor.txt">
[group transform: matrix(1,0,0,1,0,0)
    [path Rect(0,0,200,200)
        fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
]
</file>

<file path="svgnative/test/elem-defs.svg">
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <rect id="ref" width="200" height="200" fill="green" />
    </defs>
</svg>
</file>

<file path="svgnative/test/elem-transform-on-parent.txt">
[group transform: matrix(1,0,0,1,0,0)
    [path Rect(0,0,200,200)
        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
]
</file>

<file path="svgnative/test/gradient-outside-defs.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="150" height="250" viewBox="0 0 150 250">
    <linearGradient id="g1" gradientUnits="userSpaceOnUse">
        <stop stop-color="#0000FF" offset="0"/>
        <stop stop-color="#00FF00" offset="1"/>
    </linearGradient>
    <radialGradient id="g2" gradientUnits="userSpaceOnUse">
        <stop stop-color="#0000FF" offset="0"/>
        <stop stop-color="#00FF00" offset="1"/>
    </radialGradient>
    <rect width="150" height="10" fill="url(#g1)" y="180"/>
    <rect width="150" height="10" fill="url(#g2)" y="180"/>
</svg>
</file>

<file path="svgnative/test/shapes.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="250" viewBox="0 0 150 250">
    <!-- test that we disable rendering for certain values close to 0 -->
    <rect width="1" height="1"/>
    <rect width="1e20" height="1"/>
    <rect width="1" height="1e20"/>
    <rect width="1e40" height="1"/>
    <rect width="1" height="1e40"/>
    <rect width="1e60" height="1"/>
    <rect width="1" height="1e60"/>
    <rect width="0" height="1"/>
    <rect width="1" height="0"/>
    <ellipse rx="1" ry="1"/>
    <ellipse rx="1e20" ry="1"/>
    <ellipse rx="1" ry="1e20"/>
    <ellipse rx="1e40" ry="1"/>
    <ellipse rx="1" ry="1e40"/>
    <ellipse rx="1e60" ry="1"/>
    <ellipse rx="1" ry="1e60"/>
    <ellipse rx="0" ry="1"/>
    <ellipse rx="1" ry="0"/>
    <circle r="1"/>
    <circle r="1e20"/>
    <circle r="1e40"/>
    <circle r="1e60"/>
    <circle r="0"/>
</svg>
</file>

<file path="svgnative/test/svgLength.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="250" viewBox="0 0 150 250">
    <rect  y="0" height="10" width="100"/>
    <rect  y="10" height="10" width="50%"/>
    <rect  y="20" height="10" width="0.5%"/>
    <rect  y="30" height="10" width="0.5%"/>
    <rect  y="40" height="10" width="100px"/>
    <rect  y="50" height="10" width="50pt"/>
    <rect  y="60" height="10" width="10pc"/>
    <rect  y="70" height="10" width="0.5cm"/>
    <rect  y="80" height="10" width="5mm"/>
    <rect  y="90" height="10" width="0.5in"/>
    <rect  y="90" height="10" width="0.5in   "/>
    <rect  y="90" height="10" width="   0.5in"/>
    <rect  y="90" height="10" width="
    0.5in"/>
    <rect  y="90" height="10" width="50" x="-.5e2"/>
    <rect  y="90" height="10" width="50" x="5000e-2"/>
    <rect  y="90" height="10" width="50" x=".5e-2"/>
    <rect  y="90" height="10" width="50" x="5.e-1"/>

    <circle cx="50%" cy="50%" r="50%"/>
    <ellipse cx="50%" cy="50%" rx="50%" ry="50%"/>
    <rect x="25%" y="25%" width="50%" height="50%"/>

    <!-- negative tests -->
    <rect fill="red" x="50e" y="100" height="5" width="50"/>
    <rect fill="red" x="50pxx" y="105" height="5" width="50"/>
    <rect fill="red" x="50epx" y="110" height="5" width="50"/>
    <rect fill="red" x="50 px" y="115" height="5" width="50"/>
    <rect fill="red" x="--70px" y="120" height="5" width="50"/>
    <rect fill="red" x="1..1px" y="125" height="5" width="50"/>
    <rect fill="red" x=".e10" y="130" height="5" width="50"/>

    <!-- for visual testing -->
    <rect fill="green" y="100" width="50" height="100"/>
</svg>
</file>

<file path="svgnative/test/svgLength.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,0,100,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,10,75,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,20,0.75,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,30,0.75,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,40,100,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,50,66.7,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,60,160,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,70,18.9,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,80,18.9,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,90,48,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,90,48,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,90,48,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,90,48,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(-50,90,50,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(50,90,50,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0.005,90,50,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,90,50,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(75,125,146,146)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(75,125,75,125)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(37.5,62.5,75,125)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,100,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,105,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,110,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,115,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,120,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,125,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,130,50,5)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,100,50,100)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/symboles.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="150" height="250" viewBox="0 0 150 250">
    <!-- symbols are not officially support and the implementation will get removed eventually -->
    <symbol viewBox="10 20 30" id="invalid-viewBox">
        <rect width="20" height="20" />
    </symbol>
    <use xlink:href="#invalid-viewBox" />
</svg>
</file>

<file path="svgnative/test/symboles.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [group
                [path Rect(0,0,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                    stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            ]
            [group
                [group
                    [path Rect(0,0,20,20)
                        fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
            ]
        ]
    ]
]
</file>

<file path="svgnative/test/transform.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200" transform="scale(2)">
    <rect width="10" height="10" transform="translate(13)"/>
    <rect width="10" height="10" transform="translate(12, 34)"/>
    <rect width="10" height="10" transform="    translate(12, 34)    "/>
    <rect width="10" height="10" transform="translate   (12, 34)"/>
    <rect width="10" height="10" transform="translate(12 34)"/>
    <rect width="10" height="10" transform="translate(12 , 34)"/>
    <rect width="10" height="10" transform="translate(
    12 ,    34)     "/>
    <rect width="10" height="10" transform="scale(13)"/>
    <rect width="10" height="10" transform="scale(12, 34)"/>
    <rect width="10" height="10" transform="    scale(12, 34)    "/>
    <rect width="10" height="10" transform="scale   (12, 34)"/>
    <rect width="10" height="10" transform="scale(12 34)"/>
    <rect width="10" height="10" transform="scale(12 , 34)"/>
    <rect width="10" height="10" transform="scale(
    12 ,    34)     "/>
    <rect width="10" height="10" transform="rotate(45)"/>
    <rect width="10" height="10" transform="rotate(765)"/>
    <rect width="10" height="10" transform="rotate(45, 34, 75)"/>
    <rect width="10" height="10" transform="    scale(45, 34, 75)    "/>
    <rect width="10" height="10" transform="rotate   (45, 34, 75)"/>
    <rect width="10" height="10" transform="rotate(45 34, 75)"/>
    <rect width="10" height="10" transform="rotate(45, 34 75)"/>
    <rect width="10" height="10" transform="rotate(45 34 75)"/>
    <rect width="10" height="10" transform="rotate(45 34, 75)"/>
    <rect width="10" height="10" transform="rotate(45 , 34  ,75     )"/>
    <rect width="10" height="10" transform="rotate(
    45 ,    34  75)     "/>
    <rect width="10" height="10" transform="skewX(45)"/>
    <rect width="10" height="10" transform="    skewX(45)   "/>
    <rect width="10" height="10" transform="skewX  (45)"/>
    <rect width="10" height="10" transform="skewX(  45)"/>
    <rect width="10" height="10" transform="skewX(45  )"/>
    <rect width="10" height="10" transform="skewX(  45
      )"/>
    <rect width="10" height="10" transform="skewX(  765
      )"/>
    <rect width="10" height="10" transform="skewY(45)"/>
    <rect width="10" height="10" transform="    skewY(45)    "/>
    <rect width="10" height="10" transform="skewY  (45)"/>
    <rect width="10" height="10" transform="skewY(  45)"/>
    <rect width="10" height="10" transform="skewY(45  )"/>
    <rect width="10" height="10" transform="skewY(  45
      )"/>
    <rect width="10" height="10" transform="skewX(  765
      )"/>
    <rect width="10" height="10" transform="matrix(1, 2, 3, 4, 5, 6)"/>
    <rect width="10" height="10" transform="    matrix(1, 2, 3, 4, 5, 6)    "/>
    <rect width="10" height="10" transform="matrix(1 2 3 4 5 6)"/>
    <rect width="10" height="10" transform="matrix(1 2, 3 4, 5 6)"/>
    <rect width="10" height="10" transform="matrix(1, 2 3, 4 5, 6)"/>
    <rect width="10" height="10" transform="matrix    (1, 2, 3, 4, 5, 6)"/>
    <rect width="10" height="10" transform="matrix(1    , 2, 3  , 4, 
    5  , 6     )"/>
    <rect width="10" height="10" transform="scale(2) rotate(45, 50, 60) translate(20, 30)"/>
    <rect width="10" height="10" transform="scale(2)        rotate(45, 50, 60)    translate(20, 30)"/>
    <rect width="10" height="10" transform="scale(2)  ,   rotate(45, 50, 60)    ,   
    translate(20, 30)"/>
    <rect width="10" height="10" transform="translate(20, 20) translate() scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) scale() scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) rotate() scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) matrix() scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) skewX() scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) skewY() scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) ; scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) ,, scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) translate(20, 20, 20) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) scale(20, 20, 20) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) rotate(20, 20) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) rotate(20, 20, 20, 20) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) skewX(20, 20) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) skewY(20, 20) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) matrix(1, 2, 3, 4, 5) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20) matrix(1, 2, 3, 4, 5, 6, 7) scale(20)"/>
    <rect width="10" height="10" transform="translate(20, 20)translate(20, 20)"/>
    <rect width="10" height="10" transform="translate(-.20, 0)"/>
    <rect width="10" height="10" transform="translate(-.2e20, 0)"/>
    <rect width="10" height="10" transform="translate(-.2e2, 0)"/>
    <rect width="10" height="10" transform="translate(-.2e-2, 0)"/>
    <rect width="10" height="10" transform="translate(-2.e2, 0)"/>
    <rect width="10" height="10" transform="translate(-2.e-2, 0)"/>
    <rect width="10" height="10" transform="translate(.20, 0)"/>
    <rect width="10" height="10" transform="translate(.2e20, 0)"/>
    <rect width="10" height="10" transform="translate(.2e2, 0)"/>
    <rect width="10" height="10" transform="translate(.2e-2, 0)"/>
    <rect width="10" height="10" transform="translate(2.e2, 0)"/>
    <rect width="10" height="10" transform="translate(2.e-2, 0)"/>
    <rect width="10" height="10" transform="translate(2e2.2, 0)"/>
    <rect width="10" height="10" transform="translate(2e2.2)"/>
    <rect width="10" height="10" transform="translate(.2e2-.2)"/>
    <rect width="10" height="10" transform="translate(.2e2.2e2)"/>
    <rect width="10" height="10" transform="translate(2.e2-2.e2)"/>
    <rect width="10" height="10" transform="translate(-..20, 0)"/>
    <rect width="10" height="10" transform="translate(-0.-e2, 0)"/>
    <rect width="10" height="10" transform="translate(.2e2.-2)"/>
    <rect width="10" height="10" transform="translate(.e2-.e2)"/>
</svg>
</file>

<file path="svgnative/test/transform.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,13,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,12,34)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,12,34)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,12,34)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,12,34)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,12,34)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,12,34)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(13,0,0,13,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(12,0,0,34,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(12,0,0,34,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(12,0,0,34,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(12,0,0,34,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(12,0,0,34,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(12,0,0,34,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(0.707,0.707,-0.707,0.707,63,-2.07)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,1,0,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,1,0,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,1,0,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,1,0,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,1,0,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,1,0,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,1,1,0,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,2,3,4,5,6)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1.41,1.41,-1.41,1.41,100,35.1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1.41,1.41,-1.41,1.41,100,35.1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1.41,1.41,-1.41,1.41,100,35.1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,40,40)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,-0.2,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,-2e+19,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,-20,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,-0.002,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,0.2,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,2e+19,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,20,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,0.002,0)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,200,0.2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,20,-0.2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10) transform: matrix(1,0,0,1,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,10,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/tests/bound-tests-svgs/arcs.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 300,100 a 200 100 0 0 0 0,200 Z" fill="blue"/>
  <path d="M 600,250 a 100 200 0 0 1 200,0 Z" fill="blue"/>
  <path d="M 750,700 a 200 100 0 0 1 0,200 Z" fill="blue"/>
  <path d="M 200,750 a 100 200 0 0 0 200,0 Z" fill="blue"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/audi-clipping.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <clipPath id="clip">
    <path d="M 100,500 a 200 200 0 0 1 400,0 a 200 200 0 0 1 -400,0 M 300,500 a 200 200 0 0 1 400,0 a 200 200 0 0 1 -400,0 M 500,500 a 200 200 0 0 1 400,0 a 200 200 0 0 1 -400,0" clip-rule="evenodd" />
  </clipPath>
  <rect x="10" y="10" width="900" height="900" fill="red" clip-path="url(#clip)"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/audi.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,500 a 200 200 0 0 1 400,0 a 200 200 0 0 1 -400,0 M 300,500 a 200 200 0 0 1 400,0 a 200 200 0 0 1 -400,0 M 500,500 a 200 200 0 0 1 400,0 a 200 200 0 0 1 -400,0" fill="blue" fill-rule="evenodd"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/clipping.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <clipPath id="clip">
    <circle cx="300" cy="300" r="300" fill="blue" />
  </clipPath>
  <g transform="translate(100 100)">
    <g clip-path="url(#clip)">
      <g transform="translate(100 100)">
        <rect x="300" y="300" width="400" height="400" fill="red" />
      </g>
    </g>
  </g>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/curves.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 700,100 c 300,0 300,300 0,300 z" />
  <path d="M 300,100 q -200,200 0,400 z" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/dot.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100.100" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/ellipses-combined.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <ellipse cx="200" cy="200" rx="100" ry="50" fill="red" />
  <ellipse cx="800" cy="200" rx="50" ry="100" fill="red" />
  <ellipse cx="800" cy="700" rx="50" ry="100" fill="red" transform="rotate(-45 800,700)" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/fill-rule.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,100 h 400 v -70 h 70 v 70 h -70 v -70 h 70 v 70 h -70 v 400 h -400 Z" fill-rule="evenodd" />
  <path d="M 100,510 h 400 v 400 h -400 v 70 h -70 v -70 h 70 v 70 h -70 v -70 h 70 Z" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/images.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink" viewBox="0 0 1000 1000" width="1000" height="1000">
    <image id="imagejpeg" xlink:href="data:image/png;base64,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" height="300" width="500" x="100" y="100"/>
  <use xlink:href="#imagejpeg" transform="translate(500, 500) rotate(-45) translate(-250, -250)" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/line.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <line x1="100" y1="100" x2="500" y2="500" stroke-width="30" stroke="blue" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/polygon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <polygon points="100,100 800,100 800,800 100,800" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/polyline.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <polyline points="100,100 800,100 800,800 100,800" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/rectangle-rounded-rotated-circle.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <rect x="200" y="200" width="600" height="600" transform="rotate(45 500,500)" rx="100" ry="100"  fill="blue"/>
  <circle cx="500" cy="850" r="100" fill="red" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/rectangles-combined-viewbox.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 1000 1000 1000">
  <g id="group1">
    <rect x="10" y="10" width="100" height="100" fill="red" />
  </g>
  <g id="group2">
    <rect x="400" y="10" width="100" height="100" fill="blue" />
  </g>
  <g id="group3">
    <rect x="400" y="400" width="100" height="100" rx="40" ry="40" fill="green" />
  </g>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/rectangles-combined.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <g id="group1">
    <rect x="10" y="10" width="100" height="100" fill="red" />
  </g>
  <g id="group2">
    <rect x="400" y="10" width="100" height="100" fill="blue" />
  </g>
  <g id="group3">
    <rect x="400" y="400" width="100" height="100" rx="40" ry="40" fill="green" />
  </g>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/stroke-caps.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,100 h 300" stroke="red" stroke-width="50" stroke-linecap="round" />
  <path d="M 600,50 v 500" stroke="red" stroke-width="50" stroke-linecap="butt" />
  <path d="M 100,800 h 300" stroke="red" stroke-width="50" stroke-linecap="square" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/stroke-linejoin-bevel.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,500 l 400,-300 l 400,300 l -400,300 Z" fill="none" stroke-width="100" stroke="red" stroke-linejoin="bevel"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/stroke-linejoin-miter-over.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,500 l 400,-90 l 400,90 l -400,90 Z" fill="none" stroke-width="20" stroke="red" stroke-linejoin="miter" stroke-miterlimit="2"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/stroke-linejoin-miter.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,500 l 400,-90 l 400,90 l -400,90 Z" fill="none" stroke-width="20" stroke="red" stroke-linejoin="miter" stroke-miterlimit="10"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/stroke-linejoin-round.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 100,500 l 400,-300 l 400,300 l -400,300 Z" fill="none" stroke-width="100" stroke="red" stroke-linejoin="round"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/transform-concat.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" viewBox=" 0 0 1000 1000">
  <rect x="500" y="500" width="100" height="100" fill="red" id="myCircle" />
  <rect x="500" y="500" width="100" height="100" fill="blue" id="myCircle2" />
  <use xlink:href="#myCircle" x="0" y="0" transform="rotate(-45 0 0)" />
  <use xlink:href="#myCircle2" x="100" y="0" transform="rotate(-45 0 0)" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/transforms.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <path d="M 300,100 a 400 400 0 0 0 0,400 Z" transform="skewX(20) rotate(45 500,500) scale(1.4 1.4)" fill="blue"/>
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/use.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink" viewBox="0 0 1000 1000">
  <rect x="100" y="100" width="200" height="200" id="rct" />
  <use xlink:href="#rct" x="400" y="400" />
</svg>
</file>

<file path="svgnative/tests/bound-tests-svgs/zero-stroke.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <rect x="200" y="200" width="600" height="600" fill="blue" stroke="red" stroke-width="0" />
</svg>
</file>

<file path="svgnative/tests/librsvg-bounds-generator/.gitignore">
build
</file>

<file path="svgnative/tests/librsvg-bounds-generator/Makefile">
LIBRSVG_INCLUDES = $(shell pkg-config librsvg-2.0 --cflags)
LIBRSVG_LIBS = $(shell pkg-config librsvg-2.0 --libs)
all: mk_folder
	g++ -ggdb -O0 script.cpp -o build/script $(LIBRSVG_INCLUDES) $(LIBRSVG_LIBS)
mk_folder:
	mkdir -p build
</file>

<file path="svgnative/tests/librsvg-bounds-generator/script.cpp">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include <iostream>
#include <iomanip>
#include <fstream>
#include <vector>
#include <tuple>
#include <string>

#include <librsvg/rsvg.h>
#include <cairo.h>

int main(void)
{
    std::fstream filenames_file;
    filenames_file.open("../svg-filenames.txt", std::ios::in);
    if (!filenames_file)
    {
        std::cout << "Couldn't open the file with all svg filenames" << std::endl;
        return -1;
    }
    std::vector<std::string> filenames;
    std::string filename;
    while(std::getline(filenames_file, filename))
    {
        if (filename != "")
            filenames.push_back(filename);
    }
    filenames_file.close();

    std::vector<std::tuple<float, float, float, float>> bounds;
    for(auto const& line: filenames)
    {
        bool bounds_of_group = false;
        auto loc = line.find_first_of(",");
        std::string file_name = line;
        std::string id;
        if (loc != std::string::npos)
        {
            file_name = line.substr(0, loc);
            id = line.substr(loc + 1, std::string::npos);
            bounds_of_group = true;
        }

        GError *error = NULL;
        RsvgHandle *handle = rsvg_handle_new_from_file(("../bound-tests-svgs/" + file_name).c_str(), &error);
        if (error)
        {
            std::cout << "Trouble opening the SVG document in librsvg" << std::endl;
            std::cout << error->message << std::endl;
            return -1;
        }
        cairo_surface_t *surface = cairo_recording_surface_create(CAIRO_CONTENT_COLOR_ALPHA, NULL);
        cairo_t *ct = cairo_create(surface);
        if (bounds_of_group)
            rsvg_handle_render_cairo_sub(handle, ct, id.c_str());
        else
            rsvg_handle_render_cairo(handle, ct);
        cairo_surface_flush(surface);
        double x, y, width, height;
        cairo_recording_surface_ink_extents(surface, &x, &y, &width, &height);
        cairo_destroy(ct);
        cairo_surface_destroy(surface);
        if (error)
        {
            std::cout << "Couldn't compute the bounds" << std::endl;
            return -1;
        }
        auto tup = std::tuple<float, float, float, float>(x, y, width, height);
        bounds.push_back(tup);
        g_object_unref(handle);
    }
    std::fstream bounds_file;
    bounds_file.open("../svg-bounds.txt", std::ios::out);
    if (!bounds_file)
    {
        std::cout << "Couldn't open the file to write the bounds to" << std::endl;
        return -1;
    }
    for(auto const& bound: bounds)
    {
        bounds_file << std::setprecision(15) << std::get<0>(bound) << "," << std::get<1>(bound) << "," << std::get<2>(bound) << "," << std::get<3>(bound) << std::endl;
    }
    bounds_file.close();
    return 0;
}
</file>

<file path="svgnative/tests/librsvg-bounds-generator/script.h">
#include<iostream>
#include<iomanip>
#include<fstream>
#include<vector>
#include<tuple>
#include<string>
#include<librsvg/rsvg.h>
#include<cairo.h>
int main(void){std::fstream filenames_file;filenames_file.open("../svg-filenames.txt",std::ios::in);if(!filenames_file){std::cout<<"Couldn't open the file with all svg filenames"<<std::endl;return-1;}std::vector<std::string>filenames;std::string filename;while(std::getline(filenames_file,filename)){if(filename!="")filenames.push_back(filename);}filenames_file.close();std::vector<std::tuple<float,float,float,float>>bounds;for(auto const&line:filenames){bool bounds_of_group=false;auto loc=line.find_first_of(",");std::string file_name=line;std::string id;if(loc!=std::string::npos){file_name=line.substr(0,loc);id=line.substr(loc+1,std::string::npos);bounds_of_group=true;}GError*error=NULL;RsvgHandle*handle=rsvg_handle_new_from_file(("../bound-tests-svgs/"+file_name).c_str(),&error);if(error){std::cout<<"Trouble opening the SVG document in librsvg"<<std::endl;std::cout<<error->message<<std::endl;return-1;}cairo_surface_t*surface=cairo_recording_surface_create(CAIRO_CONTENT_COLOR_ALPHA,NULL);cairo_t*ct=cairo_create(surface);if(bounds_of_group)rsvg_handle_render_cairo_sub(handle,ct,id.c_str());else rsvg_handle_render_cairo(handle,ct);cairo_surface_flush(surface);double x,y,width,height;cairo_recording_surface_ink_extents(surface,&x,&y,&width,&height);cairo_destroy(ct);cairo_surface_destroy(surface);if(error){std::cout<<"Couldn't compute the bounds"<<std::endl;return-1;}auto tup=std::tuple<float,float,float,float>(x,y,width,height);bounds.push_back(tup);g_object_unref(handle);}std::fstream bounds_file;bounds_file.open("../svg-bounds.txt",std::ios::out);if(!bounds_file){std::cout<<"Couldn't open the file to write the bounds to"<<std::endl;return-1;}for(auto const&bound:bounds){bounds_file<<std::setprecision(15)<<std::get<0>(bound)<<","<<std::get<1>(bound)<<","<<std::get<2>(bound)<<","<<std::get<3>(bound)<<std::endl;}bounds_file.close();return 0;}
</file>

<file path="svgnative/tests/bounds-tests.cpp">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include <fstream>
#include <iostream>
#include <tuple>
#include <vector>
#include <cstdlib>
#include <cmath>

#include "gtest/gtest.h"
#include "gtest/gtest-spi.h"

#include <include/core/SkImage.h>
#include <include/core/SkPictureRecorder.h>
#include <include/core/SkSurface.h>

#include <svgnative/SVGRenderer.h>
#include <svgnative/SVGDocument.h>
#include <svgnative/ports/skia/SkiaSVGRenderer.h>

using namespace SVGNative;

TEST(bounds_tests, bounds_basic_test)
{
    auto surface = SkSurface::MakeNull(1000, 1000);
    auto canvas = surface->getCanvas();
    SkiaSVGRenderer renderer;
    renderer.SetSkCanvas(canvas);
    auto path = renderer.CreatePath();
    path->MoveTo(0, 0);
    path->LineTo(10, 10);
    path->LineTo(10, 0);
    path->ClosePath();
    Rect bounds = renderer.GetBounds(*path.get(), GraphicStyle{}, FillStyle{}, StrokeStyle{});
    EXPECT_EQ(bounds.x, 0);
    EXPECT_EQ(bounds.y, 0);
    EXPECT_EQ(bounds.width, 10);
    EXPECT_EQ(bounds.height, 10);
}

// TODO: Fix these file paths which are relative and dependent
// on the install location. Right now we assume it's build/**/
TEST(bounds_tests, bounds_functional_test)
{
    // get the surface and the canvas
    auto surface = SkSurface::MakeNull(1000, 1000);
    auto canvas = surface->getCanvas();
    auto renderer = std::make_shared<SVGNative::SkiaSVGRenderer>();
    renderer->SetSkCanvas(canvas);

    // load the filenames file
    std::fstream filenames_file;
    std::fstream bounds_file;
    filenames_file.open("../../tests/svg-filenames.txt");
    bounds_file.open("../../tests/svg-bounds.txt");
    if (!filenames_file || !bounds_file)
    {
        std::cout << "Error! Could not open input file." << std::endl;
        FAIL();
    }
    std::string filename;
    std::string bounds_line;
    std::vector<std::tuple<std::string, Rect>> svg_documents_bounds;
    while(std::getline(filenames_file, filename))
    {
        if (filename == "")
            break;
        std::getline(bounds_file, bounds_line);
        float x, y, width, height;
        sscanf(bounds_line.c_str(), "%f,%f,%f,%f", &x, &y, &width, &height);
        svg_documents_bounds.push_back(std::tuple<std::string, Rect>(filename, Rect{x, y, width, height}));
    }
    filenames_file.close();
    bounds_file.close();
    for(auto const& item: svg_documents_bounds)
    {
        std::string line = std::get<0>(item);
        Rect standard_bounds = std::get<1>(item);

        bool bounds_of_group = false;
        auto loc = line.find_first_of(",");
        std::string filename = line;
        std::string id;
        if (loc != std::string::npos)
        {
            filename = line.substr(0, loc);
            id = line.substr(loc + 2, std::string::npos);
            bounds_of_group = true;
        }

        std::string full_file_path = "../../tests/bound-tests-svgs/" + filename;
        std::string svgInput{};
        std::ifstream input(full_file_path);
        if (!input)
        {
            std::cout << "Error! Could not open input file." << std::endl;
            FAIL();
        }
        for (std::string line; std::getline(input, line);)
            svgInput.append(line);
        input.close();
        auto doc = std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(), renderer));
        Rect bounds;
        if (bounds_of_group)
            doc->GetBoundingBox(id.c_str(), bounds);
        else
            doc->GetBoundingBox(bounds);
        EXPECT_EQ((bounds.IsEmpty() && !standard_bounds.IsEmpty()) ||
                  (!bounds.IsEmpty() && standard_bounds.IsEmpty()), false);
        if (bounds.IsEmpty() && standard_bounds.IsEmpty())
        {
            printf("\033[32m%s, PASS because both empty \033[0m\n", filename.c_str());
            continue;
        }
        float diff = bounds.MaxDiffVertex(standard_bounds);
        //printf("diff: %f\n", diff);
        diff = diff / (std::max(standard_bounds.width, standard_bounds.height));
        if (diff < 0.1)
        {
            printf("\033[32m%s, %f, PASS\033[0m\n", line.c_str(), diff);
        }
        else
        {
            const int buffer = 2;
            bounds.x -= buffer;
            bounds.y -= buffer;
            bounds.width += buffer * 2;
            bounds.height += buffer * 2;
            if (bounds.Contains(standard_bounds))
            {
                printf("\033[35m%s, %f, PASS BECAUSE CONTAINS!\033[0m\n", line.c_str(), diff);
            }
            else
            {
                printf("\033[31m%s, %f, FAIL\033[0m\n", line.c_str(), diff);
                printf("standard: %f %f %f %f\n", standard_bounds.x, standard_bounds.y, standard_bounds.width, standard_bounds.height);
                printf("calculated: %f %f %f %f\n", bounds.x, bounds.y, bounds.width, bounds.height);
                FAIL();
            }
        }
    }
}
</file>

<file path="svgnative/tests/bounds-tests.h">
#ifndef HEADER_FILE_H
#define HEADER_FILE_H
#include<fstream>
#include<iostream>
#include<tuple>
#include<vector>
#include<cstdlib>
#include<cmath>
#include "gtest/gtest.h"
#include "gtest/gtest-spi.h"
#include<include/core/SkImage.h>
#include<include/core/SkPictureRecorder.h>
#include<include/core/SkSurface.h>
#include<svgnative/SVGRenderer.h>
#include<svgnative/SVGDocument.h>
#include<svgnative/ports/skia/SkiaSVGRenderer.h>
using namespace SVGNative;TEST(bounds_tests,bounds_basic_test){auto surface=SkSurface::MakeNull(1000,1000);auto canvas=surface->getCanvas();SkiaSVGRenderer renderer;renderer.SetSkCanvas(canvas);auto path=renderer.CreatePath();path->MoveTo(0,0);path->LineTo(10,10);path->LineTo(10,0);path->ClosePath();Rect bounds=renderer.GetBounds(*path.get(),GraphicStyle{},FillStyle{},StrokeStyle{});EXPECT_EQ(bounds.x,0);EXPECT_EQ(bounds.y,0);EXPECT_EQ(bounds.width,10);EXPECT_EQ(bounds.height,10);}TEST(bounds_tests,bounds_functional_test){auto surface=SkSurface::MakeNull(1000,1000);auto canvas=surface->getCanvas();auto renderer=std::make_shared<SVGNative::SkiaSVGRenderer>();renderer->SetSkCanvas(canvas);std::fstream filenames_file;std::fstream bounds_file;filenames_file.open("../../tests/svg-filenames.txt");bounds_file.open("../../tests/svg-bounds.txt");if(!filenames_file||!bounds_file){std::cout<<"Error!Could not open input file."<<std::endl;FAIL();}std::string filename;std::string bounds_line;std::vector<std::tuple<std::string,Rect>>svg_documents_bounds;while(std::getline(filenames_file,filename)){if(filename=="")break;std::getline(bounds_file,bounds_line);float x,y,width,height;sscanf(bounds_line.c_str(),"%f,%f,%f,%f",&x,&y,&width,&height);svg_documents_bounds.push_back(std::tuple<std::string,Rect>(filename,Rect{x,y,width,height}));}filenames_file.close();bounds_file.close();for(auto const&item:svg_documents_bounds){std::string line=std::get<0>(item);Rect standard_bounds=std::get<1>(item);bool bounds_of_group=false;auto loc=line.find_first_of(",");std::string filename=line;std::string id;if(loc!=std::string::npos){filename=line.substr(0,loc);id=line.substr(loc+2,std::string::npos);bounds_of_group=true;}std::string full_file_path="../../tests/bound-tests-svgs/"+filename;std::string svgInput{};std::ifstream input(full_file_path);if(!input){std::cout<<"Error!Could not open input file."<<std::endl;FAIL();}for(std::string line;std::getline(input,line);)svgInput.append(line);input.close();auto doc=std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(),renderer));Rect bounds;if(bounds_of_group)doc->GetBoundingBox(id.c_str(),bounds);else doc->GetBoundingBox(bounds);EXPECT_EQ((bounds.IsEmpty()&&!standard_bounds.IsEmpty())||(!bounds.IsEmpty()&&standard_bounds.IsEmpty()),false);if(bounds.IsEmpty()&&standard_bounds.IsEmpty()){printf("\033[32m%s,PASS because both empty \033[0m\n",filename.c_str());continue;}float diff=bounds.MaxDiffVertex(standard_bounds);diff=diff/(std::max(standard_bounds.width,standard_bounds.height));if(diff<0.1){printf("\033[32m%s,%f,PASS\033[0m\n",line.c_str(),diff);}else{const int buffer=2;bounds.x-=buffer;bounds.y-=buffer;bounds.width+=buffer*2;bounds.height+=buffer*2;if(bounds.Contains(standard_bounds)){printf("\033[35m%s,%f,PASS BECAUSE CONTAINS!\033[0m\n",line.c_str(),diff);}else{printf("\033[31m%s,%f,FAIL\033[0m\n",line.c_str(),diff);printf("standard:%f%f%f%f\n",standard_bounds.x,standard_bounds.y,standard_bounds.width,standard_bounds.height);printf("calculated:%f%f%f%f\n",bounds.x,bounds.y,bounds.width,bounds.height);FAIL();}}}}
#endif
</file>

<file path="svgnative/tests/CMakeLists.txt">
set (SOURCE_FILES
	${CMAKE_CURRENT_SOURCE_DIR}/../src/Interval.cpp
	${CMAKE_CURRENT_SOURCE_DIR}/../src/Interval.h
)
add_executable(intervalTests interval-tests.cpp ${SOURCE_FILES})
target_include_directories(intervalTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../src")
target_link_libraries(intervalTests SVGNativeViewerLib)
target_link_libraries(intervalTests gtest_main)
add_test(NAME interval_tests COMMAND intervalTests)

set (SOURCE_FILES
	${CMAKE_CURRENT_SOURCE_DIR}/../src/Interval.cpp	
	${CMAKE_CURRENT_SOURCE_DIR}/../src/Rect.cpp
)
add_executable(rectangleTests rectangle-tests.cpp ${SOURCE_FILES})
target_include_directories(rectangleTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../src")
target_link_libraries(rectangleTests SVGNativeViewerLib)
target_link_libraries(rectangleTests gtest_main)
add_test(NAME rectangle_tests COMMAND rectangleTests)


# TODO: For now we just use the Skia port, but later on we should
# extend this and generalize this so that all the ports are equally
# tested. We'd need some mechanism to plug in different renderer
# implementations for different ports and do the tests for all those
# that are available
if (USE_SKIA)
    add_executable(boundsTests bounds-tests.cpp)
    target_link_libraries(boundsTests SVGNativeViewerLib)
    target_link_libraries(boundsTests gtest_main)
    add_test(NAME bounds_tests COMMAND boundsTests)

    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/stylesheet/include")
    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/skia/include/config")
    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/skia/include/core")
    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/skia/include/effects")
    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/skia/include/encode")
    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/skia/include/gpu")
    target_include_directories(boundsTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../ports/skia")
    target_link_libraries(boundsTests SVGNativeViewerLib "${SKIA_LIBRARY_PATH}")
endif()
</file>

<file path="svgnative/tests/interval-tests.cpp">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "gtest/gtest.h"

#include <svgnative/SVGRenderer.h>
#include "Interval.h"

using namespace SVGNative;

TEST(interval_tests, interval_empty_test)
{
    Interval interval;
    EXPECT_EQ(interval.IsEmpty(), true);
}

TEST(interval_tests, interval_single_number_test)
{
    Interval interval(3.5);
    EXPECT_EQ(interval.IsEmpty(), true);
    EXPECT_EQ(interval.Min(), 3.5);
    EXPECT_EQ(interval.Max(), 3.5);
}

TEST(interval_tests, interval_two_numbers_test)
{
    Interval interval(3.5, 4.5);
    EXPECT_EQ(interval.IsEmpty(), false);
    EXPECT_EQ(interval.Min(), 3.5);
    EXPECT_EQ(interval.Max(), 4.5);
}

TEST(intervals_test, interval_two_opp_order_test)
{
    Interval interval(5.5, 2.5);
    EXPECT_EQ(interval.IsEmpty(), false);
    EXPECT_EQ(interval.Min(), 2.5);
    EXPECT_EQ(interval.Max(), 5.5);
}

TEST(intervals_test, interval_intersection)
{
    {
        Interval a(1.5, 2.5);
        Interval b(2, 3.5);

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), false);
        EXPECT_EQ(intersection.Min(), 2);
        EXPECT_EQ(intersection.Max(), 2.5);
    }
    {
        Interval a(1.5, 2.5);
        Interval b(3, 3.5);

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), true);
    }
    {
        Interval a(1.5, 2.5);
        Interval b(2.5, 3.5);

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), true);
    }
    {
        Interval a(1.5, 2.5);
        Interval b;

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), true);
    }
    {
        Interval a;
        Interval b(1, 2);

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), true);
    }
    {
        Interval a;
        Interval b;

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), true);
    }
    {
        Interval a(1, 1);
        Interval b(1, 1);

        Interval intersection = a & b;
        EXPECT_EQ(intersection.IsEmpty(), true);
    }
}

TEST(intervals_test, interval_join)
{
    {
        Interval a(1.5, 2.5);
        Interval b(2, 3);

        Interval join = a | b;
        EXPECT_EQ(join.IsEmpty(), false);
        EXPECT_EQ(join.Min(), 1.5);
        EXPECT_EQ(join.Max(), 3);
    }
    {
        Interval a(5.5, 2.5);
        Interval b(2, 3);

        Interval join = a | b;
        EXPECT_EQ(join.IsEmpty(), false);
        EXPECT_EQ(join.Min(), 2);
        EXPECT_EQ(join.Max(), 5.5);
    }
    {
        Interval a(5.5, 5.5);
        Interval b(2, 3);

        Interval join = a | b;
        EXPECT_EQ(join.IsEmpty(), false);
        EXPECT_EQ(join.Min(), 2);
        EXPECT_EQ(join.Max(), 3);
    }
    {
        Interval a(2, 3);
        Interval b(5.5, 5.5);

        Interval join = a | b;
        EXPECT_EQ(join.IsEmpty(), false);
        EXPECT_EQ(join.Min(), 2);
        EXPECT_EQ(join.Max(), 3);
    }
    {
        Interval a(2, 2);
        Interval b(5.5, 5.5);

        Interval join = a | b;
        EXPECT_EQ(join.IsEmpty(), true);
    }
    {
        Interval a;
        Interval b;

        Interval join = a | b;
        EXPECT_EQ(join.IsEmpty(), true);
    }
}

TEST(intervals_test, interval_contain_test)
{
    {
        Interval a(1, 2);
        Interval b(1.5, 2.5);

        EXPECT_EQ(a.Contains(b), false);
    }
    {
        Interval a(1, 2);
        Interval b(0.5, 2.5);

        EXPECT_EQ(a.Contains(b), false);
        EXPECT_EQ(b.Contains(a), true);
    }
    {
        Interval a(0.5, 2.5);
        Interval b(0.5, 2.5);

        EXPECT_EQ(a.Contains(b), true);
        EXPECT_EQ(b.Contains(a), true);
    }
    {
        Interval a(0.5, 0.5);
        Interval b(0.5, 2.5);

        EXPECT_EQ(a.Contains(b), false);
        EXPECT_EQ(b.Contains(a), true);
    }
    {
        Interval a(0, 0);
        Interval b(0.5, 2.5);

        EXPECT_EQ(a.Contains(b), false);
        EXPECT_EQ(b.Contains(a), true);
    }
    {
        Interval a(1, 1);
        Interval b(0.5, 2.5);

        EXPECT_EQ(a.Contains(b), false);
        EXPECT_EQ(b.Contains(a), true);
    }
    {
        Interval a(1, 1);
        Interval b(0.5, 0.5);

        EXPECT_EQ(a.Contains(b), true);
        EXPECT_EQ(b.Contains(a), true);
    }
}
</file>

<file path="svgnative/tests/interval-tests.h">
#include "gtest/gtest.h"
#include<svgnative/SVGRenderer.h>
#include "Interval.h"
using namespace SVGNative;TEST(interval_tests,interval_empty_test){Interval interval;EXPECT_EQ(interval.IsEmpty(),true);}TEST(interval_tests,interval_single_number_test){Interval interval(3.5);EXPECT_EQ(interval.IsEmpty(),true);EXPECT_EQ(interval.Min(),3.5);EXPECT_EQ(interval.Max(),3.5);}TEST(interval_tests,interval_two_numbers_test){Interval interval(3.5,4.5);EXPECT_EQ(interval.IsEmpty(),false);EXPECT_EQ(interval.Min(),3.5);EXPECT_EQ(interval.Max(),4.5);}TEST(intervals_test,interval_two_opp_order_test){Interval interval(5.5,2.5);EXPECT_EQ(interval.IsEmpty(),false);EXPECT_EQ(interval.Min(),2.5);EXPECT_EQ(interval.Max(),5.5);}TEST(intervals_test,interval_intersection){{Interval a(1.5,2.5);Interval b(2,3.5);Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),false);EXPECT_EQ(intersection.Min(),2);EXPECT_EQ(intersection.Max(),2.5);}{Interval a(1.5,2.5);Interval b(3,3.5);Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),true);}{Interval a(1.5,2.5);Interval b(2.5,3.5);Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),true);}{Interval a(1.5,2.5);Interval b;Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),true);}{Interval a;Interval b(1,2);Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),true);}{Interval a;Interval b;Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),true);}{Interval a(1,1);Interval b(1,1);Interval intersection=a&b;EXPECT_EQ(intersection.IsEmpty(),true);}}TEST(intervals_test,interval_join){{Interval a(1.5,2.5);Interval b(2,3);Interval join=a|b;EXPECT_EQ(join.IsEmpty(),false);EXPECT_EQ(join.Min(),1.5);EXPECT_EQ(join.Max(),3);}{Interval a(5.5,2.5);Interval b(2,3);Interval join=a|b;EXPECT_EQ(join.IsEmpty(),false);EXPECT_EQ(join.Min(),2);EXPECT_EQ(join.Max(),5.5);}{Interval a(5.5,5.5);Interval b(2,3);Interval join=a|b;EXPECT_EQ(join.IsEmpty(),false);EXPECT_EQ(join.Min(),2);EXPECT_EQ(join.Max(),3);}{Interval a(2,3);Interval b(5.5,5.5);Interval join=a|b;EXPECT_EQ(join.IsEmpty(),false);EXPECT_EQ(join.Min(),2);EXPECT_EQ(join.Max(),3);}{Interval a(2,2);Interval b(5.5,5.5);Interval join=a|b;EXPECT_EQ(join.IsEmpty(),true);}{Interval a;Interval b;Interval join=a|b;EXPECT_EQ(join.IsEmpty(),true);}}TEST(intervals_test,interval_contain_test){{Interval a(1,2);Interval b(1.5,2.5);EXPECT_EQ(a.Contains(b),false);}{Interval a(1,2);Interval b(0.5,2.5);EXPECT_EQ(a.Contains(b),false);EXPECT_EQ(b.Contains(a),true);}{Interval a(0.5,2.5);Interval b(0.5,2.5);EXPECT_EQ(a.Contains(b),true);EXPECT_EQ(b.Contains(a),true);}{Interval a(0.5,0.5);Interval b(0.5,2.5);EXPECT_EQ(a.Contains(b),false);EXPECT_EQ(b.Contains(a),true);}{Interval a(0,0);Interval b(0.5,2.5);EXPECT_EQ(a.Contains(b),false);EXPECT_EQ(b.Contains(a),true);}{Interval a(1,1);Interval b(0.5,2.5);EXPECT_EQ(a.Contains(b),false);EXPECT_EQ(b.Contains(a),true);}{Interval a(1,1);Interval b(0.5,0.5);EXPECT_EQ(a.Contains(b),true);EXPECT_EQ(b.Contains(a),true);}}
</file>

<file path="svgnative/tests/rectangle-tests.cpp">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "gtest/gtest.h"
#include "gtest/gtest-spi.h"

#include <svgnative/SVGRenderer.h>

using namespace SVGNative;

TEST(rectangle_tests, rectangle_empty_test)
{
    Rect rect(0, 0, 0, 0);
    EXPECT_EQ(rect.IsEmpty(), true);
}

TEST(rectangle_tests, rectangle_invalid_dimensions_test)
{
    try {
        Rect rect(1, 2, 4, -6);
        FAIL();
    } catch(std::invalid_argument &excepted) {}
}

TEST(rectangle_tests, rectangle_regular_test)
{
    Rect rect(1, 2, 4, 6);
    EXPECT_EQ(rect.IsEmpty(), false);
    EXPECT_EQ(rect.x, 1);
    EXPECT_EQ(rect.y, 2);
    EXPECT_EQ(rect.width, 4);
    EXPECT_EQ(rect.height, 6);
}

TEST(rectangle_tests, rectangle_equality_test)
{
    Rect rect1(1, 2, 4, 6);
    Rect rect2(1, 2, 4, 6);
    Rect rect3(2, 2, 4, 6);
    EXPECT_EQ(rect1 == rect2, true);
    EXPECT_EQ(rect2 == rect3, false);
    EXPECT_EQ(rect2 == rect1, true);
    EXPECT_EQ(rect1 == rect3, false);
}

TEST(rectangle_tests, rectangle_Contains_test)
{
    Rect rect1(1, 2, 4, 6);
    Rect rect2(2, 3, 2, 2);
    EXPECT_EQ(rect1.Contains(rect2), true);
    EXPECT_EQ(rect2.Contains(rect1), false);
}

TEST(rectangle_tests, rectangle_Contains_self_test)
{
    Rect rect1(1, 2, 4, 6);
    EXPECT_EQ(rect1.Contains(rect1), true);
}

TEST(rectangle_tests, rectangle_intersection_test)
{
    Rect rect1(1, 2, 4, 6);
    Rect rect2(2, 3, 2, 2);
    Rect rect3(0, 0, 10, 10);
    Rect rect4(-10, -10, 5, 5);
    Rect rect5(-8, -8, 5, 5);
    EXPECT_EQ((Rect{0, 0, 0, 0} & Rect{0, 0, 0, 0}).IsEmpty(), true);
    EXPECT_EQ((Rect(1, 1, 10, 10) & Rect{0, 0, 0, 0}).IsEmpty(), true);
    EXPECT_EQ((Rect{0, 0, 0, 0} & Rect(1, 1, 10, 10)).IsEmpty(), true);
    EXPECT_EQ((Rect(1, 1, 10, 10) & Rect(1, 1, 10, 10)).IsEmpty(), false);
    EXPECT_EQ((Rect(1, 1, 10, 10) & Rect(1, 1, 10, 10)) == Rect(1, 1, 10, 10), true);
    EXPECT_EQ((rect1 & rect2).IsEmpty(), false);
    EXPECT_EQ((rect1 & rect2) == rect2, true);
    EXPECT_EQ((rect1 & rect3).IsEmpty(), false);
    EXPECT_EQ((rect1 & rect3) == rect1, true);
    EXPECT_EQ((rect3 & rect4).IsEmpty(), true);
    Rect result = rect4 & rect5;
    EXPECT_EQ(result.IsEmpty(), false);
    EXPECT_EQ(result.x, -8);
    EXPECT_EQ(result.y, -8);
    EXPECT_EQ(result.width, 3);
    EXPECT_EQ(result.height, 3);
    EXPECT_EQ((result & result) == result, true);
}

TEST(rectangle_tests, rectangle_join_test)
{
    Rect rect1(1, 1, 4, 4);
    Rect rect2(5, 5, 4, 4);
    Rect result = rect1 | rect2;
    EXPECT_EQ(result.IsEmpty(), false);
    EXPECT_EQ(result.x, 1);
    EXPECT_EQ(result.y, 1);
    EXPECT_EQ(result.width, 8);
    EXPECT_EQ(result.height, 8);
    EXPECT_EQ((Rect{0, 0, 0, 0} | Rect{0, 0, 0, 0}).IsEmpty(), true);
    EXPECT_EQ((rect1 | rect1) == rect1, true);
    EXPECT_EQ((rect1 | Rect{0, 0, 0, 0}) == rect1, true);
    EXPECT_EQ((rect2 | Rect{0, 0, 0, 0}) == rect2, true);
}

TEST(rectangle_tests, rectangle_side_tests)
{
    Rect rect(1, 2, 4, 6);
    EXPECT_EQ(rect.Area(), 24.0);
    EXPECT_EQ(rect.Left(), 1);
    EXPECT_EQ(rect.Top(), 2);
    EXPECT_EQ(rect.Right(), 5);
    EXPECT_EQ(rect.Bottom(), 8);
}
</file>

<file path="svgnative/tests/rectangle-tests.h">
#include "gtest/gtest.h"
#include "gtest/gtest-spi.h"
#include<svgnative/SVGRenderer.h>
using namespace SVGNative;TEST(rectangle_tests,rectangle_empty_test){Rect rect(0,0,0,0);EXPECT_EQ(rect.IsEmpty(),true);}TEST(rectangle_tests,rectangle_invalid_dimensions_test){try{Rect rect(1,2,4,-6);FAIL();}catch(std::invalid_argument&excepted){}}TEST(rectangle_tests,rectangle_regular_test){Rect rect(1,2,4,6);EXPECT_EQ(rect.IsEmpty(),false);EXPECT_EQ(rect.x,1);EXPECT_EQ(rect.y,2);EXPECT_EQ(rect.width,4);EXPECT_EQ(rect.height,6);}TEST(rectangle_tests,rectangle_equality_test){Rect rect1(1,2,4,6);Rect rect2(1,2,4,6);Rect rect3(2,2,4,6);EXPECT_EQ(rect1==rect2,true);EXPECT_EQ(rect2==rect3,false);EXPECT_EQ(rect2==rect1,true);EXPECT_EQ(rect1==rect3,false);}TEST(rectangle_tests,rectangle_Contains_test){Rect rect1(1,2,4,6);Rect rect2(2,3,2,2);EXPECT_EQ(rect1.Contains(rect2),true);EXPECT_EQ(rect2.Contains(rect1),false);}TEST(rectangle_tests,rectangle_Contains_self_test){Rect rect1(1,2,4,6);EXPECT_EQ(rect1.Contains(rect1),true);}TEST(rectangle_tests,rectangle_intersection_test){Rect rect1(1,2,4,6);Rect rect2(2,3,2,2);Rect rect3(0,0,10,10);Rect rect4(-10,-10,5,5);Rect rect5(-8,-8,5,5);EXPECT_EQ((Rect{0,0,0,0}&Rect{0,0,0,0}).IsEmpty(),true);EXPECT_EQ((Rect(1,1,10,10)&Rect{0,0,0,0}).IsEmpty(),true);EXPECT_EQ((Rect{0,0,0,0}&Rect(1,1,10,10)).IsEmpty(),true);EXPECT_EQ((Rect(1,1,10,10)&Rect(1,1,10,10)).IsEmpty(),false);EXPECT_EQ((Rect(1,1,10,10)&Rect(1,1,10,10))==Rect(1,1,10,10),true);EXPECT_EQ((rect1&rect2).IsEmpty(),false);EXPECT_EQ((rect1&rect2)==rect2,true);EXPECT_EQ((rect1&rect3).IsEmpty(),false);EXPECT_EQ((rect1&rect3)==rect1,true);EXPECT_EQ((rect3&rect4).IsEmpty(),true);Rect result=rect4&rect5;EXPECT_EQ(result.IsEmpty(),false);EXPECT_EQ(result.x,-8);EXPECT_EQ(result.y,-8);EXPECT_EQ(result.width,3);EXPECT_EQ(result.height,3);EXPECT_EQ((result&result)==result,true);}TEST(rectangle_tests,rectangle_join_test){Rect rect1(1,1,4,4);Rect rect2(5,5,4,4);Rect result=rect1|rect2;EXPECT_EQ(result.IsEmpty(),false);EXPECT_EQ(result.x,1);EXPECT_EQ(result.y,1);EXPECT_EQ(result.width,8);EXPECT_EQ(result.height,8);EXPECT_EQ((Rect{0,0,0,0}|Rect{0,0,0,0}).IsEmpty(),true);EXPECT_EQ((rect1|rect1)==rect1,true);EXPECT_EQ((rect1|Rect{0,0,0,0})==rect1,true);EXPECT_EQ((rect2|Rect{0,0,0,0})==rect2,true);}TEST(rectangle_tests,rectangle_side_tests){Rect rect(1,2,4,6);EXPECT_EQ(rect.Area(),24.0);EXPECT_EQ(rect.Left(),1);EXPECT_EQ(rect.Top(),2);EXPECT_EQ(rect.Right(),5);EXPECT_EQ(rect.Bottom(),8);}
</file>

<file path="svgnative/tests/svg-bounds.txt">
10,10,490,490
10,-990,490,490
10,10,100,100
400,10,100,100
400,400,100,100
117,117,766,833
100,100,780,680
100,100,700,700
100,100,700,700
200,100,725,400
100,300,800,400
30,30,540,950
89,89,422,422
512,188,255,397
500,-142,420,742
500,500,200,200
100,300,800,400
70,160,860,680
97,399,806,202
54,399,892,202
50,150,900,700
100,100,600,600
275,100,455,489
0,0,0,0
200,200,600,600
100,50,850,900
</file>

<file path="svgnative/tests/svg-filenames.txt">
rectangles-combined.svg
rectangles-combined-viewbox.svg
rectangles-combined.svg,#group1
rectangles-combined.svg,#group2
rectangles-combined.svg,#group3
rectangle-rounded-rotated-circle.svg
ellipses-combined.svg
polyline.svg
polygon.svg
curves.svg
audi.svg
fill-rule.svg
line.svg
transforms.svg
transform-concat.svg
clipping.svg
audi-clipping.svg
stroke-linejoin-bevel.svg
stroke-linejoin-miter-over.svg
stroke-linejoin-miter.svg
stroke-linejoin-round.svg
use.svg
images.svg
dot.svg
zero-stroke.svg

arcs.svg
</file>

<file path="svgnative/SVGNativeViewerLib-uninstalled.pc.in">
prefix=@SOURCE_DIR@
exec_prefix=@BINARY_DIR@
libdir=${exec_prefix}
includedir=${prefix}/include

Name: SVGNativeViewerLib
Description: Parser and renderer for SVG Native documents
Version: @VERSION@
Requires: @REQUIRES@
Requires.private: @PRIVATE_REQUIRES@

Cflags: -I${includedir} @PORTS_INCLUDES@
Libs: -L${libdir} -lSVGNativeViewerLib
Libs.private: @PRIVATE_LIBS@
</file>

<file path="tools/cminify.py">
#!/usr/bin/env python3
#     C Minify Copyright (C) 2015 Alexandre Baron
#     This program comes with ABSOLUTELY NO WARRANTY; for details read LICENSE.
#     This is free software, and you are welcome to redistribute it
#     under certain conditions; read LICENSE for details.

import argparse
import fileinput  # read from STDIN
import re

# Ops: ops that may be spaced out in the code but we can trim the whitespace before and after
# Spaced ops are operators that we need to append with one trailing space because of their syntax (e.g. keywords).
# NB: theses ops are the SUPPORTED ones and these lists may not be complete as per the Standard
OPS = [
    "+",
    "-",
    "*",
    "/",
    "%",
    "++",
    "--",
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "=",
    "==",
    "!=",
    "&&",
    "||",
    "!",
    "&",
    "|",
    "^",
    "<<",
    ">>",
    "<",
    ">",
    "<=",
    ">=",
    "<<=",
    ">>=",
    "&=",
    "|=",
    "^=",
    ",",
    "(",
    ")",
    "{",
    "}",
    ";",
    "else",
    ":",
    "::",
    "?",
]
SPACED_OPS = ["else"]
UNARY_OPS = ["+", "-", "&", "!", "*"]
PREPROCESSOR_TOKEN = "#"


def remove_everything_between(subs1, subs2, line):
    regex = re.compile(subs1 + r".*" + subs2)
    return regex.sub("", line)


def remove_everything_before(subs, line):
    regex = re.compile(r".*" + subs)
    return regex.sub("", line)


def remove_everything_past(subs, line):
    regex = re.compile(subs + r".*")
    return regex.sub("", line)


def remove_multiline_comments(lines):
    start, end = "/*", "*/"
    escaped_start, escaped_end = r"/\*", r"\*/"
    in_comment = False
    newlines = []
    for line in lines:
        if not in_comment:
            start_pos = line.find(start)
            if start_pos != -1:
                in_comment = True
                end_pos = line.find(end)
                # inline multiline comment
                if start_pos < end_pos:
                    line = remove_everything_between(escaped_start, escaped_end, line)
                    in_comment = False
                else:
                    line = remove_everything_past(escaped_start, line)
        else:
            end_pos = line.find(end)
            if end_pos != -1:
                line = remove_everything_before(escaped_end, line)
                in_comment = False
                start_pos = line.find(start)
                # start of another comment on the same line
                if start_pos != -1:
                    line = remove_everything_past(escaped_start, line)
                    in_comment = True
            else:
                line = ""
        newlines.append(line)
    return newlines


def remove_inline_comments(lines):
    return [remove_everything_past("//", x) for x in lines]


def minify_operator(op):
    """Returns a function applying a regex to strip away spaces on each side of an operator
    Makes a special escape for operators that could be mistaken for regex control characters."""
    to_compile = f" *{re.escape(op)} *"
    regex = re.compile(to_compile)
    repl = op
    if op in SPACED_OPS:
        repl += " "
    return lambda string: regex.sub(repl, string)


def fix_spaced_ops(minified_txt):
    """This will walk the spaced ops list and search the text for all "[OP] {" sequences occurrences
    and replace them by "[OP]{" since there is no operator in the C syntax for which the spacing
    between the op and the '{' is mandatory.
    We do this because to manage spaced ops that may or may not be used with braces (e.g. "else"),
    we may have added unnecessary spaces (e.g. because the brace was on next line),
    so we can fix it here."""
    for op in SPACED_OPS:
        pattern = f"{op} {{"  # {{ for literal braces
        repl = f"{op}{{"
        minified_txt = re.sub(pattern, repl, minified_txt)
    return minified_txt


def fix_unary_operators(lines):
    """Ops processing can have eliminated necessary space when using unary ops
    e.g. "#define ABC -1" becomes "#define ABC-1", because the unary '-' is being
    mistaken for a binary '-', so the space has been trimmed.
    We can fix this kind of thing here, but it pretty much highlights the limits of such
    a parser..."""
    regex_unary_ops = "[{}]".format("".join(UNARY_OPS))
    regex_unary_ops = re.escape(regex_unary_ops)
    # Use capture groups to separate, e.g. in "#define MACROVALUE", "#define MACRO" from "VALUE"
    # pattern will detect problems like "#define FLUSH-2"
    # Format braces here -----------v
    pattern = f"^(#[a-z]+ +[\w\d]+)([{regex_unary_ops}][\w\d]+)$"
    # Simply add one more space between macro name and value
    repl = r"\1" + " " + r"\2"
    # Process each preprocessor line and modify it inplace as we need to keep order
    for idx, line in enumerate(lines):
        if is_preprocessor_directive(line):
            for op in UNARY_OPS:
                line = re.sub(pattern, repl, line)
            lines[idx] = line
    return lines


def clear_whitespace_first_pass(lines):
    """Given a list of lines, clears all leading/trailing whitespace"""
    lines = [x.replace("\t", " ") for x in lines]
    # specify only spaces so it doesn't strip newlines
    lines = [x.strip(" ") for x in lines]
    return list(lines)


def reinsert_preprocessor_newlines(lines):
    """Preprocessor directives should stay on their own line even minified
    So bring back a '\n' on lines beginning with '#' AND on lines before them"""
    for idx, line in enumerate(lines):
        if is_preprocessor_directive(line) or (
            idx != len(lines) - 1 and is_preprocessor_directive(lines[idx + 1])
        ):
            lines[idx] = lines[idx] + "\n"
    return lines


def fix_duplicate_newlines(file):
    """Preprocessor directives seperated by newlines can end up with blank lines between them after
    after being joined, search for any occurances of this and replace with a single new line"""
    regex = re.compile("[\n]{2,}")
    return regex.sub("\n", file)


def is_preprocessor_directive(line):
    return line.startswith(PREPROCESSOR_TOKEN)


def minify_source(orig_source, args=None):
    """
    The main function where the minification happens.
    Main steps:
    - split input into lines
    - clear leading/trailing whitespace and add newlines back again to
    preprocessor directives lines
    - minify operators that can be used without spaces
    - fix unary operators that we could have taken for binary operators (e.g. -)
    - re-concatening all lines and final fixes to possible over-spacing
    """
    # Unpacking argument parameters, dealing with the case there are no args
    keep_newlines = getattr(args, "keep_newlines", False)
    keep_multiline_comments = getattr(args, "keep_multiline", False)
    keep_inline_comments = getattr(args, "keep_inline", False)

    lines = orig_source.split("\n")

    # Things to do BEFORE processing spaced ops:
    # - erase leading and trailing whitespace
    # - reinsert newlines on preprocessor directives
    # so they stay on their own line even minified
    lines = clear_whitespace_first_pass(lines)
    if keep_newlines is False:
        lines = reinsert_preprocessor_newlines(lines)

    # for each operator: remove space on each side of the op, on every line.
    # Escape ops that could be regex control characters.
    for op in OPS:
        lines = list(map(minify_operator(op), lines))
    if keep_inline_comments is False:
        lines = remove_inline_comments(lines)
    if keep_multiline_comments is False:
        lines = remove_multiline_comments(lines)
    # Finally convert all remaining multispaces to a single space
    multi_spaces = re.compile(r"[  ]+ *")
    lines = list([multi_spaces.sub(" ", string) for string in lines])
    # Ops processing can have eliminated necessary space when using unary ops
    # e.g. "#define ABC -1" becomes "#define ABC-1", so we can fix it here
    lines = fix_unary_operators(lines)

    minified = ""
    if keep_newlines is True:
        minified = args.newline.join(lines)
    else:
        minified = fix_duplicate_newlines("".join(lines))

    # There is no syntactic requirement of an operator being spaced from a '{' in C so
    # if we added unnecessary space when processing spaced ops, we can fix it here
    minified = fix_spaced_ops(minified)

    return minified


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("files", nargs="+", help="Input files")
    parser.add_argument(
        "-n", "--names", help="Show name of processed files", action="store_true"
    )
    parser.add_argument(
        "-s", "--stats", help="Show statistics on minified version", action="store_true"
    )
    parser.add_argument(
        "-m",
        "--keep-multiline",
        help="Don't strip multiline comments (/* ... */)",
        action="store_true",
    )
    parser.add_argument(
        "-i",
        "--keep-inline",
        help="Do not strip inline comments (// ...)",
        action="store_true",
    )
    parser.add_argument(
        "-w",
        "--keep-newlines",
        help="Keep newline control characters",
        action="store_true",
    )
    args = parser.parse_args()
    return args


def get_minification_delta(source_text, minified_text):
    """Computes how much the code size has been reduced after minification"""
    orig_size = len(source_text)
    mini_size = len(minified_text)
    delta = orig_size - mini_size
    return delta


def print_additional_info(orig_source, minified_source, filename, args):
    """Prints out additional info on the minification based on given args"""
    if args.names is True:
        print(f"{filename}:")

    if args.stats is True:
        orig_size = len(orig_source)
        mini_size = len(minified_source)
        delta = get_minification_delta(orig_source, minified_source)
        if orig_size != 0:
            print(
                "Original: {} characters, Minified: {} characters, {} removed ({:.1f}%)".format(
                    orig_size,
                    mini_size,
                    delta,
                    (float(delta) / float(orig_size)) * 100.0,
                )
            )


def process_files(args):
    """Minifies a list of code files and displays additional info based on
    given args"""
    for filename in args.files:
        orig_source_code = ""
        newline = None  # would use \n by default
        # No matter the original newline character used (LF, CRLF...), python
        # will always use \n in code. But when outputting the minified
        # source, we need to know which newline character was used

        # A dash instructs the program to read from stdin
        if filename == "-":
            for line in fileinput.input():
                orig_source_code += line
        else:
            with open(filename) as f:
                orig_source_code = f.read()
                newline = f.newlines

        if type(newline) is tuple:
            print(f"Mixed newlines are unsupported, skipping file {filename}.")
            continue

        args.newline = newline  # storing the wanted newline character
        minified_source_code = minify_source(orig_source_code, args)

        print_additional_info(orig_source_code, minified_source_code, filename, args)

        # Finally output the minified code
        if filename == "-":
            print(minified_source_code)
        else:
            with open(filename, "w") as f:
                f.write(minified_source_code)


def main():
    args = get_args()
    process_files(args)


if __name__ == "__main__":
    main()
</file>

<file path="tools/makeheaders.c">
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<memory.h>
#include<sys/stat.h>
#include<assert.h>
#include<string.h>
#if defined(__MINGW32__)||defined(__DMC__)||defined(_MSC_VER)||defined(__POCC__)
# ifndef WIN32
# define WIN32
# endif
#else 
# include<unistd.h>
#endif
#ifdef DEBUG
static int debugMask=0;
# define debug0(F,M)if((F)&debugMask){fprintf(stderr,M);}
# define debug1(F,M,A)if((F)&debugMask){fprintf(stderr,M,A);}
# define debug2(F,M,A,B)if((F)&debugMask){fprintf(stderr,M,A,B);}
# define debug3(F,M,A,B,C)if((F)&debugMask){fprintf(stderr,M,A,B,C);}
# define PARSER 0x00000001
# define DECL_DUMP 0x00000002
# define TOKENIZER 0x00000004
#else 
# define debug0(Flags,Format)
# define debug1(Flags,Format,A)
# define debug2(Flags,Format,A,B)
# define debug3(Flags,Format,A,B,C)
#endif
#define INTERFACE 1
#define EXPORT_INTERFACE 1
#define EXPORT
typedef struct Token Token;struct Token{const char*zText;int nText;int eType;int nLine;Token*pComment;Token*pNext;Token*pPrev;};typedef struct InStream InStream;struct InStream{const char*z;int i;int nLine;};typedef struct Decl Decl;struct Decl{char*zName;const char*zFile;char*zIf;char*zFwd;char*zFwdCpp;char*zDecl;char*zExtra;int extraType;struct Include*pInclude;int flags;Token*pComment;Token tokenCode;Decl*pSameName;Decl*pSameHash;Decl*pNext;};
#define DP_Forward 0x001
#define DP_Declared 0x002
#define DP_Export 0x004
#define DP_Local 0x008
#define DP_Flag 0x010
#define DP_Cplusplus 0x020
#define DP_ExternCReqd 0x040
#define DP_ExternReqd 0x080
#define DeclHasProperty(D,P)(((D)->flags&(P))==(P))
#define DeclHasAnyProperty(D,P)(((D)->flags&(P))!=0)
#define DeclSetProperty(D,P)(D)->flags|=(P)
#define DeclClearProperty(D,P)(D)->flags&=~(P)
#define PS_Extern 0x000800
#define PS_Export 0x001000
#define PS_Export2 0x002000
#define PS_Typedef 0x004000
#define PS_Static 0x008000
#define PS_Interface 0x010000
#define PS_Method 0x020000
#define PS_Local 0x040000
#define PS_Local2 0x080000
#define PS_Public 0x100000
#define PS_Protected 0x200000
#define PS_Private 0x400000
#define PS_PPP 0x700000
#define TY_Class 0x00100000
#define TY_Subroutine 0x00200000
#define TY_Macro 0x00400000
#define TY_Typedef 0x00800000
#define TY_Variable 0x01000000
#define TY_Structure 0x02000000
#define TY_Union 0x04000000
#define TY_Enumeration 0x08000000
#define TY_Defunct 0x10000000
typedef struct Ifmacro Ifmacro;struct Ifmacro{int nLine;char*zCondition;Ifmacro*pNext;int flags;};typedef struct Include Include;struct Include{char*zFile;char*zIf;char*zLabel;Include*pNext;};typedef struct Ident Ident;struct Ident{char*zName;Ident*pCollide;Ident*pNext;};
#define IDENT_HASH_SIZE 2237
typedef struct IdentTable IdentTable;struct IdentTable{Ident*pList;Ident*apTable[IDENT_HASH_SIZE];};typedef struct InFile InFile;struct InFile{char*zSrc;char*zHdr;int flags;InFile*pNext;IdentTable idTable;};typedef struct String String;struct String{int nAlloc;int nUsed;char*zText;};typedef struct GenState GenState;struct GenState{String*pStr;IdentTable*pTable;const char*zIf;int nErr;const char*zFilename;int flags;};const char zTopLine[]="\n""#undef INTERFACE\n";
#define nTopLine(sizeof(zTopLine)-1)
static const char*zFilename;static Ifmacro*ifStack=0;static Include*includeList=0;static Token*blockComment=0;static int doc_flag=0;static int proto_static=0;static Decl*pDeclFirst;static Decl*pDeclLast;
#define DECL_HASH_SIZE 3371
static Decl*apTable[DECL_HASH_SIZE];
#ifndef TEST
# define TEST 0
#endif
#ifdef NOT_USED
#define Assert(X)if(!(X)){CantHappen(__LINE__);}
#define CANT_HAPPEN CantHappen(__LINE__)
static void CantHappen(int iLine){fprintf(stderr,"Assertion failed on line%d\n",iLine);*(char*)1=0;}
#endif
static void*SafeMalloc(int nByte){void*p=malloc(nByte);if(p==0){fprintf(stderr,"Out of memory. Can't allocate%d bytes.\n",nByte);exit(1);}return p;}static void SafeFree(void*pOld){if(pOld){free(pOld);}}static void*SafeRealloc(void*pOld,int nByte){void*p;if(pOld==0){p=SafeMalloc(nByte);}else{p=realloc(pOld,nByte);if(p==0){fprintf(stderr,"Out of memory. Can't enlarge an allocation to%d bytes\n",nByte);exit(1);}}return p;}static char*StrDup(const char*zSrc,int nByte){char*zDest;if(nByte<=0){nByte=strlen(zSrc);}zDest=SafeMalloc(nByte+1);strncpy(zDest,zSrc,nByte);zDest[nByte]=0;return zDest;}
#define ISALNUM(X)((X)=='_'||isalnum(X))
static void StringInit(String*pStr){pStr->nAlloc=0;pStr->nUsed=0;pStr->zText=0;}static void StringReset(String*pStr){SafeFree(pStr->zText);StringInit(pStr);}static void StringAppend(String*pStr,const char*zText,int nByte){if(nByte<=0){nByte=strlen(zText);}if(pStr->nUsed+nByte>=pStr->nAlloc){if(pStr->nAlloc==0){pStr->nAlloc=nByte+100;pStr->zText=SafeMalloc(pStr->nAlloc);}else{pStr->nAlloc=pStr->nAlloc*2+nByte;pStr->zText=SafeRealloc(pStr->zText,pStr->nAlloc);}}strncpy(&pStr->zText[pStr->nUsed],zText,nByte);pStr->nUsed+=nByte;pStr->zText[pStr->nUsed]=0;}
#define StringGet(S)((S)->zText?(S)->zText:"")
static int Hash(const char*z,int n){int h=0;if(n<=0){n=strlen(z);}while(n--){h=h^(h<<5)^*z++;}return h&0x7fffffff;}static Decl*FindDecl(const char*zName,int len){int h;Decl*p;if(len<=0){len=strlen(zName);}h=Hash(zName,len)%DECL_HASH_SIZE;p=apTable[h];while(p&&(strncmp(p->zName,zName,len)!=0||p->zName[len]!=0)){p=p->pSameHash;}return p;}static void InstallDecl(Decl*pDecl){int h;Decl*pOther;h=Hash(pDecl->zName,0)%DECL_HASH_SIZE;pOther=apTable[h];while(pOther&&strcmp(pDecl->zName,pOther->zName)!=0){pOther=pOther->pSameHash;}if(pOther){pDecl->pSameName=pOther->pSameName;pOther->pSameName=pDecl;}else{pDecl->pSameName=0;pDecl->pSameHash=apTable[h];apTable[h]=pDecl;}pDecl->pNext=0;if(pDeclFirst==0){pDeclFirst=pDeclLast=pDecl;}else{pDeclLast->pNext=pDecl;pDeclLast=pDecl;}}static char*GetIfString(void){Ifmacro*pIf;char*zResult=0;int hasIf=0;String str;for(pIf=ifStack;pIf;pIf=pIf->pNext){if(pIf->zCondition==0||*pIf->zCondition==0)continue;if(!hasIf){hasIf=1;StringInit(&str);}else{StringAppend(&str,"&&",4);}StringAppend(&str,pIf->zCondition,0);}if(hasIf){zResult=StrDup(StringGet(&str),0);StringReset(&str);}else{zResult=0;}return zResult;}static Decl*CreateDecl(const char*zName,int nName){Decl*pDecl;pDecl=SafeMalloc(sizeof(Decl)+nName+1);memset(pDecl,0,sizeof(Decl));pDecl->zName=(char*)&pDecl[1];sprintf(pDecl->zName,"%.*s",nName,zName);pDecl->zFile=zFilename;pDecl->pInclude=includeList;pDecl->zIf=GetIfString();InstallDecl(pDecl);return pDecl;}static int IdentTableInsert(IdentTable*pTable,const char*zId,int nId){int h;Ident*pId;if(nId<=0){nId=strlen(zId);}h=Hash(zId,nId)%IDENT_HASH_SIZE;for(pId=pTable->apTable[h];pId;pId=pId->pCollide){if(strncmp(zId,pId->zName,nId)==0&&pId->zName[nId]==0){return 0;}}pId=SafeMalloc(sizeof(Ident)+nId+1);pId->zName=(char*)&pId[1];sprintf(pId->zName,"%.*s",nId,zId);pId->pNext=pTable->pList;pTable->pList=pId;pId->pCollide=pTable->apTable[h];pTable->apTable[h]=pId;return 1;}static int IdentTableTest(IdentTable*pTable,const char*zId,int nId){int h;Ident*pId;if(nId<=0){nId=strlen(zId);}h=Hash(zId,nId)%IDENT_HASH_SIZE;for(pId=pTable->apTable[h];pId;pId=pId->pCollide){if(strncmp(zId,pId->zName,nId)==0&&pId->zName[nId]==0){return 1;}}return 0;}static void IdentTableReset(IdentTable*pTable){Ident*pId,*pNext;for(pId=pTable->pList;pId;pId=pNext){pNext=pId->pNext;SafeFree(pId);}memset(pTable,0,sizeof(IdentTable));}
#ifdef DEBUG
static void IdentTablePrint(IdentTable*pTable,FILE*pOut){Ident*pId;for(pId=pTable->pList;pId;pId=pId->pNext){fprintf(pOut,"%s\n",pId->zName);}}
#endif
static char*ReadFile(const char*zFilename){struct stat sStat;FILE*pIn;char*zBuf;int n;if(stat(zFilename,&sStat)!=0
#ifndef WIN32
||!S_ISREG(sStat.st_mode)
#endif
){return 0;}pIn=fopen(zFilename,"r");if(pIn==0){return 0;}zBuf=SafeMalloc(sStat.st_size+1);n=fread(zBuf,1,sStat.st_size,pIn);zBuf[n]=0;fclose(pIn);return zBuf;}static int WriteFile(const char*zFilename,const char*zOutput){FILE*pOut;pOut=fopen(zFilename,"w");if(pOut==0){return 1;}fwrite(zOutput,1,strlen(zOutput),pOut);fclose(pOut);return 0;}
#define TT_Space 1
#define TT_Id 2
#define TT_Preprocessor 3
#define TT_Comment 4
#define TT_Number 5
#define TT_String 6
#define TT_Braces 7
#define TT_EOF 8
#define TT_Error 9
#define TT_BlockComment 10
#define TT_Other 0
static int GetToken(InStream*pIn,Token*pToken){int i;const char*z;int cStart;int c;int startLine;int nlisc=0;int nErr=0;z=pIn->z;i=pIn->i;pToken->nLine=pIn->nLine;pToken->zText=&z[i];switch(z[i]){case 0:pToken->eType=TT_EOF;pToken->nText=0;break;case '#':if(i==0||z[i-1]=='\n'||(i>1&&z[i-1]=='\r'&&z[i-2]=='\n')){pToken->eType=TT_Preprocessor;i++;while(z[i]!=0&&z[i]!='\n'){if(z[i]=='\\'){i++;if(z[i]=='\n')pIn->nLine++;}i++;}pToken->nText=i-pIn->i;}else{pToken->eType=TT_Other;pToken->nText=1;}break;case ' ':case '\t':case '\r':case '\f':case '\n':while(isspace(z[i])){if(z[i]=='\n')pIn->nLine++;i++;}pToken->eType=TT_Space;pToken->nText=i-pIn->i;break;case '\\':pToken->nText=2;pToken->eType=TT_Other;if(z[i+1]=='\n'){pIn->nLine++;pToken->eType=TT_Space;}else if(z[i+1]==0){pToken->nText=1;}break;case '\'':case '\"':cStart=z[i];startLine=pIn->nLine;do{i++;c=z[i];if(c=='\n'){if(!nlisc){fprintf(stderr,"%s:%d:(warning)Newline in string or character literal.\n",zFilename,pIn->nLine);nlisc=1;}pIn->nLine++;}if(c=='\\'){i++;c=z[i];if(c=='\n'){pIn->nLine++;}}else if(c==cStart){i++;c=0;}else if(c==0){fprintf(stderr,"%s:%d:Unterminated string or character literal.\n",zFilename,startLine);nErr++;}}while(c);pToken->eType=TT_String;pToken->nText=i-pIn->i;break;case '/':if(z[i+1]=='/'){while(z[i]&&z[i]!='\n'){i++;}pToken->eType=TT_Comment;pToken->nText=i-pIn->i;}else if(z[i+1]=='*'){int isBlockComment=i==0||z[i-1]=='\n';i+=2;startLine=pIn->nLine;while(z[i]&&(z[i]!='*'||z[i+1]!='/')){if(z[i]=='\n'){pIn->nLine++;if(isBlockComment){if(z[i+1]=='*'||z[i+2]=='*'){isBlockComment=2;}else{isBlockComment=0;}}}i++;}if(z[i]){i+=2;}else{isBlockComment=0;fprintf(stderr,"%s:%d:Unterminated comment\n",zFilename,startLine);nErr++;}pToken->eType=isBlockComment==2?TT_BlockComment:TT_Comment;pToken->nText=i-pIn->i;}else{pToken->eType=TT_Other;pToken->nText=1+(z[i+1]=='+');}break;case '0':if(z[i+1]=='x'||z[i+1]=='X'){i+=2;while(isxdigit(z[i])){i++;}}else{while(isdigit(z[i])){i++;}}pToken->eType=TT_Number;pToken->nText=i-pIn->i;break;case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':while(isdigit(z[i])){i++;}if((c=z[i])=='.'){i++;while(isdigit(z[i])){i++;}c=z[i];if(c=='e'||c=='E'){i++;if(((c=z[i])=='+'||c=='-')&&isdigit(z[i+1])){i++;}while(isdigit(z[i])){i++;}c=z[i];}if(c=='f'||c=='F'||c=='l'||c=='L'){i++;}}else if(c=='e'||c=='E'){i++;if(((c=z[i])=='+'||c=='-')&&isdigit(z[i+1])){i++;}while(isdigit(z[i])){i++;}}else if(c=='L'||c=='l'){i++;c=z[i];if(c=='u'||c=='U'){i++;}}else if(c=='u'||c=='U'){i++;c=z[i];if(c=='l'||c=='L'){i++;}}pToken->eType=TT_Number;pToken->nText=i-pIn->i;break;case 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h':case 'i':case 'j':case 'k':case 'l':case 'm':case 'n':case 'o':case 'p':case 'q':case 'r':case 's':case 't':case 'u':case 'v':case 'w':case 'x':case 'y':case 'z':case 'A':case 'B':case 'C':case 'D':case 'E':case 'F':case 'G':case 'H':case 'I':case 'J':case 'K':case 'L':case 'M':case 'N':case 'O':case 'P':case 'Q':case 'R':case 'S':case 'T':case 'U':case 'V':case 'W':case 'X':case 'Y':case 'Z':case '_':while(isalnum(z[i])||z[i]=='_'){i++;};pToken->eType=TT_Id;pToken->nText=i-pIn->i;break;case ':':pToken->eType=TT_Other;pToken->nText=1+(z[i+1]==':');break;case '=':case '<':case '>':case '+':case '-':case '*':case '%':case '^':case '&':case '|':pToken->eType=TT_Other;pToken->nText=1+(z[i+1]=='=');break;default:pToken->eType=TT_Other;pToken->nText=1;break;}pIn->i+=pToken->nText;return nErr;}static int GetNonspaceToken(InStream*pIn,Token*pToken){int nIf=0;int inZero=0;const char*z;int value;int startLine;int nErr=0;startLine=pIn->nLine;while(1){nErr+=GetToken(pIn,pToken);pToken->pComment=blockComment;switch(pToken->eType){case TT_Comment:if(strncmp(pToken->zText,"}static void FindIdentifiersInMacro(Token*pToken,IdentTable*pTable){Token sToken;InStream sIn;int go=1;sIn.z=pToken->zText;sIn.i=1;sIn.nLine=1;while(go&&sIn.i<pToken->nText){GetToken(&sIn,&sToken);switch(sToken.eType){case TT_Id:IdentTableInsert(pTable,sToken.zText,sToken.nText);break;case TT_EOF:go=0;break;default:break;}}}static int GetBigToken(InStream*pIn,Token*pToken,IdentTable*pTable){const char*zStart;int iStart;int nBrace;int c;int nLine;int nErr;nErr=GetNonspaceToken(pIn,pToken);switch(pToken->eType){case TT_Id:if(pTable!=0){IdentTableInsert(pTable,pToken->zText,pToken->nText);}return nErr;case TT_Preprocessor:if(pTable!=0){FindIdentifiersInMacro(pToken,pTable);}return nErr;case TT_Other:if(pToken->zText[0]=='{')break;return nErr;default:return nErr;}iStart=pIn->i;zStart=pToken->zText;nLine=pToken->nLine;nBrace=1;while(nBrace){nErr+=GetNonspaceToken(pIn,pToken);switch(pToken->eType){case TT_EOF:fprintf(stderr,"%s:%d:Unterminated \"{\"\n",zFilename,nLine);nErr++;pToken->eType=TT_Error;return nErr;case TT_Id:if(pTable){IdentTableInsert(pTable,pToken->zText,pToken->nText);}break;case TT_Preprocessor:if(pTable!=0){FindIdentifiersInMacro(pToken,pTable);}break;case TT_Other:if((c=pToken->zText[0])=='{'){nBrace++;}else if(c=='}'){nBrace--;}break;default:break;}}pToken->eType=TT_Braces;pToken->nText=1+pIn->i-iStart;pToken->zText=zStart;pToken->nLine=nLine;return nErr;}static void FreeTokenList(Token*pList){Token*pNext;while(pList){pNext=pList->pNext;SafeFree(pList);pList=pNext;}}static Token*TokenizeFile(const char*zFile,IdentTable*pTable){InStream sIn;Token*pFirst=0,*pLast=0,*pNew;int nErr=0;sIn.z=zFile;sIn.i=0;sIn.nLine=1;blockComment=0;while(sIn.z[sIn.i]!=0){pNew=SafeMalloc(sizeof(Token));nErr+=GetBigToken(&sIn,pNew,pTable);debug3(TOKENIZER,"Token on line%d:[%.*s]\n",pNew->nLine,pNew->nText<50?pNew->nText:50,pNew->zText);if(pFirst==0){pFirst=pLast=pNew;pNew->pPrev=0;}else{pLast->pNext=pNew;pNew->pPrev=pLast;pLast=pNew;}if(pNew->eType==TT_EOF)break;}if(pLast)pLast->pNext=0;blockComment=0;if(nErr){FreeTokenList(pFirst);pFirst=0;}return pFirst;}
#if TEST==1
void main(int argc,char**argv){char*zFile;Token*pList,*p;IdentTable sTable;if(argc!=2){fprintf(stderr,"Usage:%s filename\n",*argv);exit(1);}memset(&sTable,0,sizeof(sTable));zFile=ReadFile(argv[1]);if(zFile==0){fprintf(stderr,"Can't read file \"%s\"\n",argv[1]);exit(1);}pList=TokenizeFile(zFile,&sTable);for(p=pList;p;p=p->pNext){int j;switch(p->eType){case TT_Space:printf("%4d:Space\n",p->nLine);break;case TT_Id:printf("%4d:Id%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Preprocessor:printf("%4d:Preprocessor%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Comment:printf("%4d:Comment\n",p->nLine);break;case TT_BlockComment:printf("%4d:Block Comment\n",p->nLine);break;case TT_Number:printf("%4d:Number%.*s\n",p->nLine,p->nText,p->zText);break;case TT_String:printf("%4d:String%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Other:printf("%4d:Other%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Braces:for(j=0;j<p->nText&&j<30&&p->zText[j]!='\n';j++){}printf("%4d:Braces%.*s...}\n",p->nLine,j,p->zText);break;case TT_EOF:printf("%4d:End of file\n",p->nLine);break;default:printf("%4d:type%d\n",p->nLine,p->eType);break;}}FreeTokenList(pList);SafeFree(zFile);IdentTablePrint(&sTable,stdout);}
#endif
#ifdef DEBUG
static void PrintTokens(Token*pFirst,Token*pLast){int needSpace=0;int c;pLast=pLast->pNext;while(pFirst!=pLast){switch(pFirst->eType){case TT_Preprocessor:printf("\n%.*s\n",pFirst->nText,pFirst->zText);needSpace=0;break;case TT_Id:case TT_Number:printf("%s%.*s",needSpace?" ":"",pFirst->nText,pFirst->zText);needSpace=1;break;default:c=pFirst->zText[0];printf("%s%.*s",(needSpace&&(c=='*'||c=='{'))?" ":"",pFirst->nText,pFirst->zText);needSpace=pFirst->zText[0]==',';break;}pFirst=pFirst->pNext;}}
#endif
static char*TokensToString(Token*pFirst,Token*pLast,char*zTerm,Token*pSkip,int nSkip){char*zReturn;String str;int needSpace=0;int c;int iSkip=0;int skipOne=0;StringInit(&str);pLast=pLast->pNext;while(pFirst!=pLast){if(pFirst==pSkip){iSkip=nSkip;}if(iSkip>0){iSkip--;pFirst=pFirst->pNext;continue;}switch(pFirst->eType){case TT_Preprocessor:StringAppend(&str,"\n",1);StringAppend(&str,pFirst->zText,pFirst->nText);StringAppend(&str,"\n",1);needSpace=0;break;case TT_Id:switch(pFirst->zText[0]){case 'E':if(pFirst->nText==6&&strncmp(pFirst->zText,"EXPORT",6)==0){skipOne=1;}break;case 'P':switch(pFirst->nText){case 6:skipOne=!strncmp(pFirst->zText,"PUBLIC",6);break;case 7:skipOne=!strncmp(pFirst->zText,"PRIVATE",7);break;case 9:skipOne=!strncmp(pFirst->zText,"PROTECTED",9);break;default:break;}break;default:break;}if(skipOne){pFirst=pFirst->pNext;skipOne=0;continue;}case TT_Number:if(needSpace){StringAppend(&str," ",1);}StringAppend(&str,pFirst->zText,pFirst->nText);needSpace=1;break;default:c=pFirst->zText[0];if(needSpace&&(c=='*'||c=='{')){StringAppend(&str," ",1);}StringAppend(&str,pFirst->zText,pFirst->nText);needSpace=0;break;}pFirst=pFirst->pNext;}if(zTerm&&*zTerm){StringAppend(&str,zTerm,strlen(zTerm));}zReturn=StrDup(StringGet(&str),0);StringReset(&str);return zReturn;}static int ProcessTypeDecl(Token*pList,int flags,int*pReset){Token*pName,*pEnd;Decl*pDecl;String str;int need_to_collapse=1;int type=0;*pReset=0;if(pList==0||pList->pNext==0||pList->pNext->eType!=TT_Id){return 0;}pName=pList->pNext;if(pName->pNext&&pName->pNext->zText[0]==';'){*pReset=';';return 0;}for(pEnd=pName->pNext;pEnd&&pEnd->eType!=TT_Braces;pEnd=pEnd->pNext){switch(pEnd->zText[0]){case '(':case ')':case '*':case '[':case '=':case ';':return 0;}}if(pEnd==0){return 0;}if(pEnd->pNext==0||pEnd->pNext->zText[0]==';'){*pReset=';';need_to_collapse=0;}else{need_to_collapse=1;}if(proto_static==0&&(flags&(PS_Local|PS_Export|PS_Interface))==0){*pReset=';';return 0;}
#ifdef DEBUG
if(debugMask&PARSER){printf("****Found type:%.*s%.*s...\n",pList->nText,pList->zText,pName->nText,pName->zText);PrintTokens(pList,pEnd);printf(";\n");}
#endif
switch(*pList->zText){case 'c':type=TY_Class;break;case 's':type=TY_Structure;break;case 'e':type=TY_Enumeration;break;case 'u':type=TY_Union;break;default:break;}if(type!=TY_Class){pDecl=0;}else{pDecl=FindDecl(pName->zText,pName->nText);if(pDecl&&(pDecl->flags&type)!=type)pDecl=0;}if(pDecl==0){pDecl=CreateDecl(pName->zText,pName->nText);}if((flags&PS_Static)||!(flags&(PS_Interface|PS_Export))){DeclSetProperty(pDecl,DP_Local);}DeclSetProperty(pDecl,type);if(flags&(PS_Local|PS_Export|PS_Interface)){pDecl->zDecl=TokensToString(pList,pEnd,";\n",0,0);}else{pDecl->zDecl=0;}pDecl->pComment=pList->pComment;StringInit(&str);StringAppend(&str,"typedef ",0);StringAppend(&str,pList->zText,pList->nText);StringAppend(&str," ",0);StringAppend(&str,pName->zText,pName->nText);StringAppend(&str," ",0);StringAppend(&str,pName->zText,pName->nText);StringAppend(&str,";\n",2);pDecl->zFwd=StrDup(StringGet(&str),0);StringReset(&str);StringInit(&str);StringAppend(&str,pList->zText,pList->nText);StringAppend(&str," ",0);StringAppend(&str,pName->zText,pName->nText);StringAppend(&str,";\n",2);pDecl->zFwdCpp=StrDup(StringGet(&str),0);StringReset(&str);if(flags&PS_Export){DeclSetProperty(pDecl,DP_Export);}else if(flags&PS_Local){DeclSetProperty(pDecl,DP_Local);}if(pDecl->zDecl&&DeclHasProperty(pDecl,TY_Enumeration)){StringInit(&str);StringAppend(&str,pDecl->zDecl,0);StringAppend(&str,pDecl->zFwd,0);SafeFree(pDecl->zDecl);SafeFree(pDecl->zFwd);pDecl->zFwd=0;pDecl->zDecl=StrDup(StringGet(&str),0);StringReset(&str);}if(pName->pNext->zText[0]==':'){DeclSetProperty(pDecl,DP_Cplusplus);}if(pName->nText==5&&strncmp(pName->zText,"class",5)==0){DeclSetProperty(pDecl,DP_Cplusplus);}if(need_to_collapse){while(pEnd!=pName){Token*pPrev=pEnd->pPrev;pPrev->pNext=pEnd->pNext;pEnd->pNext->pPrev=pPrev;SafeFree(pEnd);pEnd=pPrev;}}return 0;}static Token*FindDeclName(Token*pFirst,Token*pLast){Token*pName=0;Token*p;int c;if(pFirst==0||pLast==0){return 0;}pLast=pLast->pNext;for(p=pFirst;p&&p!=pLast;p=p->pNext){if(p->eType==TT_Id){static IdentTable sReserved;static int isInit=0;static const char*aWords[]={"char","class","const","double","enum","extern","EXPORT","ET_PROC","float","int","long","PRIVATE","PROTECTED","PUBLIC","register","static","struct","sizeof","signed","typedef","union","volatile","virtual","void",};if(!isInit){int i;for(i=0;i<sizeof(aWords)/sizeof(aWords[0]);i++){IdentTableInsert(&sReserved,aWords[i],0);}isInit=1;}if(!IdentTableTest(&sReserved,p->zText,p->nText)){pName=p;}}else if(p==pFirst){continue;}else if((c=p->zText[0])=='['&&pName){break;}else if(c=='('&&p->pNext&&p->pNext->eType==TT_Id&&pName){break;}else if(c==':'&&p->zText[1]==':'&&pName){break;}}return pName;}static int ProcessMethodDef(Token*pFirst,Token*pLast,int flags){Token*pClass;char*zDecl;Decl*pDecl;String str;int type;pLast=pLast->pPrev;while(pFirst->zText[0]=='P'){int rc=1;switch(pFirst->nText){case 6:rc=strncmp(pFirst->zText,"PUBLIC",6);break;case 7:rc=strncmp(pFirst->zText,"PRIVATE",7);break;case 9:rc=strncmp(pFirst->zText,"PROTECTED",9);break;default:break;}if(rc)break;pFirst=pFirst->pNext;}pClass=FindDeclName(pFirst,pLast);if(pClass==0){fprintf(stderr,"%s:%d:Unable to find the class name for this method\n",zFilename,pFirst->nLine);return 1;}pDecl=FindDecl(pClass->zText,pClass->nText);if(pDecl==0||(pDecl->flags&TY_Class)!=TY_Class){pDecl=CreateDecl(pClass->zText,pClass->nText);DeclSetProperty(pDecl,TY_Class);}StringInit(&str);if(pDecl->zExtra){StringAppend(&str,pDecl->zExtra,0);SafeFree(pDecl->zExtra);pDecl->zExtra=0;}type=flags&PS_PPP;if(pDecl->extraType!=type){if(type&PS_Public){StringAppend(&str,"public:\n",0);pDecl->extraType=PS_Public;}else if(type&PS_Protected){StringAppend(&str,"protected:\n",0);pDecl->extraType=PS_Protected;}else if(type&PS_Private){StringAppend(&str,"private:\n",0);pDecl->extraType=PS_Private;}}StringAppend(&str," ",0);zDecl=TokensToString(pFirst,pLast,";\n",pClass,2);if(strncmp(zDecl,pClass->zText,pClass->nText)==0){char*colon=strchr(zDecl,':');if(colon!=0&&colon[1]!=0){*colon++=';';*colon++='\n';*colon=0;}}StringAppend(&str,zDecl,0);SafeFree(zDecl);pDecl->zExtra=StrDup(StringGet(&str),0);StringReset(&str);return 0;}static int ProcessProcedureDef(Token*pFirst,Token*pLast,int flags){Token*pName;Decl*pDecl;Token*pCode;if(pFirst==0||pLast==0){return 0;}if(flags&PS_Method){if(flags&PS_PPP){return ProcessMethodDef(pFirst,pLast,flags);}else{return 0;}}if((flags&PS_Static)!=0&&!proto_static){return 0;}pCode=pLast;while(pLast&&pLast!=pFirst&&pLast->zText[0]!=')'){pLast=pLast->pPrev;}if(pLast==0||pLast==pFirst||pFirst->pNext==pLast){fprintf(stderr,"%s:%d:Unrecognized syntax.\n",zFilename,pFirst->nLine);return 1;}if(flags&(PS_Interface|PS_Export|PS_Local)){fprintf(stderr,"%s:%d:Missing \"inline\" on function or procedure.\n",zFilename,pFirst->nLine);return 1;}pName=FindDeclName(pFirst,pLast);if(pName==0){fprintf(stderr,"%s:%d:Malformed function or procedure definition.\n",zFilename,pFirst->nLine);return 1;}if(strncmp(pName->zText,"main",pName->nText)==0){return 0;}
#ifdef DEBUG
if(debugMask&PARSER){printf("****Found routine:%.*s on line%d...\n",pName->nText,pName->zText,pFirst->nLine);PrintTokens(pFirst,pLast);printf(";\n");}
#endif
pDecl=CreateDecl(pName->zText,pName->nText);pDecl->pComment=pFirst->pComment;if(pCode&&pCode->eType==TT_Braces){pDecl->tokenCode=*pCode;}DeclSetProperty(pDecl,TY_Subroutine);pDecl->zDecl=TokensToString(pFirst,pLast,";\n",0,0);if((flags&(PS_Static|PS_Local2))!=0){DeclSetProperty(pDecl,DP_Local);}else if((flags&(PS_Export2))!=0){DeclSetProperty(pDecl,DP_Export);}if(flags&DP_Cplusplus){DeclSetProperty(pDecl,DP_Cplusplus);}else{DeclSetProperty(pDecl,DP_ExternCReqd);}return 0;}static int ProcessInlineProc(Token*pFirst,int flags,int*pReset){Token*pName;Token*pEnd;Decl*pDecl;for(pEnd=pFirst;pEnd;pEnd=pEnd->pNext){if(pEnd->zText[0]=='{'||pEnd->zText[0]==';'){*pReset=pEnd->zText[0];break;}}if(pEnd==0){*pReset=';';fprintf(stderr,"%s:%d:incomplete inline procedure definition\n",zFilename,pFirst->nLine);return 1;}pName=FindDeclName(pFirst,pEnd);if(pName==0){fprintf(stderr,"%s:%d:malformed inline procedure definition\n",zFilename,pFirst->nLine);return 1;}
#ifdef DEBUG
if(debugMask&PARSER){printf("****Found inline routine:%.*s on line%d...\n",pName->nText,pName->zText,pFirst->nLine);PrintTokens(pFirst,pEnd);printf("\n");}
#endif
pDecl=CreateDecl(pName->zText,pName->nText);pDecl->pComment=pFirst->pComment;DeclSetProperty(pDecl,TY_Subroutine);pDecl->zDecl=TokensToString(pFirst,pEnd,";\n",0,0);if((flags&(PS_Static|PS_Local|PS_Local2))){DeclSetProperty(pDecl,DP_Local);}else if(flags&(PS_Export|PS_Export2)){DeclSetProperty(pDecl,DP_Export);}if(flags&DP_Cplusplus){DeclSetProperty(pDecl,DP_Cplusplus);}else{DeclSetProperty(pDecl,DP_ExternCReqd);}return 0;}static int isVariableDef(Token*pFirst,Token*pEnd){if(pEnd&&pEnd->zText[0]=='='&&(pEnd->pPrev->nText!=8||strncmp(pEnd->pPrev->zText,"operator",8)!=0)){return 1;}while(pFirst&&pFirst!=pEnd&&pFirst->pNext&&pFirst->pNext!=pEnd){if(pFirst->eType==TT_Id&&pFirst->pNext->zText[0]=='('){return 0;}pFirst=pFirst->pNext;}return 1;}static int isStaticAssert(Token*pFirst){if((pFirst->nText==13&&strncmp(pFirst->zText,"static_assert",13)==0)||(pFirst->nText==14&&strncmp(pFirst->zText,"_Static_assert",14)==0)){return 1;}else{return 0;}}static int ProcessDecl(Token*pFirst,Token*pEnd,int flags){Token*pName;Decl*pDecl;int isLocal=0;int isVar;int nErr=0;if(pFirst==0||pEnd==0){return 0;}if(flags&PS_Typedef){if((flags&(PS_Export2|PS_Local2))!=0){fprintf(stderr,"%s:%d:\"EXPORT\" or \"LOCAL\" ignored before typedef.\n",zFilename,pFirst->nLine);nErr++;}if((flags&(PS_Interface|PS_Export|PS_Local|DP_Cplusplus))==0){return nErr;}if((flags&(PS_Interface|PS_Export|PS_Local))==0&&proto_static==0){return nErr;}if((flags&(PS_Interface|PS_Export))==0){isLocal=1;}}else if(flags&(PS_Static|PS_Local2)){if(proto_static==0&&(flags&PS_Local2)==0){return nErr;}while(pFirst!=0&&pFirst->pNext!=pEnd&&((pFirst->nText==6&&strncmp(pFirst->zText,"static",6)==0)||(pFirst->nText==5&&strncmp(pFirst->zText,"LOCAL",6)==0))){pFirst=pFirst->pNext;isLocal=1;}if(pFirst==0||!isLocal){return nErr;}}else if(flags&PS_Method){return nErr;}else if(isStaticAssert(pFirst)){return 0;}isVar=(flags&(PS_Typedef|PS_Method))==0&&isVariableDef(pFirst,pEnd);if(isVar&&(flags&(PS_Interface|PS_Export|PS_Local))!=0&&(flags&PS_Extern)==0){fprintf(stderr,"%s:%d:Can't define a variable in this context\n",zFilename,pFirst->nLine);nErr++;}pName=FindDeclName(pFirst,pEnd->pPrev);if(pName==0){if(pFirst->nText==4&&strncmp(pFirst->zText,"enum",4)==0){return nErr;}else{fprintf(stderr,"%s:%d:Can't find a name for the object declared here.\n",zFilename,pFirst->nLine);return nErr+1;}}
#ifdef DEBUG
if(debugMask&PARSER){if(flags&PS_Typedef){printf("****Found typedef%.*s at line%d...\n",pName->nText,pName->zText,pName->nLine);}else if(isVar){printf("****Found variable%.*s at line%d...\n",pName->nText,pName->zText,pName->nLine);}else{printf("****Found prototype%.*s at line%d...\n",pName->nText,pName->zText,pName->nLine);}PrintTokens(pFirst,pEnd->pPrev);printf(";\n");}
#endif
pDecl=CreateDecl(pName->zText,pName->nText);if((flags&PS_Typedef)){DeclSetProperty(pDecl,TY_Typedef);}else if(isVar){DeclSetProperty(pDecl,DP_ExternReqd|TY_Variable);if(!(flags&DP_Cplusplus)){DeclSetProperty(pDecl,DP_ExternCReqd);}}else{DeclSetProperty(pDecl,TY_Subroutine);if(!(flags&DP_Cplusplus)){DeclSetProperty(pDecl,DP_ExternCReqd);}}pDecl->pComment=pFirst->pComment;pDecl->zDecl=TokensToString(pFirst,pEnd->pPrev,";\n",0,0);if(isLocal||(flags&(PS_Local|PS_Local2))!=0){DeclSetProperty(pDecl,DP_Local);}else if(flags&(PS_Export|PS_Export2)){DeclSetProperty(pDecl,DP_Export);}if(flags&DP_Cplusplus){DeclSetProperty(pDecl,DP_Cplusplus);}return nErr;}static void PushIfMacro(const char*zPrefix,const char*zText,int nText,int nLine,int flags){Ifmacro*pIf;int nByte;nByte=sizeof(Ifmacro);if(zText){if(zPrefix){nByte+=strlen(zPrefix)+2;}nByte+=nText+1;}pIf=SafeMalloc(nByte);if(zText){pIf->zCondition=(char*)&pIf[1];if(zPrefix){sprintf(pIf->zCondition,"%s(%.*s)",zPrefix,nText,zText);}else{sprintf(pIf->zCondition,"%.*s",nText,zText);}}else{pIf->zCondition=0;}pIf->nLine=nLine;pIf->flags=flags;pIf->pNext=ifStack;ifStack=pIf;}static int ParsePreprocessor(Token*pToken,int flags,int*pPresetFlags){const char*zCmd;int nCmd;const char*zArg;int nArg;int nErr=0;Ifmacro*pIf;zCmd=&pToken->zText[1];while(isspace(*zCmd)&&*zCmd!='\n'){zCmd++;}if(!isalpha(*zCmd)){return 0;}nCmd=1;while(isalpha(zCmd[nCmd])){nCmd++;}if(nCmd==5&&strncmp(zCmd,"endif",5)==0){pIf=ifStack;if(pIf==0){fprintf(stderr,"%s:%d:extra '#endif'.\n",zFilename,pToken->nLine);return 1;}ifStack=pIf->pNext;SafeFree(pIf);}else if(nCmd==6&&strncmp(zCmd,"define",6)==0){Decl*pDecl;if(!(flags&(PS_Local|PS_Interface|PS_Export))){return 0;}zArg=&zCmd[6];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}for(nArg=0;ISALNUM(zArg[nArg]);nArg++){}if(nArg==0){return 0;}pDecl=CreateDecl(zArg,nArg);pDecl->pComment=pToken->pComment;DeclSetProperty(pDecl,TY_Macro);pDecl->zDecl=SafeMalloc(pToken->nText+2);sprintf(pDecl->zDecl,"%.*s\n",pToken->nText,pToken->zText);if(flags&PS_Export){DeclSetProperty(pDecl,DP_Export);}else if(flags&PS_Local){DeclSetProperty(pDecl,DP_Local);}}else if(nCmd==7&&strncmp(zCmd,"include",7)==0){Include*pInclude;char*zIf;if(!(flags&(PS_Interface|PS_Export))){return 0;}zArg=&zCmd[7];while(*zArg&&isspace(*zArg)){zArg++;}for(nArg=0;!isspace(zArg[nArg]);nArg++){}if((zArg[0]=='"'&&zArg[nArg-1]!='"')||(zArg[0]=='<'&&zArg[nArg-1]!='>')){fprintf(stderr,"%s:%d:malformed #include statement.\n",zFilename,pToken->nLine);return 1;}zIf=GetIfString();if(zIf){pInclude=SafeMalloc(sizeof(Include)+nArg*2+strlen(zIf)+10);pInclude->zFile=(char*)&pInclude[1];pInclude->zLabel=&pInclude->zFile[nArg+1];sprintf(pInclude->zFile,"%.*s",nArg,zArg);sprintf(pInclude->zLabel,"%.*s:%s",nArg,zArg,zIf);pInclude->zIf=&pInclude->zLabel[nArg+1];SafeFree(zIf);}else{pInclude=SafeMalloc(sizeof(Include)+nArg+1);pInclude->zFile=(char*)&pInclude[1];sprintf(pInclude->zFile,"%.*s",nArg,zArg);pInclude->zIf=0;pInclude->zLabel=pInclude->zFile;}pInclude->pNext=includeList;includeList=pInclude;}else if(nCmd==2&&strncmp(zCmd,"if",2)==0){zArg=&zCmd[2];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}nArg=pToken->nText+(int)(pToken->zText-zArg);if(nArg==9&&strncmp(zArg,"INTERFACE",9)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Interface);}else if(nArg==16&&strncmp(zArg,"EXPORT_INTERFACE",16)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Export);}else if(nArg==15&&strncmp(zArg,"LOCAL_INTERFACE",15)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Local);}else if(nArg==15&&strncmp(zArg,"MAKEHEADERS_STOPLOCAL_INTERFACE",15)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Local);}else{PushIfMacro(0,zArg,nArg,pToken->nLine,0);}}else if(nCmd==5&&strncmp(zCmd,"ifdef",5)==0){zArg=&zCmd[5];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}nArg=pToken->nText+(int)(pToken->zText-zArg);PushIfMacro("defined",zArg,nArg,pToken->nLine,0);}else if(nCmd==6&&strncmp(zCmd,"ifndef",6)==0){zArg=&zCmd[6];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}nArg=pToken->nText+(int)(pToken->zText-zArg);PushIfMacro("!defined",zArg,nArg,pToken->nLine,0);}else if(nCmd==4&&strncmp(zCmd,"else ",4)==0){if(ifStack==0){fprintf(stderr,"%s:%d:'#else ' without an '#if'\n",zFilename,pToken->nLine);return 1;}pIf=ifStack;if(pIf->zCondition){ifStack=ifStack->pNext;PushIfMacro("!",pIf->zCondition,strlen(pIf->zCondition),pIf->nLine,0);SafeFree(pIf);}else{pIf->flags=0;}}else{return 0;}*pPresetFlags=0;for(pIf=ifStack;pIf;pIf=pIf->pNext){*pPresetFlags|=pIf->flags;}return nErr;}static int ParseFile(Token*pList,int initFlags){int nErr=0;Token*pStart=0;int flags=initFlags;int presetFlags=initFlags;int resetFlag=0;includeList=0;while(pList){switch(pList->eType){case TT_EOF:goto end_of_loop;case TT_Preprocessor:nErr+=ParsePreprocessor(pList,flags,&presetFlags);pStart=0;presetFlags|=initFlags;flags=presetFlags;break;case TT_Other:switch(pList->zText[0]){case ';':nErr+=ProcessDecl(pStart,pList,flags);pStart=0;flags=presetFlags;break;case '=':if(pList->pPrev->nText==8&&strncmp(pList->pPrev->zText,"operator",8)==0){break;}nErr+=ProcessDecl(pStart,pList,flags);pStart=0;while(pList&&pList->zText[0]!=';'){pList=pList->pNext;}if(pList==0)goto end_of_loop;flags=presetFlags;break;case ':':if(pList->zText[1]==':'){flags|=PS_Method;}break;default:break;}break;case TT_Braces:nErr+=ProcessProcedureDef(pStart,pList,flags);pStart=0;flags=presetFlags;break;case TT_Id:if(pStart==0){pStart=pList;flags=presetFlags;}resetFlag=0;switch(pList->zText[0]){case 'c':if(pList->nText==5&&strncmp(pList->zText,"class",5)==0){nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}break;case 'E':if(pList->nText==6&&strncmp(pList->zText,"EXPORT",6)==0){flags|=PS_Export2;}break;case 'e':if(pList->nText==4&&strncmp(pList->zText,"enum",4)==0){if(pList->pNext&&pList->pNext->eType==TT_Braces){pList=pList->pNext;}else{nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}}else if(pList->nText==6&&strncmp(pList->zText,"extern",6)==0){pList=pList->pNext;if(pList&&pList->nText==3&&strncmp(pList->zText,"\"C\"",3)==0){pList=pList->pNext;flags&=~DP_Cplusplus;}else{flags|=PS_Extern;}pStart=pList;}break;case 'i':if(pList->nText==6&&strncmp(pList->zText,"inline",6)==0&&(flags&PS_Static)==0){nErr+=ProcessInlineProc(pList,flags,&resetFlag);}break;case 'L':if(pList->nText==5&&strncmp(pList->zText,"LOCAL",5)==0){flags|=PS_Local2;pStart=pList;}break;case 'P':if(pList->nText==6&&strncmp(pList->zText,"PUBLIC",6)==0){flags|=PS_Public;pStart=pList;}else if(pList->nText==7&&strncmp(pList->zText,"PRIVATE",7)==0){flags|=PS_Private;pStart=pList;}else if(pList->nText==9&&strncmp(pList->zText,"PROTECTED",9)==0){flags|=PS_Protected;pStart=pList;}break;case 's':if(pList->nText==6&&strncmp(pList->zText,"struct",6)==0){if(pList->pNext&&pList->pNext->eType==TT_Braces){pList=pList->pNext;}else{nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}}else if(pList->nText==6&&strncmp(pList->zText,"static",6)==0){flags|=PS_Static;}break;case 't':if(pList->nText==7&&strncmp(pList->zText,"typedef",7)==0){flags|=PS_Typedef;}break;case 'u':if(pList->nText==5&&strncmp(pList->zText,"union",5)==0){if(pList->pNext&&pList->pNext->eType==TT_Braces){pList=pList->pNext;}else{nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}}break;default:break;}if(resetFlag!=0){while(pList&&pList->zText[0]!=resetFlag){pList=pList->pNext;}if(pList==0)goto end_of_loop;pStart=0;flags=presetFlags;}break;case TT_String:case TT_Number:break;default:pStart=pList;flags=presetFlags;break;}pList=pList->pNext;}end_of_loop:while(ifStack){Ifmacro*pIf=ifStack;ifStack=pIf->pNext;fprintf(stderr,"%s:%d:This '#if' has no '#endif'\n",zFilename,pIf->nLine);SafeFree(pIf);}return nErr;}static void InsertExtraDecl(Decl*pDecl){int i;String str;if(pDecl==0||pDecl->zExtra==0||pDecl->zDecl==0)return;i=strlen(pDecl->zDecl)-1;while(i>0&&pDecl->zDecl[i]!='}'){i--;}StringInit(&str);StringAppend(&str,pDecl->zDecl,i);StringAppend(&str,pDecl->zExtra,0);StringAppend(&str,&pDecl->zDecl[i],0);SafeFree(pDecl->zDecl);SafeFree(pDecl->zExtra);pDecl->zDecl=StrDup(StringGet(&str),0);StringReset(&str);pDecl->zExtra=0;}static void ResetDeclFlags(char*zFilename){Decl*pDecl;for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){DeclClearProperty(pDecl,DP_Forward|DP_Declared);if(DeclHasProperty(pDecl,DP_Local)&&pDecl->zFile!=zFilename){DeclSetProperty(pDecl,DP_Forward|DP_Declared);}}}static void ScanText(const char*,GenState*pState);static void ChangeIfContext(const char*zIf,GenState*pState){if(zIf==0){if(pState->zIf==0)return;StringAppend(pState->pStr,"#endif\n",0);pState->zIf=0;}else{if(pState->zIf){if(strcmp(zIf,pState->zIf)==0)return;StringAppend(pState->pStr,"#endif\n",0);pState->zIf=0;}ScanText(zIf,pState);if(pState->zIf!=0){StringAppend(pState->pStr,"#endif\n",0);}StringAppend(pState->pStr,"#if ",0);StringAppend(pState->pStr,zIf,0);StringAppend(pState->pStr,"\n",0);pState->zIf=zIf;}}static void AddIncludes(Include*pInclude,GenState*pState){if(pInclude){if(pInclude->pNext){AddIncludes(pInclude->pNext,pState);}if(IdentTableInsert(pState->pTable,pInclude->zLabel,0)){ChangeIfContext(pInclude->zIf,pState);StringAppend(pState->pStr,"#include ",0);StringAppend(pState->pStr,pInclude->zFile,0);StringAppend(pState->pStr,"\n",1);}}}static void DeclareObject(Decl*pDecl,GenState*pState,int needFullDecl){Decl*p;int flag;int isCpp;int doneTypedef=0;isCpp=(pState->flags&DP_Cplusplus)!=0;for(p=pDecl;p;p=p->pSameName){if(p->zFwd){if(!DeclHasProperty(p,DP_Forward)){DeclSetProperty(p,DP_Forward);if(strncmp(p->zFwd,"typedef",7)==0){if(doneTypedef)continue;doneTypedef=1;}ChangeIfContext(p->zIf,pState);StringAppend(pState->pStr,isCpp?p->zFwdCpp:p->zFwd,0);}}}flag=needFullDecl?DP_Declared|DP_Forward:DP_Forward;for(p=pDecl;p;p=p->pSameName){if(!DeclHasProperty(p,flag))break;}if(p==0){return;}for(p=pDecl;p;p=p->pSameName){AddIncludes(p->pInclude,pState);}for(p=pDecl;p;p=p->pSameName){if(!DeclHasProperty(p,DP_Declared)&&(p->zFwd==0||needFullDecl)&&p->zDecl!=0){DeclSetProperty(p,DP_Forward|DP_Declared|DP_Flag);}else{DeclClearProperty(p,DP_Flag);}}for(p=pDecl;p;p=p->pSameName){if(DeclHasProperty(p,DP_Flag)){if(p->zDecl[0]=='#'){ScanText(&p->zDecl[1],pState);}else{InsertExtraDecl(p);ScanText(p->zDecl,pState);}}}for(p=pDecl;p;p=p->pSameName){if(DeclHasProperty(p,DP_Flag)&&!DeclHasProperty(p,TY_Typedef)){if(DeclHasAnyProperty(p,TY_Enumeration)){if(doneTypedef)continue;doneTypedef=1;}ChangeIfContext(p->zIf,pState);if(!isCpp&&DeclHasAnyProperty(p,DP_ExternReqd)){StringAppend(pState->pStr,"extern ",0);}else if(isCpp&&DeclHasProperty(p,DP_Cplusplus|DP_ExternReqd)){StringAppend(pState->pStr,"extern ",0);}else if(isCpp&&DeclHasAnyProperty(p,DP_ExternCReqd|DP_ExternReqd)){StringAppend(pState->pStr,"extern \"C\" ",0);}InsertExtraDecl(p);StringAppend(pState->pStr,p->zDecl,0);if(!isCpp&&DeclHasProperty(p,DP_Cplusplus)){fprintf(stderr,"%s:C code ought not reference the C++object \"%s\"\n",pState->zFilename,p->zName);pState->nErr++;}DeclClearProperty(p,DP_Flag);}}for(p=pDecl;p&&!doneTypedef;p=p->pSameName){if(DeclHasProperty(p,DP_Flag)){doneTypedef=1;ChangeIfContext(p->zIf,pState);InsertExtraDecl(p);StringAppend(pState->pStr,p->zDecl,0);}}}static void ScanText(const char*zText,GenState*pState){int nextValid=0;InStream sIn;Token sToken;Token sNext;sIn.z=zText;sIn.i=0;sIn.nLine=1;while(sIn.z[sIn.i]!=0){if(nextValid){sToken=sNext;nextValid=0;}else{GetNonspaceToken(&sIn,&sToken);}if(sToken.eType==TT_Id){int needFullDecl;Decl*pDecl;pDecl=FindDecl(sToken.zText,sToken.nText);if(pDecl==0)continue;GetNonspaceToken(&sIn,&sNext);if(sNext.zText[0]=='*'){needFullDecl=0;}else{needFullDecl=1;nextValid=sNext.eType==TT_Id;}DeclareObject(pDecl,pState,needFullDecl);}else if(sToken.eType==TT_Preprocessor){sIn.i-=sToken.nText-1;}}}static void CompleteForwardDeclarations(GenState*pState){Decl*pDecl;int progress;do{progress=0;for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){if(DeclHasProperty(pDecl,DP_Forward)&&!DeclHasProperty(pDecl,DP_Declared)){DeclareObject(pDecl,pState,1);progress=1;assert(DeclHasProperty(pDecl,DP_Declared));}}}while(progress);}static int MakeHeader(InFile*pFile,FILE*report,int nolocal_flag){int nErr=0;GenState sState;String outStr;IdentTable includeTable;Ident*pId;char*zNewVersion;char*zOldVersion;if(pFile->zHdr==0||*pFile->zHdr==0)return 0;sState.pStr=&outStr;StringInit(&outStr);StringAppend(&outStr,zTopLine,nTopLine);sState.pTable=&includeTable;memset(&includeTable,0,sizeof(includeTable));sState.zIf=0;sState.nErr=0;sState.zFilename=pFile->zSrc;sState.flags=pFile->flags&DP_Cplusplus;ResetDeclFlags(nolocal_flag?"no":pFile->zSrc);for(pId=pFile->idTable.pList;pId;pId=pId->pNext){Decl*pDecl=FindDecl(pId->zName,0);if(pDecl){DeclareObject(pDecl,&sState,1);}}CompleteForwardDeclarations(&sState);ChangeIfContext(0,&sState);nErr+=sState.nErr;zOldVersion=ReadFile(pFile->zHdr);zNewVersion=StringGet(&outStr);if(report)fprintf(report,"%s:",pFile->zHdr);if(zOldVersion==0){if(report)fprintf(report,"updated\n");if(WriteFile(pFile->zHdr,zNewVersion)){fprintf(stderr,"%s:Can't write to file\n",pFile->zHdr);nErr++;}}else if(strncmp(zOldVersion,zTopLine,nTopLine)!=0){if(report)fprintf(report,"error!\n");fprintf(stderr,"%s:Can't overwrite this file because it wasn't previously\n""%*s generated by 'makeheaders'.\n",pFile->zHdr,(int)strlen(pFile->zHdr),"");nErr++;}else if(strcmp(zOldVersion,zNewVersion)!=0){if(report)fprintf(report,"updated\n");if(WriteFile(pFile->zHdr,zNewVersion)){fprintf(stderr,"%s:Can't write to file\n",pFile->zHdr);nErr++;}}else if(report){fprintf(report,"unchanged\n");}SafeFree(zOldVersion);IdentTableReset(&includeTable);StringReset(&outStr);return nErr;}static int MakeGlobalHeader(int forExport){GenState sState;String outStr;IdentTable includeTable;Decl*pDecl;sState.pStr=&outStr;StringInit(&outStr);sState.pTable=&includeTable;memset(&includeTable,0,sizeof(includeTable));sState.zIf=0;sState.nErr=0;sState.zFilename="(all)";sState.flags=0;ResetDeclFlags(0);for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){if(forExport==0||DeclHasProperty(pDecl,DP_Export)){DeclareObject(pDecl,&sState,1);}}ChangeIfContext(0,&sState);printf("%s",StringGet(&outStr));IdentTableReset(&includeTable);StringReset(&outStr);return 0;}
#ifdef DEBUG
static int ClipTrailingNewline(char*z){int n=strlen(z);while(n>0&&(z[n-1]=='\n'||z[n-1]=='\r')){n--;}return n;}static void DumpDeclList(void){Decl*pDecl;for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){printf("****%s from file%s****\n",pDecl->zName,pDecl->zFile);if(pDecl->zIf){printf("If:[%.*s]\n",ClipTrailingNewline(pDecl->zIf),pDecl->zIf);}if(pDecl->zFwd){printf("Decl:[%.*s]\n",ClipTrailingNewline(pDecl->zFwd),pDecl->zFwd);}if(pDecl->zDecl){InsertExtraDecl(pDecl);printf("Def:[%.*s]\n",ClipTrailingNewline(pDecl->zDecl),pDecl->zDecl);}if(pDecl->flags){static struct{int mask;char*desc;}flagSet[]={{TY_Class,"class"},{TY_Enumeration,"enum"},{TY_Structure,"struct"},{TY_Union,"union"},{TY_Variable,"variable"},{TY_Subroutine,"function"},{TY_Typedef,"typedef"},{TY_Macro,"macro"},{DP_Export,"export"},{DP_Local,"local"},{DP_Cplusplus,"C++"},};int i;printf("flags:");for(i=0;i<sizeof(flagSet)/sizeof(flagSet[0]);i++){if(flagSet[i].mask&pDecl->flags){printf("%s",flagSet[i].desc);}}printf("\n");}if(pDecl->pInclude){Include*p;printf("includes:");for(p=pDecl->pInclude;p;p=p->pNext){printf("%s",p->zFile);}printf("\n");}}}
#endif
static void DocumentationDump(void){Decl*pDecl;static struct{int mask;char flag;}flagSet[]={{TY_Class,'c'},{TY_Enumeration,'e'},{TY_Structure,'s'},{TY_Union,'u'},{TY_Variable,'v'},{TY_Subroutine,'f'},{TY_Typedef,'t'},{TY_Macro,'m'},{DP_Export,'x'},{DP_Local,'l'},{DP_Cplusplus,'+'},};for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){int i;int nLabel=0;char*zDecl;char zLabel[50];for(i=0;i<sizeof(flagSet)/sizeof(flagSet[0]);i++){if(DeclHasProperty(pDecl,flagSet[i].mask)){zLabel[nLabel++]=flagSet[i].flag;}}if(nLabel==0)continue;zLabel[nLabel]=0;InsertExtraDecl(pDecl);zDecl=pDecl->zDecl;if(zDecl==0)zDecl=pDecl->zFwd;printf("%s%s%s%p%d%d%d%d%d\n",pDecl->zName,zLabel,pDecl->zFile,pDecl->pComment,pDecl->pComment?pDecl->pComment->nText+1:0,pDecl->zIf?(int)strlen(pDecl->zIf)+1:0,zDecl?(int)strlen(zDecl):0,pDecl->pComment?pDecl->pComment->nLine:0,pDecl->tokenCode.nText?pDecl->tokenCode.nText+1:0);if(pDecl->pComment){printf("%.*s\n",pDecl->pComment->nText,pDecl->pComment->zText);}if(pDecl->zIf){printf("%s\n",pDecl->zIf);}if(zDecl){printf("%s",zDecl);}if(pDecl->tokenCode.nText){printf("%.*s\n",pDecl->tokenCode.nText,pDecl->tokenCode.zText);}}}void PrintModuleRecord(const char*zFile,const char*zFilename){int i;static int addr=5;while(isspace(*zFile)){zFile++;}if(*zFile!='/'||zFile[1]!='*')return;for(i=2;zFile[i]&&(zFile[i-1]!='/'||zFile[i-2]!='*');i++){}if(zFile[i]==0)return;printf("%s M%s%d%d 0 0 0 0\n%.*s\n",zFilename,zFilename,addr,i+1,i,zFile);addr+=4;}static InFile*CreateInFile(char*zArg,int*pnErr){int nSrc;char*zSrc;InFile*pFile;int i;zSrc=zArg;for(nSrc=2;zSrc[nSrc]&&zArg[nSrc]!=':';nSrc++){}pFile=SafeMalloc(sizeof(InFile));memset(pFile,0,sizeof(InFile));pFile->zSrc=StrDup(zSrc,nSrc);if(nSrc>2&&zSrc[nSrc-2]=='.'&&(zSrc[nSrc-1]=='c'||zSrc[nSrc-1]=='h')){pFile->flags&=~DP_Cplusplus;}else{pFile->flags|=DP_Cplusplus;}if(zSrc[nSrc]==':'){int nHdr;char*zHdr;zHdr=&zSrc[nSrc+1];for(nHdr=0;zHdr[nHdr];nHdr++){}pFile->zHdr=StrDup(zHdr,nHdr);}else{int foundC=0;pFile->zHdr=StrDup(zSrc,nSrc);for(i=nSrc-1;i>0&&pFile->zHdr[i]!='.';i--){if(pFile->zHdr[i]=='c'){foundC=1;pFile->zHdr[i]='h';}else if(pFile->zHdr[i]=='C'){foundC=1;pFile->zHdr[i]='H';}}if(!foundC){SafeFree(pFile->zHdr);pFile->zHdr=0;}}pFile->flags|=PS_Interface;for(i=nSrc-1;i>0&&zSrc[i]!='.';i--){if(zSrc[i]=='c'||zSrc[i]=='C'){pFile->flags&=~PS_Interface;break;}}return pFile;}static void AddParameters(int index,int*pArgc,char***pArgv){int argc=*pArgc;char**argv=*pArgv;int newArgc;char**zNew=0;char*zFile;int nNew=0;int nAlloc=0;int i;int n;int c;int startOfLine=1;FILE*in;char zBuf[1000];if(index+1==argc)return;zFile=argv[index+1];in=fopen(zFile,"r");if(in==0){fprintf(stderr,"Can't open input file \"%s\"\n",zFile);exit(1);}c=' ';while(c!=EOF){while(c!=EOF&&isspace(c)){if(c=='\n'){startOfLine=1;}c=getc(in);if(startOfLine&&c=='#'){while(c!=EOF&&c!='\n'){c=getc(in);}}}n=0;while(c!=EOF&&!isspace(c)){if(n<sizeof(zBuf)-1){zBuf[n++]=c;}startOfLine=0;c=getc(in);}zBuf[n]=0;if(n>0){nNew++;if(nNew+argc>nAlloc){if(nAlloc==0){nAlloc=100+argc;zNew=malloc(sizeof(char*)*nAlloc);}else{nAlloc*=2;zNew=realloc(zNew,sizeof(char*)*nAlloc);}}if(zNew){int j=nNew+index;zNew[j]=malloc(n+1);if(zNew[j]){strcpy(zNew[j],zBuf);}}}}fclose(in);newArgc=argc+nNew-1;for(i=0;i<=index;i++){zNew[i]=argv[i];}for(i=nNew+index+1;i<newArgc;i++){zNew[i]=argv[i+1-nNew];}zNew[newArgc]=0;*pArgc=newArgc;*pArgv=zNew;}
#ifdef NOT_USED
static unsigned int ModTime(const char*zFilename){unsigned int mTime=0;struct stat sStat;if(stat(zFilename,&sStat)==0){mTime=sStat.st_mtime;}return mTime;}
#endif
static void Usage(const char*argv0,const char*argvN){fprintf(stderr,"%s:Illegal argument \"%s\"\n",argv0,argvN);fprintf(stderr,"Usage:%s [options] filename...\n""Options:\n""-h Generate a single .h to standard output.\n""-H Like-h,but only output EXPORT declarations.\n""-v(verbose)Write status information to the screen.\n""-doc Generate no header files. Instead,output information\n"" that can be used by an automatic program documentation\n"" and cross-reference generator.\n""-local Generate prototypes for \"static\" functions and\n"" procedures.\n""-f FILE Read additional command-line arguments from the file named\n"" \"FILE\".\n"
#ifdef DEBUG
"-!MASK Set the debugging mask to the number \"MASK\".\n"
#endif
"--Treat all subsequent comment-line parameters as filenames,\n"" even if they begin with \"-\".\n",argv0);}static const char zInit[]="#define INTERFACE 0\n""#define EXPORT_INTERFACE 0\n""#define LOCAL_INTERFACE 0\n""#define EXPORT\n""#define LOCAL static\n""#define PUBLIC\n""#define PRIVATE\n""#define PROTECTED\n";
#if TEST==0
int main(int argc,char**argv){int i;int nErr=0;Token*pList;InFile*pFileList=0;InFile*pTail=0;InFile*pFile;int h_flag=0;int H_flag=0;int v_flag=0;int noMoreFlags;FILE*report;noMoreFlags=0;for(i=1;i<argc;i++){if(argv[i][0]=='-'&&!noMoreFlags){switch(argv[i][1]){case 'h':h_flag=1;break;case 'H':H_flag=1;break;case 'v':v_flag=1;break;case 'd':doc_flag=1;proto_static=1;break;case 'l':proto_static=1;break;case 'f':AddParameters(i,&argc,&argv);break;case '-':noMoreFlags=1;break;
#ifdef DEBUG
case '!':i++;debugMask=strtol(argv[i],0,0);break;
#endif
default:Usage(argv[0],argv[i]);return 1;}}else{pFile=CreateInFile(argv[i],&nErr);if(pFile){if(pFileList){pTail->pNext=pFile;pTail=pFile;}else{pFileList=pTail=pFile;}}}}if(h_flag&&H_flag){h_flag=0;}if(v_flag){report=(h_flag||H_flag)?stderr:stdout;}else{report=0;}if(nErr>0){return nErr;}for(pFile=pFileList;pFile;pFile=pFile->pNext){char*zFile;zFilename=pFile->zSrc;if(zFilename==0)continue;zFile=ReadFile(zFilename);if(zFile==0){fprintf(stderr,"Can't read input file \"%s\"\n",zFilename);nErr++;continue;}if(strncmp(zFile,zTopLine,nTopLine)==0){pFile->zSrc=0;}else{if(report)fprintf(report,"Reading%s...\n",zFilename);pList=TokenizeFile(zFile,&pFile->idTable);if(pList){nErr+=ParseFile(pList,pFile->flags);FreeTokenList(pList);}else if(zFile[0]==0){fprintf(stderr,"Input file \"%s\" is empty.\n",zFilename);nErr++;}else{fprintf(stderr,"Errors while processing \"%s\"\n",zFilename);nErr++;}}if(!doc_flag)SafeFree(zFile);if(doc_flag)PrintModuleRecord(zFile,zFilename);}if(nErr>0){return nErr;}
#ifdef DEBUG
if(debugMask&DECL_DUMP){DumpDeclList();return nErr;}
#endif
if(doc_flag){DocumentationDump();return nErr;}zFilename="--internal--";pList=TokenizeFile(zInit,0);if(pList==0){return nErr+1;}ParseFile(pList,PS_Interface);FreeTokenList(pList);if(h_flag||H_flag){nErr+=MakeGlobalHeader(H_flag);}else{for(pFile=pFileList;pFile;pFile=pFile->pNext){if(pFile->zSrc==0)continue;nErr+=MakeHeader(pFile,report,0);}}return nErr;}
#endif
</file>

<file path="tools/think.sh">
#!/usr/bin/env bash
dir=${0%/*}; if [ "$dir" = "$0" ]; then dir="."; fi; cd "$dir"; 
echo $dir

echo "In svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h write the header for a Qt5 QPainter renderer in such a way that code that currently uses QSvg could easily change to use the new implementation. Take clues from the provided codebase which uses Skia."

files=$(find .. -type f \( -name "*.c" -o -name "*.cpp" \))

for file in $files; do
    echo ">> Checking: $file"
    folder=$(dirname "$file")
    filename=$(basename "$file")
    header="$folder/${filename%.*}.h"

    if [ ! -e "$header" ]; then
        echo ">> Making header for: $header"
        tulp -q Generate header file for this code, output only the final code without any formatting: "$(cat "$file")" > "$header"
    fi
done

files=$(find .. -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.h" \))

for file in $files; do
    echo ">> Minifying: $file"
    python3 ./cminify.py "$file" -n -s; 
done;

cd ..

aider svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h svgnative/src/ports/qt/QPainterSVGRenderer.cpp svgnative/include/svgnative/Config.h svgnative/include/svgnative/SVGDocument.h svgnative/include/svgnative/SVGRenderer.h svgnative/include/svgnative/Rect.h svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h svgnative/src/ports/skia/SkiaSVGRenderer.cpp svgnative/example/testSkia/TestSkia.cpp
</file>

<file path=".aider.chat.history.md">
# aider chat started at 2023-07-03 16:02:02

> /Users/adam/Library/Python/3.11/bin/aider svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h svgnative/src/ports/qt/QPainterSVGRenderer.cpp svgnative/include/svgnative/Config.h svgnative/include/svgnative/SVGDocument.h svgnative/include/svgnative/SVGRenderer.h svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h svgnative/src/ports/skia/SkiaSVGRenderer.cpp svgnative/example/testSkia/TestSkia.cpp  
> Model: gpt-4  
> Git repo: .git  
> Repo-map: universal-ctags using 1024 tokens  
> Added svgnative/example/testSkia/TestSkia.cpp to the chat.  
> Added svgnative/include/svgnative/Config.h to the chat.  
> Added svgnative/include/svgnative/SVGDocument.h to the chat.  
> Added svgnative/include/svgnative/SVGRenderer.h to the chat.  
> Added svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h to the chat.  
> Added svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h to the chat.  
> Added svgnative/src/ports/qt/QPainterSVGRenderer.cpp to the chat.  
> Added svgnative/src/ports/skia/SkiaSVGRenderer.cpp to the chat.  
> Use /help to see in-chat commands.  

#### /tokens  
> Approximate context window usage, in tokens:  
> 389 system messages  
> 1,022 repository map                                             use --map-tokens to resize  
> 668 svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h   use /drop to drop from chat  
> 163 svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h use /drop to drop from chat  
> 244 svgnative/include/svgnative/Config.h                       use /drop to drop from chat  
> 1,181 svgnative/include/svgnative/SVGRenderer.h                  use /drop to drop from chat  
> 326 svgnative/include/svgnative/SVGDocument.h                  use /drop to drop from chat  
> 418 svgnative/example/testSkia/TestSkia.cpp                    use /drop to drop from chat  
> 18 svgnative/src/ports/qt/QPainterSVGRenderer.cpp             use /drop to drop from chat  
> 2,840 svgnative/src/ports/skia/SkiaSVGRenderer.cpp               use /drop to drop from chat  
> ========  
> 7,269 tokens total  
> 923 tokens remaining in context window  
> 8,192 tokens max context window size  

#### /add svgnative/include/svgnative/Rect.h  
> Git repo has uncommitted changes.  
> Commit before the chat proceeds [y/n/commit message]? Add files svgnative/include/svgnative/Rect.h to the list of files to be aided in the think.sh script.y  
> Commit 54b566a Add files svgnative/include/svgnative/Rect.h to the list of files to be aided in the think.sh script.y  
> Use up-arrow to retry previous command: /add svgnative/include/svgnative/Rect.h  

# aider chat started at 2023-07-03 19:19:34

> /Users/adam/Library/Python/3.11/bin/aider svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h svgnative/src/ports/qt/QPainterSVGRenderer.cpp svgnative/include/svgnative/Config.h svgnative/include/svgnative/SVGDocument.h svgnative/include/svgnative/SVGRenderer.h svgnative/include/svgnative/Rect.h svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h svgnative/src/ports/skia/SkiaSVGRenderer.cpp svgnative/example/testSkia/TestSkia.cpp  
> Model: gpt-4  
> Git repo: .git  
> Repo-map: universal-ctags using 1024 tokens  
> Added svgnative/example/testSkia/TestSkia.cpp to the chat.  
> Added svgnative/include/svgnative/Config.h to the chat.  
> Added svgnative/include/svgnative/Rect.h to the chat.  
> Added svgnative/include/svgnative/SVGDocument.h to the chat.  
> Added svgnative/include/svgnative/SVGRenderer.h to the chat.  
> Added svgnative/include/svgnative/ports/qt/QPainterSVGRenderer.h to the chat.  
> Added svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h to the chat.  
> Added svgnative/src/ports/qt/QPainterSVGRenderer.cpp to the chat.  
> Added svgnative/src/ports/skia/SkiaSVGRenderer.cpp to the chat.  
> Git repo has uncommitted changes.
</file>

<file path=".aider.input.history">
# 2023-07-03 16:02:07.980333
+/tokens

# 2023-07-03 16:03:46.830383
+/add svgnative/include/svgnative/Rect.h
</file>

<file path="svgnative/example/testC/CMakeLists.txt">
add_executable(testC TestMain.c)

target_link_libraries(testC PUBLIC SVGNativeViewerLib)

if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" OR "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
  target_compile_options(testC PUBLIC -ansi -Wpedantic -Wall -Wextra)
endif()
</file>

<file path="svgnative/example/testCairo/TestCairo.cpp">
/*
Copyright 2019 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/SVGDocument.h"
#include <list>
#include "svgnative/ports/cairo/CairoSVGRenderer.h"
#include "cairo.h"

#if CAIRO_HAS_SCRIPT_SURFACE
#include "cairo-script.h"
#endif
#if CAIRO_HAS_SVG_SURFACE
#include "cairo-svg.h"
#endif
#if CAIRO_HAS_XML_SURFACE
#include "cairo-xml.h"
#endif

#include <fstream>
#include <iostream>
#include <string>
#include <cctype>

void shutdown_cairo_surface(cairo_surface_t* cairo_surface)
{
    cairo_surface_flush(cairo_surface);
    cairo_surface_finish(cairo_surface);
    cairo_surface_destroy(cairo_surface);
}

void shutdown_cairo_device(cairo_device_t* cairo_device)
{
    cairo_device_flush(cairo_device);
    cairo_device_finish(cairo_device);
    cairo_device_destroy(cairo_device);
}

bool try_emit_svg(const char* pathSvg, int width, int height, cairo_surface_t* cairoRecSurface)
{
    assert(pathSvg);
    assert(cairoRecSurface);

#ifndef CAIRO_HAS_SVG_SURFACE
    return false;
#else
    auto cairoSvgSurface = cairo_svg_surface_create(pathSvg, width, height);
    auto cairoSvgCtx = cairo_create(cairoSvgSurface);
    cairo_set_source_surface(cairoSvgCtx, cairoRecSurface, 0, 0);

    /* XXX: it seems that source surface should be destroyed before SVG painting
     *       to prevent leaks ???
     */
    shutdown_cairo_surface(cairoRecSurface);

    cairo_paint(cairoSvgCtx);
    cairo_show_page(cairoSvgCtx);
    cairo_destroy(cairoSvgCtx);
    shutdown_cairo_surface(cairoSvgSurface);

    return true;
#endif
}

bool try_emit_xml(const char* pathXml, cairo_surface_t* cairoRecSurface)
{
    assert(pathXml);
    assert(cairoRecSurface);

#ifndef CAIRO_HAS_XML_SURFACE
    return false;
#else
    auto cairoXmlDev = cairo_xml_create(pathXml);
    cairo_xml_for_recording_surface(cairoXmlDev, cairoRecSurface);
    shutdown_cairo_device(cairoXmlDev);

    return true;
#endif
}

bool try_emit_cairo_script(const char* pathCairoScript, cairo_surface_t* cairoRecSurface)
{
    assert(pathCairoScript);
    assert(cairoRecSurface);

#ifndef CAIRO_HAS_SCRIPT_SURFACE
    return false;
#else
    auto cairoScriptDev = cairo_script_create(pathCairoScript);
    cairo_script_from_recording_surface(cairoScriptDev, cairoRecSurface);
    shutdown_cairo_device(cairoScriptDev);

    return true;
#endif
}

bool try_emit_png(const char* pathPng, cairo_surface_t* cairoRecSurface)
{
    assert(pathPng);
    assert(cairoRecSurface);

#ifndef CAIRO_HAS_PNG_FUNCTIONS
    // TODO: rather than using shortcut PNG function, getting the pixel data and
    //       pack it in specified image format would be better to support various
    //       raster image formats, like JPEG and GIF.

    return false;
#else
    cairo_surface_write_to_png(cairoRecSurface, pathPng);

    return true;
#endif
}

int main(int argc, char* const argv[])
{
    if (argc < 3)
    {
        std::cerr << argv[0] << " <input.svg> <output1.png> [<output2.xml> <output3.cs> <output4.svg> ...]" << std::endl;
        return 0;
    }

    std::string svgInput{};
    std::ifstream input(argv[1]);
    if (!input)
    {
        std::cerr << "Error! Could not open input file." << std::endl;
        exit(EXIT_FAILURE);
    }
    for (std::string line; std::getline(input, line);)
        svgInput.append(line);
    input.close();

    auto renderer = std::make_shared<SVGNative::CairoSVGRenderer>();

    auto doc = std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(), renderer));

    cairo_rectangle_t docExtents{ 0, 0, 0, 0 };
    docExtents.width = doc->Width();
    docExtents.height = doc->Height();

    for (int i = 2; i < argc; i++ )
    {
        std::string outPath = argv[i];
        std::string suffix = outPath.substr(outPath.rfind('.') + 1).c_str();
        std::transform(suffix.begin(), suffix.end(), suffix.begin(), ::tolower);

        cairo_surface_t* cairoRecSurface = cairo_recording_surface_create(CAIRO_CONTENT_COLOR_ALPHA, &docExtents);

        auto cairoRecContext = cairo_create(cairoRecSurface);

        renderer->SetCairo(cairoRecContext);
        doc->Render();
        cairo_destroy(cairoRecContext);

        if (suffix == "svg" && try_emit_svg(outPath.c_str(), doc->Width(), doc->Height(), cairoRecSurface))
            continue;

        if (suffix == "xml" && try_emit_xml(outPath.c_str(), cairoRecSurface))
            continue;

        if (suffix == "cs" && try_emit_cairo_script(outPath.c_str(), cairoRecSurface))
            continue;

        if (suffix == "png" && try_emit_png(outPath.c_str(), cairoRecSurface))
            continue;

        std::cerr << "Specified format " << suffix << " does not match any output format available in linked Cairo" << std::endl;
        shutdown_cairo_surface(cairoRecSurface);
    }

    doc.reset();
    renderer.reset();

    return 0;
}
</file>

<file path="svgnative/example/testGDIPlus/CMakeLists.txt">
add_definitions(-DUNICODE -D_UNICODE)
add_definitions(-D_WIN32_IE=0x0501 -D_WIN32_WINNT=0x0501 -DWINVER=_WIN32_WINNT)

set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO")
add_definitions(/D_CRT_SECURE_NO_WARNINGS)
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /MTd")
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /MT")
set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELEASE} /MT")
set(CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_RELEASE} /MT")
set (SOURCE_FILES
	${CMAKE_CURRENT_SOURCE_DIR}/../../src/Interval.cpp
	${CMAKE_CURRENT_SOURCE_DIR}/../../src/Rect.cpp
)
add_executable("testGDIPlus" WIN32 "TestGDIPlus.cpp" ${SOURCE_FILES})
target_link_libraries("testGDIPlus" PUBLIC SVGNativeViewerLib)
target_include_directories("testGDIPlus" PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../../" "${CMAKE_CURRENT_SOURCE_DIR}/../../ports/gdiplus")
</file>

<file path="svgnative/example/testGDIPlus/TestGDIPlus.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#define WIN32_LEAN_AND_MEAN

#include <tchar.h>
#include <windows.h>
#include <unknwn.h>
#include <Gdiplus.h>
#include <memory>

#include "svgnative/SVGDocument.h"
#include "svgnative/ports/gdiplus/GDIPlusSVGRenderer.h"

/* We need to include the Gdiplus lib */
#pragma comment (lib, "Gdiplus.lib")

using namespace Gdiplus;
using namespace SVGNative;

static HWND hwndMain = NULL;

static const std::string gSVGString = "<svg viewBox=\"0 0 200 200\"><circle cx=\"100\" cy=\"100\" r=\"100\" fill=\"yellow\"/></svg>";

static void
MainWinPaintToCanvas(HDC hdc)
{
    Graphics graphics(hdc);

    auto renderer = std::shared_ptr<GDIPlusSVGRenderer>(new GDIPlusSVGRenderer);
    renderer->SetGraphicsContext(&graphics);

    auto svgDocument = SVGDocument::CreateSVGDocument(gSVGString.c_str(), renderer);
    svgDocument->Render();
}

/* Main window procedure */
static LRESULT CALLBACK
MainWinProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) {
        case WM_PAINT:
        {
            PAINTSTRUCT ps;

            HDC hdc;
            hdc = BeginPaint(hwndMain, &ps);
            MainWinPaintToCanvas(hdc);
            EndPaint(hwndMain, &ps);
            return 0;
        }

        case WM_PRINTCLIENT:
            PostQuitMessage(0);
            return 0;

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int APIENTRY
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    WNDCLASS wc = { 0 };
    MSG msg;

    GdiplusStartupInput gdiplusStartupInput;

    ULONG_PTR gdiplusToken;
    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

    /* Register main window class */
    wc.lpfnWndProc = MainWinProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName = _T("main_window");
    RegisterClass(&wc);

    /* Create main window */
    hwndMain = CreateWindow(
        _T("main_window"), _T("LibWinDraw Example: Simple Draw"),
        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 550, 350,
        NULL, NULL, hInstance, NULL
    );
    SendMessage(hwndMain, WM_SETFONT, (WPARAM) GetStockObject(DEFAULT_GUI_FONT),
            MAKELPARAM(TRUE, 0));
    ShowWindow(hwndMain, nCmdShow);

    /* Message loop */
    while(GetMessage(&msg, NULL, 0, 0)) {
        if(IsDialogMessage(hwndMain, &msg))
            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    GdiplusShutdown(gdiplusToken);

    /* Return exit code of WM_QUIT */
    return (int)msg.wParam;
}
</file>

<file path="svgnative/include/svgnative/ports/gdiplus/GDIPlusSVGRenderer.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_GDIPlusSVGRenderer_h
#define SVGViewer_GDIPlusSVGRenderer_h

#include "svgnative/SVGRenderer.h"
#include <gdiplus.h>
#include <stack>

namespace SVGNative
{
class GDIPlusSVGPath final : public Path
{
public:
    GDIPlusSVGPath();
    ~GDIPlusSVGPath();

    void Rect(float x, float y, float width, float height) override;
    void RoundedRect(float x, float y, float width, float height, float rx, float ry) override;
    void Ellipse(float cx, float cy, float rx, float ry) override;

    void MoveTo(float x, float y) override;
    void LineTo(float x, float y) override;
    void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) override;
    void CurveToV(float x2, float y2, float x3, float y3) override;
    void ClosePath() override;

    const Gdiplus::GraphicsPath& GetGraphicsPath() const;

private:
    Gdiplus::GraphicsPath mPath;
    float mCurrentX{};
    float mCurrentY{};
};

class GDIPlusSVGTransform final : public Transform
{
public:
    GDIPlusSVGTransform(float a, float b, float c, float d, float tx, float ty);

    void Set(float a, float b, float c, float d, float tx, float ty) override;
    void Rotate(float r) override;
    void Translate(float tx, float ty) override;
    void Scale(float sx, float sy) override;
    void Concat(float a, float b, float c, float d, float tx, float ty) override;

    const Gdiplus::Matrix& GetMatrix() const;

private:
    Gdiplus::Matrix mTransform;
};

class GDIPlusSVGImageData final : public ImageData
{
public:
    GDIPlusSVGImageData(const std::string& base64, ImageEncoding encoding);
    ~GDIPlusSVGImageData();

    float Width() const override;
    float Height() const override;

    const std::unique_ptr<Gdiplus::Image>& GetImage() const;

private:
    std::unique_ptr<Gdiplus::Image> mImage;
};

class SVG_IMP_EXP GDIPlusSVGRenderer final : public SVGRenderer
{
public:
    GDIPlusSVGRenderer();

    virtual ~GDIPlusSVGRenderer() 
    { 
    }

    std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding encoding) override;

    std::unique_ptr<Path> CreatePath() override;

    std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) override;

    void Save(const GraphicStyle& graphicStyle) override;
    void Restore() override;

    void DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;
    void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) override;

    void SetGraphicsContext(Gdiplus::Graphics* inContext)
    {
        mContext = inContext;
    }

    void ReleaseGraphicsContext()
    {
        mContext = nullptr;
    }

private:
    std::unique_ptr<Gdiplus::Brush> CreateGradientBrush(const Gradient& gradient, float opacity);

    Gdiplus::Graphics* mContext{};
    std::vector<Gdiplus::GraphicsState> mStateStack;
    std::stack<float> mOpacityStack;
};

} // namespace SVGNative

#endif // SVGViewer_GDIPlusSVGRenderer_h
</file>

<file path="svgnative/include/svgnative/Config.h">
/*
Copyright 2014 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#if defined(SVGNATIVE_USER_CONFIG)
#include SVGNATIVE_USER_CONFIG
#endif
#if (__cplusplus >= 201703L)
#include <cassert>
#endif

#ifndef SVGViewer_Config_h
#define SVGViewer_Config_h

#ifndef SVG_ASSERT
#define SVG_ASSERT(exp) assert(exp);
#endif
#ifndef SVG_ASSERT_MSG
#define SVG_ASSERT_MSG(exp, _message) void();
#endif

#ifndef SVG_PARSE_TRACE
#define SVG_PARSE_TRACE(_message) void();
#endif
#ifndef SVG_DRAW_TRACE
#define SVG_DRAW_TRACE(_message) void();
#endif
#ifndef SVG_CSS_TRACE
#define SVG_CSS_TRACE(_message) void();
#endif

#if defined _MSC_VER || defined __CYGWIN__
	#ifndef DllImport
		#define DllImport __declspec(dllimport)
	#endif
	#ifndef DllExport 
		#define DllExport __declspec(dllexport)
    #endif
#else
	#ifndef DllImport
		#define DllImport
	#endif
	#ifndef DllExport 
		#define DllExport __attribute__((visibility("default")))
	#endif
#endif

#ifdef BUILDING_DLL
	#ifdef SVG_IMPORT
		#define SVG_IMP_EXP DllImport
	#else
		#define SVG_IMP_EXP DllExport
	#endif
#else
	#define SVG_IMP_EXP
#endif

#endif /* SVGViewer_Config_h */
</file>

<file path="svgnative/include/svgnative/Rect.h">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#pragma once

#include "Config.h"

#include <array>
#include <limits>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

namespace SVGNative
{
class Interval;

using IntervalPair = std::tuple<Interval, Interval>;

/**
 * Represents a rectangle.
 *
 * The following points hold true for a Rectangle:
 * 1. A rectangle is simply defined by a pair of two Intervals. The set
 * of a rectangle $R$ defined by two Intervals $A$ and $B$ is the set
 * of all points $(x, y)$ such that $x$ is a member of Interval $A$'s
 * set while $y$ is a member of Interval $B$'s set.
 * 2. A rectangle is empty if its set is of length zero.
 * 3. A rectangle $A$ contains a rectangle $B$ if all points of rectangle
 * $B$'s set are also members of the set of rectangle $A$.
 * 4. The intersection of two rectangles $A$ and $B$ is a rectangle whose
 * set contains the elements that are common in the point set of $A$ and
 * that of $B$.
 * 5. The join of two rectangles $A$ and $B$ is a rectangle with the smallest
 * possible point set such that it has all points of $A$ as well as those of
 * set $B$ and is complete, meaning that for any two points in the set, all
 * the points lying between will also be a part of the set. By smallest we mean
 * that no other proper subset of that set should satisfy this requirement.
 */
class Rect
{
  public:
    Rect() = default;
    Rect(float aX, float aY, float aWidth, float aHeight);
    /**
     * Returns if the rectangle is empty
     */
    bool IsEmpty() const;
    /**
     * Returns the two intervals defining the rectangle
     * Returns true if Rect contains the other Rect within it
     */
    bool Contains(Rect other) const;
    /**
     * Computes the intersection of Rect with the other Rect, meaning a rectangle encompassing area
     * that is common in both.
     */
    Rect operator&(Rect other) const;
    /**
     * Returns true if two rectangles are the same
     */
    bool operator==(Rect other) const;
    /**
     * Computes the join of two rectangles, meaning a bigger rectangle that contains both of those.
     */
    Rect operator|(Rect other) const;
    float Area() const { return width * height; }
    float MaxDiffVertex(Rect other) const;
    float Left() const { return x; }
    float Right() const { return x + width; }
    float Top() const { return y; }
    float Bottom() const { return y + height; }

    float x = std::numeric_limits<float>::quiet_NaN();
    float y = std::numeric_limits<float>::quiet_NaN();
    float width = std::numeric_limits<float>::quiet_NaN();
    float height = std::numeric_limits<float>::quiet_NaN();

  private:
    IntervalPair Intervals() const;
};

} // namespace SVGNative
</file>

<file path="svgnative/script/runTest.py">
#!/usr/bin/python

# Copyright 2019 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

import argparse
import difflib
import fnmatch
import os
import platform
import sys
from subprocess import Popen


class DirectoryIterator:
    def __init__(self, paths, recursive):
        self.files = []
        self.testexpectations = {}
        self.index = -1
        for path in paths:
            (dir, file) = os.path.split(path)
            if os.path.isfile(path):
                self.private_addFile(dir, file)
            elif os.path.isdir(path):
                self.private_walkDir(path, recursive)
            elif os.path.isdir(dir):
                self.private_walkDir(dir, False, file)
            else:
                print("  Invalid path")

    def currentPath(self):
        if self.index < 0 or self.index >= len(self.files):
            return None
        return self.files[self.index]

    def nextPath(self):
        self.index = self.index + 1
        return self.currentPath()

    def fileNum(self):
        return count(self.files)

    def fileArray(self):
        return self.files

    def testExpectations(self):
        return self.testexpectations

    def private_parseTestExpectation(self, testExpectationsPath):
        dirname = os.path.dirname(testExpectationsPath)
        with open(testExpectationsPath) as file:
            for line in file:
                chunks = line.split()
                if not chunks:
                    continue
                if chunks[0] == "#":
                    continue
                testpath = os.path.abspath(os.path.join(dirname, chunks[0]))
                for i, chunk in enumerate(chunks):
                    if chunk == "[":
                        state = chunks[i + 1]
                        self.testexpectations[testpath] = state

    def private_addFile(self, dirname, filename, pattern=None):
        if (
            not self.private_isFileExcluded(filename)
            and self.private_isFileAllowed(filename)
            and (not pattern or fnmatch.fnmatch(filename, pattern))
        ):
            self.files.append(os.path.join(dirname, filename))

    def private_walkDir(self, path, recursive, pattern=None):
        for dirname, subdirnames, filenames in os.walk(path):
            base = os.path.basename(dirname)
            if base.startswith("."):
                continue
            for filename in filenames:
                filepath = os.path.join(dirname, filename)
                if filename == "TestExpectations" and os.path.exists(filepath):
                    print("Found TestExpectations file at: " + filepath)
                    self.private_parseTestExpectation(filepath)
            for filename in filenames:
                filepath = os.path.abspath(os.path.join(dirname, filename))
                if filepath in self.testexpectations and (
                    self.testexpectations[filepath] == "Skip"
                    or self.testexpectations[filepath] == "Crash"
                ):
                    continue
                self.private_addFile(dirname, filename, pattern)
            if not recursive:
                return

    def private_isFileExcluded(self, filename):
        if filename.startswith("."):
            return True
        if filename.endswith(".txt"):
            return True
        for exc in DirectoryIterator.exceptions:
            if filename.find(exc) != -1:
                return True
        return False

    def private_isFileAllowed(self, filename):
        if filename.endswith("svg"):
            return True
        return False

    exceptions = ["-expected.", "-actual.", "-diff."]


def compare_text_files(path_1, path_2, diffpath):
    different = False
    l1 = l2 = " "
    text1_lines = []
    text2_lines = []

    with open(path_1) as f1, open(path_2) as f2:
        while l1 != "" and l2 != "":
            l1 = f1.readline()
            text1_lines.append(l1)
            l2 = f2.readline()
            text2_lines.append(l2)
            if l1 != l2:
                different = True
    if not different:
        return True

    if diffpath != "":
        try:
            os.remove(diffpath)
        except OSError:
            pass  # do nothing, just continue execution, the file probably doesn't exist

    diff = difflib.unified_diff(text1_lines, text2_lines, lineterm="\n")
    file = open(diffpath, "w")
    file.write("".join(list(diff)))
    file.close()

    return False


def readLine(p):
    line = ""
    c = p.stdout.read(1)
    while c:
        if c == "\n" or c == "\r":
            if line:
                return line
        else:
            line += c
        if line == "% ":
            return line
        c = p.stdout.read(1)
    return line


def exportTestFilesSequential(files, args):
    hasError = 0
    while True:
        p = None
        inputFile = files.nextPath()
        if not inputFile or not os.path.exists(inputFile):
            return hasError

        (expectedDir, fname) = os.path.split(inputFile)
        (fbase, fext) = os.path.splitext(fname)

        expectedFile = os.path.abspath(os.path.join(expectedDir, fbase + ".txt"))
        # TODO: preserve sub-dirs
        actualFile = os.path.abspath(os.path.join(args.result_dir, fbase + ".txt"))
        diffFile = os.path.abspath(os.path.join(args.result_dir, fbase + "-diff.txt"))
        elementRef = fbase.startswith("elem-")
        if not os.path.exists(expectedFile):
            if not elementRef:
                p = Popen([args.program, inputFile, expectedFile])
            else:
                p = Popen([args.program, inputFile, expectedFile, "ref"])
            if p is None:
                print("Error opening testapp")
                hasError = -1
                continue
            print("Created missing expectation file: " + expectedFile)
        else:
            if not elementRef:
                p = Popen([args.program, inputFile, actualFile])
            else:
                p = Popen([args.program, inputFile, actualFile, "ref"])
            if p is None:
                print("Error opening testapp")
                hasError = -1
                continue
            p.wait()
            if not compare_text_files(expectedFile, actualFile, diffFile):
                print("   " + inputFile + " FAILED.")
                hasError = -1
            else:
                print("   " + inputFile + " passed.")

    return hasError


def runTestApp(args):
    filesIterator = DirectoryIterator(args.path, args.recursive)
    filesIterator.fileArray()
    filesIterator.testExpectations()

    error = exportTestFilesSequential(filesIterator, args)
    if error == -1:
        return error

    return 0


def main(argv):
    parser = argparse.ArgumentParser(description="Arguments for RunAiTests.")

    parser.add_argument(
        "--program", dest="program", required=False, help="path to test application"
    )
    parser.add_argument(
        "--debug",
        dest="debug",
        action="store_true",
        required=False,
        default=True,
        help="debug build",
    )
    parser.add_argument(
        "--output", dest="result_dir", required=False, help="path for actual results"
    )
    parser.add_argument(
        "--rebase",
        dest="rebase",
        action="store_true",
        default=False,
        help="overwrite all the expected files",
    )
    parser.add_argument(
        "--recursive",
        dest="recursive",
        action="store_true",
        default=False,
        help="walk the directories recursively",
    )
    parser.add_argument(
        "--port",
        dest="port_dir",
        required=False,
        help="expected files directory for specific port",
    )
    parser.add_argument(
        "--tests", dest="path", nargs="+", required=True, help="test files or folders"
    )

    args = parser.parse_args()

    if args.program:
        args.program = os.path.realpath(args.program)
    else:
        plat = ""
        if platform.system() == "Darwin":
            plat = "mac"
        elif platform.system() == "Windows":
            plat = "win64"
        elif platform.system() == "Linux":
            plat = "linux"
        else:
            raise "Unknown platform. Specify path to test application with --path"
        args.program = os.path.relpath(
            os.path.join(
                os.path.dirname(os.path.abspath(__file__)),
                "..",
                "build",
                plat,
                "example",
                "testText",
                ""
                if platform.system() == "Linux"
                else "Debug"
                if args.debug
                else "Release",
                "testSVGNative.exe"
                if platform.system() == "Windows"
                else "testSVGNative",
            )
        )
    print(args.program)
    if not os.path.exists(args.program):
        raise (
            "Test application not found at: "
            + args.program
            + ". Specify correct path with --path."
        )

    # Folder where we save the result to
    if not args.result_dir:
        args.result_dir = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), "..", "viewer", "output"
        )
    if not os.path.isdir(args.result_dir):
        try:
            os.makedirs(args.result_dir)
        except OSError:
            raise "Could not create test result files directory"
    args.result_dir = os.path.relpath(args.result_dir)

    ret = runTestApp(args)
    if ret != 0:
        raise "[ERROR] Unexpected error from testapp"


if __name__ == "__main__":
    main(sys.argv[1:])
</file>

<file path="svgnative/src/ports/d2d/D2DSVGRenderer.cpp">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include <Windows.h>
#include <D2d1.h>
#include <Wincodec.h> // Windows Imaging Component (WIC)

#include "svgnative/Config.h"
#include "svgnative/ports/d2d/D2DSVGRenderer.h"
#include "base64.h"
#include <memory>
#include <stdexcept>

namespace
{
void ThrowIfFailed(HRESULT hr)
{
    if (FAILED(hr))
    {
        std::string msg = "Operation failed with result: " + std::to_string(hr);
        throw std::runtime_error(msg);
    }
}

template <class T>
void ThrowIfNull(CComPtr<T> inComObject)
{
    if (!inComObject)
    {
        throw std::runtime_error("Object is Null");
    }
}

}

namespace SVGNative
{

/******************************************************************************/

D2DSVGPath::D2DSVGPath(CComPtr<ID2D1Factory> inD2DFactory)
{
    inD2DFactory->CreatePathGeometry(&mPath);
    SVG_ASSERT(mPath);
}

D2DSVGPath::~D2DSVGPath()
{
    SVG_ASSERT(mPath);
    ClosePathSink();
    mPath.Release();
}

void D2DSVGPath::AddArc(float x, float y, float rx, float ry)
{
    SVG_ASSERT(mSink);
    mSink->AddArc(
        D2D1::ArcSegment(
            D2D1::Point2F(x, y),
            D2D1::SizeF(rx, ry),
            0,
            D2D1_SWEEP_DIRECTION_CLOCKWISE,
            D2D1_ARC_SIZE_SMALL
        )
    );
}

void D2DSVGPath::ClosePathSink()
{
    if (mHasOpenFigure)
    {
        SVG_ASSERT(mSink);
        mSink->EndFigure(D2D1_FIGURE_END_OPEN);
        mHasOpenFigure = false;
    }
    if (mSink)
    {
        mSink->Close();
        mSink.Release();
    }
}

void D2DSVGPath::Rect(float x, float y, float w, float h)
{
    MoveTo(x, y);
    LineTo(x + w, y);
    LineTo(x + w, y + h);
    LineTo(x, y + h);
    ClosePath();
}

void D2DSVGPath::RoundedRect(float x, float y, float w, float h, float rx, float ry)
{
    MoveTo(x + rx, y);
    LineTo(x + w - rx, y);
    AddArc(x + w, y + ry, rx, ry);
    LineTo(x + w, y + h - ry);
    AddArc(x + w - rx, y + h, rx, ry);
    LineTo(x + rx, y + h);
    AddArc(x, y + h - ry, rx, ry);
    LineTo(x, y + ry);
    AddArc(x + rx, y, rx, ry);
    ClosePath();
}

void D2DSVGPath::Ellipse(float cx, float cy, float rx, float ry)
{
    MoveTo(cx, cy - ry);
    AddArc(cx, cy + ry, rx, ry);
    AddArc(cx, cy - ry, rx, ry);
    ClosePath();
}

void D2DSVGPath::MoveTo(float x, float y)
{
    if (mHasOpenFigure)
    {
        SVG_ASSERT(mSink);
        mSink->EndFigure(D2D1_FIGURE_END_OPEN);
        mHasOpenFigure = false;
    }
    if (!mSink)
        mPath->Open(&mSink);
    SVG_ASSERT(mSink);
    mSink->BeginFigure(
            D2D1::Point2F(x, y),
            D2D1_FIGURE_BEGIN_FILLED
        );
    mHasOpenFigure = true;
    mCurrentX = x;
    mCurrentY = y;
}

void D2DSVGPath::LineTo(float x, float y)
{
    if (!mHasOpenFigure)
        MoveTo(x, y);
    mSink->AddLine(D2D1::Point2F(x, y));
    mCurrentX = x;
    mCurrentY = y;
}

void D2DSVGPath::CurveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{
    SVG_ASSERT(mSink);
    if (!mHasOpenFigure)
        MoveTo(x1, y1);
    mSink->AddBezier(
        D2D1::BezierSegment(
            D2D1::Point2F(x1, y1),
            D2D1::Point2F(x2, y2),
            D2D1::Point2F(x3, y3))
        );
    mCurrentX = x3;
    mCurrentY = y3;
}

void D2DSVGPath::CurveToV(float x2, float y2, float x3, float y3)
{
    float cx1 = static_cast<float>(mCurrentX + 2.0 / 3.0 * (x2 - mCurrentX));
    float cy1 = static_cast<float>(mCurrentY + 2.0 / 3.0 * (y2 - mCurrentY));
    float cx2 = static_cast<float>(x3 + 2.0 / 3.0 * (x2 - x3));
    float cy2 = static_cast<float>(y3 + 2.0 / 3.0 * (y2 - y3));
    CurveTo(cx1, cy1, cx2, cy2, x3, y3);
}

void D2DSVGPath::ClosePath()
{
    SVG_ASSERT(mSink);
    mSink->EndFigure(D2D1_FIGURE_END_CLOSED);
    mHasOpenFigure = false;
    mSink->Close();
    mSink.Release();
}

CComPtr<ID2D1PathGeometry> D2DSVGPath::GetGraphicsPath()
{
    ClosePathSink();
    return mPath;
}

/******************************************************************************/

D2DSVGTransform::D2DSVGTransform(float a, float b, float c, float d, float tx, float ty)
{
    mTransform = D2D1::Matrix3x2F{a, b, c, d, tx, ty};
}

void D2DSVGTransform::Set(float a, float b, float c, float d, float tx, float ty)
{
    mTransform = D2D1::Matrix3x2F{ a, b, c, d, tx, ty };
}

void D2DSVGTransform::Rotate(float r)
{
    mTransform = D2D1::Matrix3x2F::Rotation(r) * mTransform;
}

void D2DSVGTransform::Translate(float tx, float ty)
{
    mTransform = D2D1::Matrix3x2F::Translation(tx, ty) * mTransform;
}

void D2DSVGTransform::Scale(float sx, float sy)
{
    mTransform = D2D1::Matrix3x2F::Scale(sx, sy) * mTransform;
}

void D2DSVGTransform::Concat(float a, float b, float c, float d, float tx, float ty)
{
    mTransform = D2D1::Matrix3x2F{a, b, c, d, tx, ty} * mTransform;
}

const D2D1::Matrix3x2F& D2DSVGTransform::GetMatrix() const
{
    return mTransform;
}

D2DSVGImageData::D2DSVGImageData(CComPtr<IWICBitmapSource> bitmapSource)
    : mBitmapSource(bitmapSource)
{
    if (mBitmapSource)
    {
        UINT width = 0;
        UINT height = 0;
        ThrowIfFailed(mBitmapSource->GetSize(&width, &height));
        mWidth = static_cast<float>(width);
        mHeight = static_cast<float>(height);
    }
}

D2DSVGImageData::~D2DSVGImageData()
{
}

float D2DSVGImageData::Width() const
{
    return mWidth;
}

float D2DSVGImageData::Height() const
{
    return mHeight;
}

CComPtr<IWICBitmapSource> D2DSVGImageData::GetBitmapSource() const
{
    return mBitmapSource;
}

D2DSVGRenderer::D2DSVGRenderer()
{
}

std::unique_ptr<ImageData> D2DSVGRenderer::CreateImageData(const std::string& base64, ImageEncoding encoding)
{
    std::string imageString = base64_decode(base64);
    CComPtr<IStream> stream{ SHCreateMemStream((const BYTE*)imageString.c_str(), (UINT)imageString.size()) };
    ThrowIfNull(stream);

    CComPtr<IWICBitmapDecoder> imgDecoder;
    ThrowIfFailed(
        mWICFactory->CreateDecoderFromStream(stream, nullptr, WICDecodeMetadataCacheOnDemand, &imgDecoder));

    CComPtr<IWICBitmapFrameDecode> frame;
    ThrowIfFailed(imgDecoder->GetFrame(0, &frame));

    // Convert to a format that Direct2D can use (pre-multiplied BRGA is best)
    CComPtr<IWICFormatConverter> converter;
    ThrowIfFailed(mWICFactory->CreateFormatConverter(&converter));
    ThrowIfFailed(converter->Initialize(
        frame,
        GUID_WICPixelFormat32bppPBGRA,
        WICBitmapDitherTypeNone,
        nullptr,
        0.0,
        WICBitmapPaletteTypeMedianCut));

    // Keep a BitmapSource and not an ID2D1Bitmap because the latter is tied to a specific ID2D1RenderTarget.
    CComPtr<IWICBitmapSource> bitmapSource = converter;
    return std::unique_ptr<D2DSVGImageData>(new D2DSVGImageData(bitmapSource));
}

std::unique_ptr<Path> D2DSVGRenderer::CreatePath()
{
    return std::unique_ptr<D2DSVGPath>(new D2DSVGPath{mD2DFactory});
}

std::unique_ptr<Transform> D2DSVGRenderer::CreateTransform(float a, float b, float c, float d, float tx, float ty)
{
    return std::unique_ptr<D2DSVGTransform>(new D2DSVGTransform(a, b, c, d, tx, ty));
}

void D2DSVGRenderer::Save(const GraphicStyle& graphicStyle)
{
    CComPtr<ID2D1Geometry> maskPath;
    D2D1_MATRIX_3X2_F maskTransform = D2D1::IdentityMatrix();
    if (graphicStyle.clippingPath)
    {
        if (graphicStyle.clippingPath->transform)
            maskTransform = dynamic_cast<D2DSVGTransform*>(graphicStyle.clippingPath->transform.get())->GetMatrix();
        const auto constPath = dynamic_cast<const D2DSVGPath*>(graphicStyle.clippingPath->path.get());
        maskPath = const_cast<D2DSVGPath*>(constPath)->GetGraphicsPath();
    }

    CComPtr<ID2D1Layer> layer;
    mContext->CreateLayer(&layer);
    mContext->PushLayer(
        D2D1::LayerParameters(
            D2D1::InfiniteRect(),
            maskPath,
            D2D1_ANTIALIAS_MODE_PER_PRIMITIVE,
            maskTransform,
            graphicStyle.opacity
        ),
        layer);

    // FIXME: May need to get applied before creating the layer to apply to clipping path.
    D2D1_MATRIX_3X2_F transform;
    mContext->GetTransform(&transform);
    mContextTransform.push(transform);
    if (graphicStyle.transform)
    {
        D2D1_MATRIX_3X2_F gsTransform = dynamic_cast<D2DSVGTransform*>(graphicStyle.transform.get())->GetMatrix();
        mContext->SetTransform(gsTransform * transform);
    }
}

void D2DSVGRenderer::Restore()
{
    mContext->SetTransform(mContextTransform.top());
    mContextTransform.pop();
    mContext->PopLayer();
}

inline D2D1_EXTEND_MODE D2DSpreadMethod(SpreadMethod spreadMethod)
{
    switch (spreadMethod)
    {
    case SpreadMethod::kReflect:
        return D2D1_EXTEND_MODE_MIRROR;
    case SpreadMethod::kRepeat:
        return D2D1_EXTEND_MODE_WRAP;
    case SpreadMethod::kPad:
    default:
        return D2D1_EXTEND_MODE_CLAMP;
    }
}

inline D2D1_CAP_STYLE D2DCapStyle(LineCap lineCap)
{
    switch (lineCap)
    {
    case LineCap::kRound:
        return D2D1_CAP_STYLE_ROUND;
    case LineCap::kSquare:
        return D2D1_CAP_STYLE_SQUARE;
    case LineCap::kButt:
    default:
        return D2D1_CAP_STYLE_FLAT;
    }
}

inline D2D1_LINE_JOIN D2DLineJoin(LineJoin lineJoin)
{
    switch (lineJoin)
    {
    case LineJoin::kRound:
        return D2D1_LINE_JOIN_ROUND;
    case LineJoin::kBevel:
        return D2D1_LINE_JOIN_BEVEL;
    case LineJoin::kMiter:
    default:
        return D2D1_LINE_JOIN_MITER;
    }
}

CComPtr<ID2D1Brush> D2DSVGRenderer::CreateBrush(const Paint& paint)
{
    SVG_ASSERT(mContext);
    CComPtr<ID2D1Brush> brush;
    if (SVGNative::holds_alternative<Color>(paint))
    {
        const auto& color = SVGNative::get<Color>(paint);
        CComPtr<ID2D1SolidColorBrush> solidColorBrush;
        mContext->CreateSolidColorBrush({color[0], color[1], color[2], color[3]}, &solidColorBrush);
        solidColorBrush->QueryInterface(&brush);
    }
    else if (SVGNative::holds_alternative<Gradient>(paint))
    {
        const auto& gradient = SVGNative::get<Gradient>(paint);
        std::vector<D2D1_GRADIENT_STOP> colorsStops;
        for (const auto& stop : gradient.colorStops)
        {
            const auto& color = stop.second;
            colorsStops.push_back({ stop.first, { color[0], color[1], color[2], color[3] } });
        }
        CComPtr<ID2D1GradientStopCollection> gradientStopCollection;
        mContext->CreateGradientStopCollection(
            colorsStops.data(),
            static_cast<UINT32>(colorsStops.size()),
            D2D1_GAMMA_2_2,
            D2DSpreadMethod(gradient.method),
            &gradientStopCollection);
        if (gradient.type == GradientType::kLinearGradient)
        {
            CComPtr<ID2D1LinearGradientBrush> linearGradientBrush;
            mContext->CreateLinearGradientBrush(
                D2D1::LinearGradientBrushProperties(
                    D2D1::Point2F(gradient.x1, gradient.y1),
                    D2D1::Point2F(gradient.x2, gradient.y2)),
                gradientStopCollection,
                &linearGradientBrush);
            if (gradient.transform)
                linearGradientBrush->SetTransform(std::static_pointer_cast<D2DSVGTransform>(gradient.transform)->GetMatrix());
            linearGradientBrush->QueryInterface(&brush);
        }
        else
        {
            CComPtr<ID2D1RadialGradientBrush> radialGradientBrush;
            mContext->CreateRadialGradientBrush(
                D2D1::RadialGradientBrushProperties(
                    D2D1::Point2F(gradient.cx, gradient.cy),
                    D2D1::Point2F(gradient.fx, gradient.fy),
                    gradient.r,
                    gradient.r),
                gradientStopCollection,
                &radialGradientBrush);
            if (gradient.transform)
                radialGradientBrush->SetTransform(std::static_pointer_cast<D2DSVGTransform>(gradient.transform)->GetMatrix());
            radialGradientBrush->QueryInterface(&brush);
        }
    }
    else
    {
        SVG_ASSERT_MSG(false, "Unknown paint type");
    }
    return brush;
}

void D2DSVGRenderer::DrawPath(const Path& renderPath, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    SVG_ASSERT(mContext);

    Save(graphicStyle);

    const auto& constPath = dynamic_cast<const D2DSVGPath&>(renderPath);
    auto path = const_cast<D2DSVGPath&>(constPath).GetGraphicsPath();
    if (fillStyle.hasFill)
    {
        auto brush = CreateBrush(fillStyle.paint);
        mContext->FillGeometry(path, brush, nullptr);
        brush.Release();
    }
    if (strokeStyle.hasStroke)
    {
        auto lineCap = D2DCapStyle(strokeStyle.lineCap);
        auto lineJoin = D2DLineJoin(strokeStyle.lineJoin);

        auto brush = CreateBrush(strokeStyle.paint);

        SVG_ASSERT(mD2DFactory);
        CComPtr<ID2D1StrokeStyle> d2dStrokeStyle;
        mD2DFactory->CreateStrokeStyle(
            D2D1::StrokeStyleProperties(
                lineCap,
                lineCap,
                lineCap,
                lineJoin,
                strokeStyle.miterLimit,
                D2D1_DASH_STYLE_CUSTOM,
                strokeStyle.dashOffset),
            strokeStyle.dashArray.data(),
            static_cast<UINT32>(strokeStyle.dashArray.size()),
            &d2dStrokeStyle);
        
        mContext->DrawGeometry(
            path,
            brush,
            strokeStyle.lineWidth,
            d2dStrokeStyle);

        d2dStrokeStyle.Release();
        brush.Release();
    }

    Restore();
}

void D2DSVGRenderer::DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea)
{
    const D2DSVGImageData& imageData(dynamic_cast<const D2DSVGImageData&>(image));
    CComPtr<IWICBitmapSource> bitmapSource = imageData.GetBitmapSource();
    if (bitmapSource)
    {
        CComPtr<ID2D1Bitmap> bitmap;
        ThrowIfFailed(mContext->CreateBitmapFromWicBitmap(bitmapSource, &bitmap));

        SVG_ASSERT(mContext);
        Save(graphicStyle);
        D2D1_RECT_F clipRect{};
        if (clipArea.width < fillArea.width || clipArea.height < fillArea.height)
        {
            clipRect = D2D1::RectF(clipArea.x, clipArea.y, clipArea.x + clipArea.width, clipArea.y + clipArea.height);
            CComPtr<ID2D1Layer> layer;
            mContext->CreateLayer(&layer);
            mContext->PushLayer(
                D2D1::LayerParameters(clipRect),
                layer
            );
        }

        D2D1_RECT_F drawRect = D2D1::RectF(fillArea.x, fillArea.y, fillArea.x + fillArea.width, fillArea.y + fillArea.height);
        mContext->DrawBitmap(bitmap, drawRect);

        if (clipRect.right > clipRect.left)
        {
            mContext->PopLayer();
        }

        Restore();
    }
}

} // namespace SVGNative
</file>

<file path="svgnative/src/xml/ExpatXMLParser.cpp">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "xml/XMLParser.h"
#include "Config.h"

#include <expat.h>
#include <map>
#include <stack>
#include <string>
#include <string.h>

namespace SVGNative
{
namespace xml
{
    class ExpatXMLNode final : public XMLNode {
    public:
        ExpatXMLNode()
        {}

        const char* GetName() const override
        {
            return mName.c_str();
        }

        const char* GetValue() const override
        {
            // Not implemented.
            return nullptr;
        }

        std::unique_ptr<XMLNode> GetFirstNode() override
        {
            return std::move(mChild);
        }

        std::unique_ptr<XMLNode> GetNextSibling() override
        {
            return std::move(mSibling);
        }

        Attribute GetAttribute(const char* attrName, const char* xmlNSPrefix) const override
        {
            auto it = mAttributes.find(attrName);
            if (it != mAttributes.end())
                return {true, it->second.c_str()};
            if (xmlNSPrefix)
            {
                std::string newAttrName{xmlNSPrefix};
                newAttrName.append(":");
                newAttrName.append(attrName);
                it = mAttributes.find(newAttrName);
                if (it != mAttributes.end())
                    return {true, it->second.c_str()};
            }
            return {false, {}};
        }

    private:
        friend class ExpatXMLDocument;

        std::string mName;
        std::map<std::string, std::string> mAttributes;
        std::unique_ptr<ExpatXMLNode> mChild;
        std::unique_ptr<ExpatXMLNode> mSibling;
    };

    class ExpatXMLDocument final : public XMLDocument {
    public:
        static std::unique_ptr<XMLDocument> CreateXMLDocument(const char* documentString)
        {
            auto newDocument = new ExpatXMLDocument(documentString);
            return std::unique_ptr<XMLDocument>(newDocument);
        }

        ~ExpatXMLDocument()
        {
        }

        std::unique_ptr<XMLNode> GetFirstNode() override
        {
            return std::move(mRootNode);
        }
    
    private:
        ExpatXMLDocument(const char* documentString)
        {
            XML_Parser parser = XML_ParserCreate(nullptr);
            XML_SetUserData(parser, this);
            XML_SetElementHandler(parser, this->StartElement, this->EndElement);
            int done{0};
            if (XML_Parse(parser, documentString, (int)strlen(documentString), done) == XML_STATUS_ERROR || done)
            {
                mXMLNodeStack = {};
                mRootNode.reset();
            }
            mPreviousSilbingXMLNode = nullptr;
            SVG_ASSERT_MSG(mXMLNodeStack.empty(), "element stack not empty");
            XML_ParserFree(parser);
        }

        static void XMLCALL StartElement(void* userData, const XML_Char* name, const XML_Char** attrs)
        {
            auto node = new ExpatXMLNode{};
            node->mName = name;
            auto& attributes = node->mAttributes;
            while (*attrs)
            {
                auto attrName = *attrs++;
                if (!*attrs)
                    break;
                auto attrValue = *attrs++;
                auto it = attributes.find(attrName);
                if (it == attributes.end())
                    attributes.insert({attrName, attrValue});
            }

            auto document = static_cast<ExpatXMLDocument*>(userData);
            if (document->mXMLNodeStack.empty())
                document->mRootNode = std::unique_ptr<ExpatXMLNode>(node);
            else
            {
                if (document->mStartNodeCalled)
                    document->mXMLNodeStack.top()->mChild = std::unique_ptr<ExpatXMLNode>(node);
                else
                    document->mPreviousSilbingXMLNode->mSibling = std::unique_ptr<ExpatXMLNode>(node);
            }
            document->mXMLNodeStack.push(node);
            document->mStartNodeCalled = true;
        }

        static void XMLCALL EndElement(void* userData, const XML_Char* /*name*/)
        {
            auto document = static_cast<ExpatXMLDocument*>(userData);
            document->mPreviousSilbingXMLNode = document->mXMLNodeStack.top();
            document->mXMLNodeStack.pop();
            document->mStartNodeCalled = false;
        }

    private:
        bool mStartNodeCalled{false};

        // These members have no ownership of the pointers.
        std::stack<ExpatXMLNode*> mXMLNodeStack;
        ExpatXMLNode* mPreviousSilbingXMLNode{};

        std::unique_ptr<ExpatXMLNode> mRootNode;
    };

    std::unique_ptr<XMLDocument> XMLDocument::CreateXMLDocument(const char* documentString)
    {
        return ExpatXMLDocument::CreateXMLDocument(documentString);
    }
} // namespace xml
} // namespace SVGNative
</file>

<file path="svgnative/src/xml/LibXMLParser.cpp">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "xml/XMLParser.h"

#include <libxml/tree.h>
#include <libxml/parser.h>

namespace SVGNative
{
namespace xml
{
    class LibXMLNode final : public XMLNode {
    public:
        LibXMLNode(xmlNode* node)
            : mNode{node}
        {}

        const char* GetName() const override
        {
            if (!mNode)
                return nullptr;
            return (const char*)(mNode->name);
        }

        const char* GetValue() const override
        {
            if (!mNode)
                return nullptr;
            return (const char*)(mNode->content);
        }

        std::unique_ptr<XMLNode> GetFirstNode() override
        {
            if (!mNode)
                return nullptr;
            auto children = mNode->children;
            while (children && children->type != XML_ELEMENT_NODE)
                children = children->next;
            if (children)
            {
                auto newNode = new LibXMLNode{children};
                return std::unique_ptr<XMLNode>(newNode);
            }
            return nullptr;
        }

        std::unique_ptr<XMLNode> GetNextSibling() override
        {
            if (!mNode)
                return nullptr;
            
            auto nextSibling = mNode->next;
            while (nextSibling && nextSibling->type != XML_ELEMENT_NODE)
                nextSibling = nextSibling->next;

            if (nextSibling)
            {
                auto newNode = new LibXMLNode{nextSibling};
                return std::unique_ptr<XMLNode>(newNode);
            }
            return nullptr;
        }

        Attribute GetAttribute(const char* attrName, const char*) const override
        {
            if (!mNode)
                return {false, nullptr};

            auto attr = xmlHasProp(mNode, (const xmlChar*)attrName);
            if (attr)
                return {true, (const char*)xmlGetProp(mNode, (const xmlChar*)(attrName))};

            return {false, nullptr};
        }
    private:
        xmlNode* mNode{};
    };

    class LibXMLDocument final : public XMLDocument {
    public:
        static std::unique_ptr<XMLDocument> CreateXMLDocument(const char* documentString)
        {
            auto newDocument = new LibXMLDocument(documentString);
            return std::unique_ptr<XMLDocument>(newDocument);
        }

        LibXMLDocument(const char* documentString)
        {
            mDocument = xmlReadDoc((const xmlChar*)documentString, nullptr, nullptr, XML_PARSE_RECOVER);
        }

        ~LibXMLDocument()
        {
            xmlFreeDoc(mDocument);
            xmlCleanupParser();
        }

        std::unique_ptr<XMLNode> GetFirstNode() override
        {
            if (!mDocument)
                return nullptr;
            if (auto firstNode = xmlDocGetRootElement(mDocument))
            {
                auto newNode = new LibXMLNode{firstNode};
                return std::unique_ptr<XMLNode>(newNode);
            }
            return nullptr;
        }
    private:
        xmlDocPtr mDocument{};
    };

    std::unique_ptr<XMLDocument> XMLDocument::CreateXMLDocument(const char* documentString)
    {
        return LibXMLDocument::CreateXMLDocument(documentString);
    }
} // namespace xml
} // namespace SVGNative
</file>

<file path="svgnative/src/xml/RapidXMLParser.cpp">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "xml/XMLParser.h"

#include <boost/property_tree/detail/xml_parser_read_rapidxml.hpp>

namespace SVGNative
{
namespace xml
{
    class RapidXMLNode final : public XMLNode {
    public:
        RapidXMLNode(const boost::property_tree::detail::rapidxml::xml_node<>* node)
            : mNode{node}
        {}

        const char* GetName() const override
        {
            if (!mNode)
                return nullptr;
            return mNode->name();
        }

        const char* GetValue() const override
        {
            if (!mNode)
                return nullptr;
            return mNode->value();
        }

        std::unique_ptr<XMLNode> GetFirstNode() override
        {
            if (!mNode)
                return nullptr;
            if (const auto firstChild = mNode->first_node())
            {
                auto newNode = new RapidXMLNode{firstChild};
                return std::unique_ptr<XMLNode>(newNode);
            }
            return nullptr;
        }
        std::unique_ptr<XMLNode> GetNextSibling() override
        {
            if (!mNode)
                return nullptr;
            if (const auto nextSibling = mNode->next_sibling())
            {
                auto newNode = new RapidXMLNode{nextSibling};
                return std::unique_ptr<XMLNode>(newNode);
            }
            return nullptr;
        }

        Attribute GetAttribute(const char* attrName, const char* nsPrefix) const override
        {
            if (!mNode)
                return {false, nullptr};

            if (const auto attr = mNode->first_attribute(attrName))
                return {true, attr->value()};
            if (nsPrefix)
            {
                std::string newAttrName = nsPrefix;
                newAttrName.append(":");
                newAttrName.append(attrName);
                if (const auto attr = mNode->first_attribute(newAttrName.c_str()))
                    return {true, attr->value()};
            }
            return {false, nullptr};
        }
    private:
        const boost::property_tree::detail::rapidxml::xml_node<>* mNode;
    };

    class RapidXMLDocument final : public XMLDocument {
    public:
        static std::unique_ptr<XMLDocument> CreateXMLDocument(const char* documentString)
        {
            auto newDocument = new RapidXMLDocument(documentString);
            return std::unique_ptr<XMLDocument>(newDocument);
        }

        RapidXMLDocument(const char* documentString)
        {
            mDocument.parse<0>((char*)documentString);
        }

        ~RapidXMLDocument()
        {
            mDocument.clear();
        }

        std::unique_ptr<XMLNode> GetFirstNode() override
        {
            if (const auto firstNode = mDocument.first_node())
            {
                auto newNode = new RapidXMLNode{firstNode};
                return std::unique_ptr<XMLNode>(newNode);
            }
            return nullptr;
        }
    private:
        boost::property_tree::detail::rapidxml::xml_document<> mDocument;
    };

    std::unique_ptr<XMLDocument> XMLDocument::CreateXMLDocument(const char* documentString)
    {
        return RapidXMLDocument::CreateXMLDocument(documentString);
    }
} // namespace xml
} // namespace SVGNative
</file>

<file path="svgnative/src/xml/XMLParser.h">
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#pragma once

#include <memory>

namespace SVGNative
{
namespace xml
{
    struct Attribute
    {
        Attribute(bool aFound, const char* aValue)
            : found{aFound}
            , value{aValue}
        {}
        bool found{false};
        const char* value{};
    };

    class XMLNode {
    public:

        virtual const char* GetName() const = 0;
        virtual const char* GetValue() const = 0;

        // Both functions will never get called more than once per XMLNode!
        // Deriving parsers may optimize for this scenario in the implementation.
        // Hence those functions are not const.
        virtual std::unique_ptr<XMLNode> GetFirstNode() = 0;
        virtual std::unique_ptr<XMLNode> GetNextSibling() = 0;

        virtual Attribute GetAttribute(const char*, const char* nsPrefix = nullptr) const = 0;

        virtual ~XMLNode() {}
    };

    class XMLDocument {
    public:
        static std::unique_ptr<XMLDocument> CreateXMLDocument(const char* documentString);
        virtual std::unique_ptr<XMLNode> GetFirstNode() = 0;

        virtual ~XMLDocument() {}
    };
} // namespace xml

} // namespace SVGNative
</file>

<file path="svgnative/src/DeprecatedSVGDocumentImpl.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifdef STYLE_SUPPORT
#include "SVGDocumentImpl.h"
#include "svgnative/SVGDocument.h"
#include "xml/XMLParser.h"

using namespace SVGNative::xml;

namespace SVGNative
{
void SVGDocumentImpl::AddCustomCSS(const StyleSheet::CssDocument* cssDocument) { mOverrideStyle = cssDocument; }

void SVGDocumentImpl::ClearCustomCSS()
{
    const auto elements = mCustomCSSInfo.getElements();
    for (const auto& element : elements)
        mCustomCSSInfo.removeElement(element.getSelector());
    mOverrideStyle = nullptr;
}

void SVGDocumentImpl::ParseStyle(const XMLNode* child)
{
    SVG_ASSERT(mCSSInfo.getElements().size() == 0); // otherwise we need to merge with existing mCSSInfo

    // StyleSheet Library expects one definition per line, so we need to
    // format the string accordingly.
    std::string styleSheet = std::string(child->GetValue());

    SVG_CSS_TRACE("ParseStyle INPUT:\n" << styleSheet);

    // strip out all line breaks
    boost::replace_all(styleSheet, "\r\n", " ");
    boost::replace_all(styleSheet, "\r", " ");
    boost::replace_all(styleSheet, "\n", " ");
    // trim whitespace from head & tail of string
    boost::trim(styleSheet);
    // put each definition on its own line
    boost::replace_all(styleSheet, "} ", "}\n");

    SVG_CSS_TRACE("ParseStyle CLEANED:\n" << styleSheet);

    std::string output;

    boost::tokenizer<boost::char_separator<char>> cssLines(styleSheet, boost::char_separator<char>("\n"));
    for (boost::tokenizer<boost::char_separator<char>>::iterator it = cssLines.begin(); it != cssLines.end(); ++it)
    {
        std::string cssLine{*it};
        boost::trim(cssLine);

        if (cssLine.find(",") == std::string::npos)
        {
            output.append(cssLine);
            output.append("\n");
        }
        else
        {
            auto dataStart = cssLine.find("{");
            std::string cssData(cssLine.substr(dataStart, cssLine.find("}") - dataStart + 1));

            std::string cssClasses(cssLine.substr(0, dataStart));

            boost::tokenizer<boost::char_separator<char>> cssClassTokens(cssClasses, boost::char_separator<char>(","));
            for (boost::tokenizer<boost::char_separator<char>>::iterator itc = cssClassTokens.begin(); itc != cssClassTokens.end(); ++itc)
            {
                output.append(*itc);
                output.append(" ");
                output.append(cssData);
                output.append("\n");
            }
        }
    }

    SVG_CSS_TRACE("ParseStyle OUTPUT:\n" << output);

    // parse style sheet
    mCSSInfo = StyleSheet::CssDocument::parse(output);
}

void SVGDocumentImpl::ApplyCSSStyle(
    const std::set<std::string>& classNames, GraphicStyleImpl& graphicStyle, FillStyleImpl& fillStyle, StrokeStyleImpl& strokeStyle)
{
    if (!mOverrideStyle)
        return;

    for (const auto& className : classNames)
    {
        auto selector = StyleSheet::CssSelector::CssClassSelector(className);
        if (!mOverrideStyle->hasSelector(selector))
            continue;

        auto cssElement = mOverrideStyle->getElement(selector);
        auto properties = cssElement.getProperties();
        ParseGraphicsProperties(graphicStyle, properties);
        ParseFillProperties(fillStyle, properties);
        ParseStrokeProperties(strokeStyle, properties);
    }
}

void SVGDocumentImpl::ParseStyleAttr(const XMLNode* node, std::vector<PropertySet>& propertySets, std::set<std::string>& classNames)
{
    auto attr = node->GetAttribute("style");
    if (attr.found)
    {
        auto cssDoc = StyleSheet::CssDocument::parse(attr.value);
        auto cssElements = cssDoc.getElements();
        if (!cssElements.empty())
        {
            propertySets.push_back(cssElements.front().getProperties());
        }
    }
    // Warning: The inheritance order is incorrect but required by current clients at this point.
    // The code is going to get removed once clients do no longer use "<style>" or
    // override styles.
    attr = node->GetAttribute("class");
    if (attr.found)
    {
        boost::char_separator<char> sep("\n\r\t ");
        std::string cssString = attr.value;
        boost::tokenizer<boost::char_separator<char>> tok(cssString, sep);
        for (boost::tokenizer<boost::char_separator<char>>::iterator it = tok.begin(); it != tok.end(); ++it)
        {
            classNames.insert(*it);
            auto selector = StyleSheet::CssSelector::CssClassSelector(*it);
            auto cssElement = mCSSInfo.getElement(selector);
            propertySets.push_back(cssElement.getProperties());
        }
    }
}

} // namespace SVGNative
#endif
</file>

<file path="svgnative/src/Rect.cpp">
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/Rect.h"
#include "Interval.h"

#include <cmath>
#include <stdexcept>
#include <tuple>

namespace SVGNative
{
    Rect::Rect(float aX, float aY, float aWidth, float aHeight)
    {
        if (aWidth < 0 || aHeight < 0)
        {
            throw std::invalid_argument("Height or Width of a rectangle can't be negative!");
        }
        x = aX;
        y = aY;
        width = aWidth;
        height = aHeight;
    }
    bool Rect::IsEmpty() const
    {
        IntervalPair rectIntervals = Intervals();
        return std::get<0>(rectIntervals).IsEmpty() || std::get<1>(rectIntervals).IsEmpty();
    }
    bool Rect::Contains(Rect other) const
    {
        IntervalPair thisIntervals = Intervals();
        IntervalPair otherIntervals = other.Intervals();
        return std::get<0>(thisIntervals).Contains(std::get<0>(otherIntervals)) &&
            std::get<1>(thisIntervals).Contains(std::get<1>(otherIntervals));
    }
    bool Rect::operator==(Rect other) const
    {
        return x == other.x && y == other.y && width == other.width && height == other.height;
    }
    Rect Rect::operator&(Rect other) const
    {
        IntervalPair intervalsA = Intervals();
        IntervalPair intervalsB = other.Intervals();
        Interval resultX = std::get<0>(intervalsA) & std::get<0>(intervalsB);
        Interval resultY = std::get<1>(intervalsA) & std::get<1>(intervalsB);
        if (resultX.IsEmpty() || resultY.IsEmpty())
            return Rect{0, 0, 0, 0};
        return Rect(resultX.Min(), resultY.Min(), resultX.Max() - resultX.Min(), resultY.Max() - resultY.Min());
    }
    Rect Rect::operator|(Rect other) const
    {
        IntervalPair intervalsA = Intervals();
        IntervalPair intervalsB = other.Intervals();
        Interval resultX = std::get<0>(intervalsA) | std::get<0>(intervalsB);
        Interval resultY = std::get<1>(intervalsA) | std::get<1>(intervalsB);
        if (resultX.IsEmpty() || resultY.IsEmpty())
            return Rect{0, 0, 0, 0};
        return Rect(resultX.Min(), resultY.Min(), resultX.Max() - resultX.Min(), resultY.Max() - resultY.Min());
    }
    float Rect::MaxDiffVertex(Rect other) const
    {
        float topLeftDiff = std::sqrt(std::pow(Left() - other.Left(), 2) + std::pow(Top() - other.Top(), 2));
        float topRightDiff = std::sqrt(std::pow(Right() - other.Right(), 2) + std::pow(Top() - other.Top(), 2));
        float bottomLeftDiff = std::sqrt(std::pow(Left() - other.Left(), 2) + std::pow(Bottom() - other.Bottom(), 2));
        float bottomRightDiff = std::sqrt(std::pow(Right() - other.Right(), 2) + std::pow(Bottom() - other.Bottom(), 2));
	float max1 = std::max(topLeftDiff, topRightDiff);
	float max2 = std::max(bottomLeftDiff, bottomRightDiff);
	return std::max(max1,max2);
    }

    IntervalPair Rect::Intervals() const { return IntervalPair(Interval(x, x + width), Interval(y, y + height)); }
}
</file>

<file path="svgnative/test/clipping.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(40,0,40,40) clipping: { winding: nonzero [path Ellipse(60,20,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(80,0,40,40) clipping: { winding: nonzero [path Ellipse(100,20,20,15)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(120,0,40,40) clipping: { winding: nonzero [path RoundedRect(130,10,20,20,5,5)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(160,0,40,40) clipping: { winding: nonzero [path M180,10 L190,35 L170,35]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,40,40,40) clipping: { winding: nonzero [path M20,50 L30,75 L10,75]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(40,40,40,40) clipping: { winding: nonzero transform: matrix(1,0,0,1,40,40) [path Ellipse(20,20,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(120,40,40,40) clipping: { winding: nonzero [path Ellipse(140,60,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(160,40,40,40) clipping: { winding: nonzero [path Ellipse(180,60,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,80,40,40) clipping: { winding: nonzero [path Ellipse(20,100,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(40,80,40,40) clipping: { winding: nonzero [path Ellipse(60,100,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(80,80,40,40) clipping: { winding: evenodd [path Ellipse(100,100,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(120,80,40,40) clipping: { winding: evenodd [path Ellipse(140,100,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(160,80,40,40) clipping: { winding: nonzero [path Ellipse(180,100,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,40,40) transform: matrix(1,0,0,1,0,120) clipping: { winding: nonzero [path Ellipse(20,20,20,20)]}
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/dash-array.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path M0,5 L200,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 20 20 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,10 L200,10
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,15 L200,15
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 20 0 0 0 10 20 0 0 0 10 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,20 L200,20
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 0.99 0.99 0.99 0.99 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,25 L200,25
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 5 1.33 8 5 1.33 8 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,30 L200,30
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 7.56 7.56 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,35 L200,35
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 9.9 20 10 0.9 0.9 9.9 20 10 0.9 0.9 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,40 L200,40
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dash: 14.1 28.3 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,100 L200,100
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,105 L200,105
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,110 L200,110
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,115 L200,115
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 5 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,130 L200,130
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 5 paint: rgba(0,0,0,1)}]
            [path M0,135 L200,135
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 5 paint: rgba(0,0,0,1)}]
            [path M0,140 L200,140
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 6.67 paint: rgba(0,0,0,1)}]
            [path M0,145 L200,145
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 16 paint: rgba(0,0,0,1)}]
            [path M0,150 L200,150
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 41.6 paint: rgba(0,0,0,1)}]
            [path M0,155 L200,155
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 41.6 paint: rgba(0,0,0,1)}]
            [path M0,160 L200,160
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 14.1 paint: rgba(0,0,0,1)}]
            [path M0,165 L200,165
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 90 paint: rgba(0,0,0,1)}]
            [path M0,170 L200,170
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 90 paint: rgba(0,0,0,1)}]
            [path M0,175 L200,175
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: 2 paint: rgba(0,0,0,1)}]
            [path M0,180 L200,180
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: -300 paint: rgba(0,0,0,1)}]
            [path M0,185 L200,185
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dash: 20 10 dashOffset: -3 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/elem-defs.txt">
[group transform: matrix(1,0,0,1,0,0)
    [path Rect(0,0,200,200)
        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
]
</file>

<file path="svgnative/test/elem-transform-on-parent.svg">
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g transform="rotate(45)">
        <rect id="ref" width="200" height="200" fill="green" />
    </g>
</svg>
</file>

<file path="svgnative/test/gradient.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,0,150,10)
                fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,10,150,10)
                fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,20,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0,1,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,30,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    radialGradient: cx: 75 cy: 125 fx: 75 fy: 125 r: 146 method: pad stops: {
                        offset: 0 rgba(0,0,1,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,40,150,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,1,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,50,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0,0,0)
                        offset: 0.25 rgba(0.0588,0.941,0,0.25)
                        offset: 0.75 rgba(0,0.0588,0.941,0.75)
                        offset: 1 rgba(0,0,1,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,60,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    radialGradient: cx: 75 cy: 125 fx: 75 fy: 125 r: 146 method: pad stops: {
                        offset: 0 rgba(0,0,0,1)
                        offset: 0.75 rgba(0.0588,0.941,0,1)
                        offset: 0.75 rgba(0,1,0,1)
                        offset: 0.75 rgba(0,0.0588,0.941,1)
                        offset: 1 rgba(0,0,1,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,70,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    radialGradient: cx: 75 cy: 125 fx: 75 fy: 125 r: 146 method: pad stops: {
                        offset: 0 rgba(0,0,1,1)
                        offset: 0.25 rgba(0,0,1,1)
                        offset: 0.75 rgba(0,1,0,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,80,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 15 y1: 15 x2: 185 y2: 185 method: pad stops: {
                        offset: 0 rgba(0,1,0,1)
                        offset: 1 rgba(0,0.867,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,90,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 185 method: pad stops: {
                        offset: 0 rgba(0,1,0,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,100,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 5 y1: 5 x2: 195 y2: 195 method: reflect stops: {
                        offset: 0 rgba(0,1,0,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,110,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    radialGradient: transform: matrix(2,0,0,2,40,0) cx: 50 cy: 50 fx: 50 fy: 50 r: 25 method: pad stops: {
                        offset: 0 rgba(0,1,0,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,120,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    radialGradient: cx: 75 cy: 125 fx: 75 fy: 125 r: 146 method: pad stops: {
                        offset: 0 rgba(0,1,0,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,130,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0.502,0,1)
                        offset: 1 rgba(0,0,1,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,140,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0.502,0,1)
                        offset: 1 rgba(0,0,1,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,150,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0.502,0,1)
                        offset: 1 rgba(0,0,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,160,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0.502,0,1)
                        offset: 1 rgba(0,0.502,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,170,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0.502,0,1)
                        offset: 1 rgba(0,0.502,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,180,150,10)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,190,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0.502,0,1)
                        offset: 1 rgba(0,0.502,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/image.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [group transform: matrix(1,0,0,1,20,40)
                [image clip(0, 0, 30, 40) fill(0, 0, 30, 40)  (PNG) iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==]
            ]
            [group transform: matrix(1,0,0,1,10,120)
                [path Rect(0.5,0.5,49,29)
                    fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            ]
            [group transform: matrix(1,0,0,1,20,190)
                [path Rect(0.5,0.5,29,59)
                    fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            ]
            [group transform: matrix(1,0,0,1,100,60)
                [group
                    [image clip(0, 0, 50, 30) fill(0, 0, 50, 30)  (PNG) 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]
                    [path Rect(0.5,0.5,49,29)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,70,0)
                    [image clip(0, 0, 50, 30) fill(0, 0, 50, 30)  (PNG) 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]
                    [path Rect(0.5,0.5,49,29)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,0,70)
                    [image clip(0, 0, 50, 30) fill(0, 0, 50, 30)  (PNG) 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]
                    [path Rect(0.5,0.5,49,29)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
            ]
            [group transform: matrix(1,0,0,1,250,60)
                [group
                    [image clip(0, 0, 30, 60) fill(0, 0, 30, 60)  (PNG) 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]
                    [path Rect(0.5,0.5,29,59)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,50,0)
                    [image clip(0, 0, 30, 60) fill(0, 0, 30, 60)  (PNG) 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]
                    [path Rect(0.5,0.5,29,59)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,100,0)
                    [image clip(0, 0, 30, 60) fill(0, 0, 30, 60)  (PNG) iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==]
                    [path Rect(0.5,0.5,29,59)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
            ]
            [group transform: matrix(1,0,0,1,100,220)
                [group
                    [image clip(0, 0, 30, 60) fill(0, 0, 30, 60)  (PNG) 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]
                    [path Rect(0.5,0.5,29,59)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,50,0)
                    [image clip(0, 0, 30, 60) fill(0, 0, 30, 60)  (PNG) iVBORw0KGgoAAAANSUhEUgAAAH0AAACoCAYAAADNc+G5AAAACXBIWXMAAC4jAAAuIwF4pT92AAAHn0lEQVR4Xu2bQXLkOBAD2RF6zz5mPrxP0xzGjm631QIgsgoUybms0xYqWYXzPvb9/72UUkp5lFJK2b/o+e/o9+zvor6tzSvf1uaVb2vz3LePfS/7vj/Kvn//4VEYLuVR9v2M+VmII2dnurw3e/LGDsFD+azKka5eikBZlc9md1m69ziZLj6rcpPSvcfJdPFZlSNdys1W6amz+3DdpHQ+i9i7Rx+uitL5ByFWHlzL87g+f/uxdO+DR3XxWcQ1e6zShSxi7x68q9PS+Sxi7x59uoTS+QchrnmwyvO4+OwqXZiFOHJ2S9f2/OX7kOtDEXtdfFblSFfLm3VSOp9VOdLlvdl110np/BCVI10tj4PY6+Kz75xSuvc4mS4+q3JL1yq9gnNnt3NNUDqfRezdo53LVDqfRRx5nFFdG/ORypEPntfFZxGv0gXOnR3nGrB0PovYu0ecK6l0PqtypCuziEzX7UrPPI7XxWdVblK69ziZLj6rcqTrffYApfNZlSNdzpsFlc5nVY50OYvIdHVfuvM4uS4+q3KT0r3HGdXFZxGjPVbppy4+i9i7x0++Yel8FrF3D5+rUel8FjF6sDIL8Tyun99SpXsfPKqLzyJW91ilp83ux3WD0vmsypEu783OXRdL5x+kcqRLPU4Ne13nWXvp3uNkuvisyqrrsHTvcTJdfFblSFftzTosnc+qHOny3kxzkaXzD1I50lV7HIW9Lj6774bSvccZ1cVn9/2rdO+DR3XxWcSt95isdD6L2LtHnauD0vksYu8e93F9KF0bkvng5dKyR7xKv8i5s9u6Bi+dz6oc6Yq+maF0PqtypCu6iEzXxnxUw60ffD57VBefZbh56d7jZLr4rMqRrlKGK53Pqhzpyr5ZQul8VuVIV3YRma5blZ59nFFd1aVnP3gOF59FfLTHKp128VnE3j1uXzqfRezdI9cVUDqfRew+zpiuopfuffCoLj6LmNljlZ4wO9PF3OxmpfNZlSNd3pv9djUonc+qHOlijsPOQux1/f62q9K9x8l08VmVGRcs3XucTBefVTnSdeVmnZfOZ1WOdHlvhl3TlO7doy/XhdL5ByG+8uCrPI8LZ3+V7n3wqC4+i7jFHhOXzmcRe/fQXZ2VzmcRe/fo20WUjoew3OLBLM/j4rPfvEpvwJGzI1yb9ziZLj6rcqQr4mZf/39626H8AnxW5UhXRBGZroPScegqt3gwP3tUF5/9xKGle4+T6eKzKke4Bi6dz6oc6cq42SqdYO8e7V3JpfNZxBnHGdW1vQ5kQ84Hz+fis4i/Z2+vH6AQYu9xMl18FrFjj4FK57OIvXvEu4JL57OIHccZ1bVK787FZ1VuUrr3OJkuPqtypOvTzW5cOp9VOdLlvdk/blw6n1U50tVDEUxW5U+zuy3de5xMF59VuUnp3uOM6uKziNk9Vunps/2uG5XOZxF79/C7KkvnH4SYfXALnsd1/O1p6d4Hj+ris4iv7rFKF7OIvXtwro5L57OIvXv05xJL5x+kcqTr6nGusNfFZW2le4+T6eKzKl91bT9/+T7k2lCGvS4+q3Kkq9XNOiqdz6oc6fLe7JoLlM4NucKRrlbHYdjr4rOvnFa69zijuvjsK6/SKzl3dhvXJKXzWcTePdq4jKXzWcRRxxnVtTEfXeGoB8/t4rNnvEoXOXd2jGvQ0vmsypGurJslls5nVY50ZRWR6bpl6VnH8bv4rMLNSvceJ9PFZ1WOdL3OHqR0PqtypMt1s8DS+azKkS5XEZmuW5TuOs6orsulux48tovPIj7bY5UOXXwWsXePJ9+0dD6L2LuHx9WwdD6LuJfjoKzKXtfzZ7p074NHdfFZxMoeq/TA2Zku5WY3KZ3Pqhzp8t7ss6uidP5BKke6lOPUstf1+dsuSvceJ9PFZ1VWXB9L9x4n08VnVY501dys09L5rMqRLu/NeNfwpXv36NMllM4/CHHNg1Wex8Vnt+cvnQ8e1cVnEbfcY8LS+Sxi7x7XXZ2UzmcRe/e4h+ukdH4I4pYPRjyPi8++8yq9giNnR7omKJ3PqhzpiryZqXQ+q3KkK7KITNfGfFTLLR+MZ4/q4rOIQ0r3HifTxWdVjnQNWDqfVTnSlXmzVbo0ewxXUul8FnHmcUZ1NSk988HzuPgs4vfZq3TJxWcRO/cYoHQ+i9i7R54rqHQ+i9h5nFFdq/RuXHxW5Sale4+T6eKzKke60M1uWDqfVTnS5b3ZT25UOp9VOdKFjqPMQux1/fy2u9K9x8l08VmVkYsq3XucTBefVTnSpd5slZ42ux/XDUrns4i9e/Tjulg6/yDE6oNreB7XefawdO+DR3XxWcS1e0xeOp9F7N1Dc3VYOp9F7N2jXxdZOv8glSNdtcdR2Ovis/tuKN17nEwXn1W51rUdD6kbqj0408VnVY50tb5ZB6XzWZUjXd6b1bk+lK4NUTjS1fo4/br47BGHl+49zqguPnvEq/SLnDu7rWvw0vksYu8ebV2G0vks4ujjjOramI8Ujn7wnC4+i7iUVTrNubNjXYOVzmcRe/eIdSWUzmdVjnRlF5HnKmX78+e/su+llPL9x98///vv68/o2+t/V77l/q58W/t35dvavyvfPsrrv78x98C7+TTMeAAAAABJRU5ErkJggg==]
                    [path Rect(0.5,0.5,29,59)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,100,0)
                    [image clip(0, 0, 30, 60) fill(0, 0, 30, 60)  (PNG) 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]
                    [path Rect(0.5,0.5,29,59)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
            ]
            [group transform: matrix(1,0,0,1,250,220)
                [group
                    [image clip(0, 0, 50, 30) fill(0, 0, 50, 30)  (PNG) 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]
                    [path Rect(0.5,0.5,49,29)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,70,0)
                    [image clip(0, 0, 50, 30) fill(0, 0, 50, 30)  (PNG) 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]
                    [path Rect(0.5,0.5,49,29)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
                [group transform: matrix(1,0,0,1,140,0)
                    [image clip(0, 0, 50, 30) fill(0, 0, 50, 30)  (PNG) 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]
                    [path Rect(0.5,0.5,49,29)
                        fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                        stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
            ]
        ]
    ]
]
</file>

<file path="svgnative/test/paint.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200" color="blue">
    <rect x="0" y="0" width="20" height="20" fill="#008000" stroke="#008000"/>
    <rect x="20" y="0" width="20" height="20" fill="     #008000" stroke="     #008000"/>
    <rect x="40" y="0" width="20" height="20" fill="     #008000
    " stroke="     #008000
    "/>
    <rect x="60" y="0" width="20" height="20" fill="#080" stroke="#080"/>
    <rect x="80" y="0" width="20" height="20" fill="    #080" stroke="    #080"/>
    <rect x="100" y="0" width="20" height="20" fill="    #080
    " stroke="    #080
    "/>
    <rect x="120" y="0" width="20" height="20" fill="green" stroke="green"/>
    <rect x="140" y="0" width="20" height="20" fill="    green" stroke="    green"/>
    <rect x="160" y="0" width="20" height="20" fill="    green
    " stroke="    green
    "/>
    <rect x="180" y="0" width="20" height="20" fill="    green   " stroke="    green   "/>
    <rect x="0" y="20" width="20" height="20" fill="greenInvalid" stroke="greenInvalid"/>
    <rect x="20" y="20" width="20" height="20" fill="rgb(0, 128, 0)" stroke="rgb(0, 128, 0)"/>
    <rect x="40" y="20" width="20" height="20" fill="rgb(01280)" stroke="rgb(01280)"/>
    <rect x="60" y="20" width="20" height="20" fill="rgb(0  , 128    ,
     0)" stroke="rgb(0  , 128    ,
     0)"/>
    <g fill="#008000" stroke="#008000">
        <rect x="120" y="20" width="20" height="20"/>
    </g>
    <rect x="180" y="20" width="20" height="20" color="#008000" fill="currentColor" stroke="currentColor"/>
    <g color="#008000">
        <rect x="40" y="40" width="20" height="20" fill="currentColor" stroke="currentColor"/>
    </g>
    <g color="#008000">
        <rect x="60" y="40" width="20" height="20"/>
    </g>
    <g fill="#008000" stroke="#008000">
        <rect x="80" y="40" width="20" height="20" fill="invalid" stroke="invalid"/>
    </g>
    <g fill="#008000" stroke="#008000">
        <rect x="100" y="40" width="20" height="20" fill="initial" stroke="initial"/>
    </g>
    <g fill="#008000" stroke="#008000">
        <rect x="120" y="40" width="20" height="20" fill="inherited" stroke="inherited"/>
    </g>
    <rect x="140" y="40" width="20" height="20" fill="#F00 red" stroke="#F00 red"/>
    <rect x="160" y="40" width="20" height="20" fill="#F00 #F00" stroke="#F00 #F00"/>
    <rect x="180" y="40" width="20" height="20" fill="url(#notPresent) #008000" stroke=" url(#notPresent) #008000"/>
    <rect x="0" y="60" width="20" height="20" fill=" url(#notPresent) green" stroke="url(#notPresent) green"/>
    <rect x="20" y="60" width="20" height="20" fill="url(#notPresent) none" stroke="url(#notPresent) none"/>
    <rect x="40" y="60" width="20" height="20" fill="url(#notPresent) #008000 #008000" stroke="url(#notPresent) #008000 #008000"/>
    <rect x="60" y="60" width="20" height="20" fill="#F00 url(#notPresent)" stroke="#F00 url(#notPresent)"/>
    <rect x="80" y="60" width="20" height="20" fill="url(#notPresent), #F00" stroke="url(#notPresent), #F00"/>
    <rect x="80" y="60" width="20" height="20" fill="url(#notPresent)#F00" stroke="url(#notPresent)#F00"/>

    <!-- var(): invalid -->
    <rect x="100" y="60" width="20" height="20" fill="var(test-green)" stroke="var(test-green)"/>
    <rect x="120" y="60" width="20" height="20" fill="var(invalid, #F00)" stroke="var(invalid, #F00)"/>
    <rect x="140" y="60" width="20" height="20" fill="var(--missingComma #F00)" stroke="var(--missingComma #F00)"/>
    <rect x="160" y="60" width="20" height="20" fill="var(--missingName)" stroke="var(--missingName)"/>
    <rect x="180" y="60" width="20" height="20" fill="var(--test-green, url(#grad))" stroke="var(--test-green, url(#grad))"/>

    <!-- var() passes. Color defined in source code -->
    <rect x="0" y="80" width="20" height="20" fill="var(--missingName, #008000)" stroke="var(--missingName, #008000)"/>
    <rect x="20" y="80" width="20" height="20" fill="var(--test-green)" stroke="var(--test-green)"/>
    <rect x="40" y="80" width="20" height="20" fill="var(--test-green, #F00)" stroke="var(--test-green, #F00)"/>
    <rect x="60" y="80" width="20" height="20" fill="  var(   --test-green
        , #F00  )" stroke="var(--test-green, #F00)"/>

    <!-- Inheritance from SVG root -->
    <rect x="100" y="80" width="20" height="20" fill="currentColor" stroke="currentColor"/>

    <!-- var(): testing fallback colors -->
    <rect x="80" y="80" width="20" height="20" fill="var(--missingName, green)" stroke="var(--missingName, green)"/>
    <rect x="80" y="80" width="20" height="20" fill="var(--missingName, rgb(0, 128, 0))" stroke="var(--missingName, rgb(0, 128, 0))"/>
    <rect x="80" y="80" width="20" height="20" fill="var(--test-green, var(--missingName, #008000))" stroke="var(--test-green, var(--missingName, #008000))"/>
</svg>
</file>

<file path="svgnative/test/paint.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(20,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(40,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(60,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.533,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.533,0,1)}]
            [path Rect(80,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.533,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.533,0,1)}]
            [path Rect(100,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.533,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.533,0,1)}]
            [path Rect(120,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(140,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(160,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(180,0,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(0,20,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(20,20,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(40,20,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(60,20,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [group
                [path Rect(120,20,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            ]
            [path Rect(180,20,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [group
                [path Rect(40,40,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            ]
            [group
                [path Rect(60,40,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                    stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            ]
            [group
                [path Rect(80,40,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            ]
            [group
                [path Rect(100,40,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            ]
            [group
                [path Rect(120,40,20,20)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            ]
            [path Rect(140,40,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(160,40,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(180,40,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(0,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(20,60,20,20)
                fill: {hasFill: false winding: nonzero paint: rgba(0,0,0,0)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,0)}]
            [path Rect(40,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(60,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(80,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(80,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(100,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(120,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(140,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(160,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(180,60,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(20,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(40,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(60,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(100,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,1,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,1,1)}]
            [path Rect(80,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(80,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
            [path Rect(80,80,20,20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0.502,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/properties.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="250" viewBox="0 0 150 250">
    <!-- stroke-miterlimit -->
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="4"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="1"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="0.5e2"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="  0.5e2"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="  
    0.5e2  "/>

    <!-- stroke-miterlimit: negative tests -->
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="-4"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="0"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="0.99"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="2e-2"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="2px"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="2pc"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="2pt"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="2mm"/>
    <line x1="5" y1="5" x2="145" y2="5" stroke-miterlimit="2cm"/>

    <!-- stroke-opacity -->
    <line x1="5" y1="10" x2="145" y2="10" stroke="black" stroke-opacity="-4"/>
    <line x1="5" y1="13" x2="145" y2="13" stroke="black" stroke-opacity="4"/>
    <line x1="5" y1="16" x2="145" y2="16" stroke="black" stroke-opacity="2e-1"/>
    <line x1="5" y1="19" x2="145" y2="19" stroke="black" stroke-opacity="   
    2e-1  "/>
    <line x1="5" y1="22" x2="145" y2="22" stroke="black" stroke-opacity="20%"/>

    <!-- stroke-opacity: negative tests -->
    <line x1="5" y1="22" x2="145" y2="22" stroke="black" stroke-opacity="2px"/>
    <line x1="5" y1="22" x2="145" y2="22" stroke="black" stroke-opacity="2pc"/>
    <line x1="5" y1="22" x2="145" y2="22" stroke="black" stroke-opacity="2pt"/>
    <line x1="5" y1="22" x2="145" y2="22" stroke="black" stroke-opacity="2mm"/>
    <line x1="5" y1="22" x2="145" y2="22" stroke="black" stroke-opacity="2cm"/>

    <!-- opacity -->
    <rect x="5" y="30" width="140" height="2" opacity="-4"/>
    <rect x="5" y="33" width="140" height="2" opacity="4"/>
    <rect x="5" y="36" width="140" height="2" opacity="2e-1"/>
    <rect x="5" y="39" width="140" height="2" opacity="   
    2e-1  "/>
    <rect x="5" y="40" width="140" height="2" opacity="20%"/>

    <!-- opacity: negative tests -->
    <rect x="5" y="40" width="140" height="2" opacity="2px"/>
    <rect x="5" y="40" width="140" height="2" opacity="2pc"/>
    <rect x="5" y="40" width="140" height="2" opacity="2pt"/>
    <rect x="5" y="40" width="140" height="2" opacity="2mm"/>
    <rect x="5" y="40" width="140" height="2" opacity="2cm"/>

    <!-- fill-opacity -->
    <rect x="5" y="30" width="140" height="2" fill-opacity="-4"/>
    <rect x="5" y="33" width="140" height="2" fill-opacity="4"/>
    <rect x="5" y="36" width="140" height="2" fill-opacity="2e-1"/>
    <rect x="5" y="39" width="140" height="2" fill-opacity="   
    2e-1  "/>
    <rect x="5" y="42" width="140" height="2" fill-opacity="20%"/>

    <!-- fill-opacity: negative tests -->
    <rect x="5" y="42" width="140" height="2" fill-opacity="2px"/>
    <rect x="5" y="42" width="140" height="2" fill-opacity="2pc"/>
    <rect x="5" y="42" width="140" height="2" fill-opacity="2pt"/>
    <rect x="5" y="42" width="140" height="2" fill-opacity="2mm"/>
    <rect x="5" y="42" width="140" height="2" fill-opacity="2cm"/>

    <!-- stroke-width -->
    <line x2="200" y1="50" y2="50" stroke="black" stroke-width="3"/>
    <line x2="200" y1="55" y2="55" stroke="black" stroke-width="3px"/>
    <line x2="200" y1="60" y2="60" stroke="black" stroke-width="1.5pt"/>
    <line x2="200" y1="65" y2="65" stroke="black" stroke-width="1pc"/>
    <line x2="200" y1="70" y2="70" stroke="black" stroke-width="1.1mm"/>
    <line x2="200" y1="75" y2="75" stroke="black" stroke-width="0.12cm"/>
    <line x2="200" y1="80" y2="80" stroke="black" stroke-width="1%"/>
    <line x2="200" y1="85" y2="85" stroke="black" stroke-width=".9e1"/>
    <line x2="200" y1="90" y2="90" stroke="black" stroke-width="   
    .9e1   "/>
    <line x2="200" y1="95" y2="95" stroke="black" stroke-width="2000.0e-3"/>

    <!-- stroke-width: reset stroke -->
    <line x2="200" y1="100" y2="100" stroke="black" stroke-width="0"/>

    <!-- stroke-width: negative tests -->
    <line x2="200" y1="105" y2="105" stroke="black" stroke-width="-3.0e2"/>
    <line x2="200" y1="105" y2="105" stroke="black" stroke-width="-300.0e-2"/>
</svg>
</file>

<file path="svgnative/test/properties.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 1 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 50 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 50 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 50 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,5 L145,5
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,10 L145,10
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 opacity: 0 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,13 L145,13
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,16 L145,16
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 opacity: 0.2 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,19 L145,19
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 opacity: 0.2 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,22 L145,22
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 opacity: 0.2 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,22 L145,22
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,22 L145,22
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,22 L145,22
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,22 L145,22
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M5,22 L145,22
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,30,140,2) opacity: 0
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,33,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,36,140,2) opacity: 0.2
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,39,140,2) opacity: 0.2
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,40,140,2) opacity: 0.2
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,40,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,40,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,40,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,40,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,40,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,30,140,2)
                fill: {hasFill: true winding: nonzero opacity: 0 paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,33,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,36,140,2)
                fill: {hasFill: true winding: nonzero opacity: 0.2 paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,39,140,2)
                fill: {hasFill: true winding: nonzero opacity: 0.2 paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,42,140,2)
                fill: {hasFill: true winding: nonzero opacity: 0.2 paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,42,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,42,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,42,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,42,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(5,42,140,2)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,50 L200,50
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 3 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,55 L200,55
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 3 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,60 L200,60
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 2 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,65 L200,65
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 16 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,70 L200,70
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 4.16 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,75 L200,75
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 4.54 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,80 L200,80
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 2.92 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,85 L200,85
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 9 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,90 L200,90
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 9 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,95 L200,95
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 2 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,100 L200,100
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 0 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,105 L200,105
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,105 L200,105
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: true width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/recursion.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200" viewBox="0 0 200 200">
  <rect width="200" height="100" fill="red"/>
    
  <rect width="50" height="50" fill="green"/>
  <!-- self reference -->
  <use xlink:href="#a" id="a"/>
  
  <g transform="translate(50, 0)">
    <rect width="50" height="50" fill="green"/>
    <use xlink:href="#a"/>
  </g>
  
  <defs>
    <g transform="translate(100, 0)" id="b">
      <rect width="50" height="50" fill="green"/>
      <use xlink:href="#b"/>
    </g>
  </defs>
  <use xlink:href="#b" id="c"/>
  
  <g id="d" transform="translate(150, 0)">
    <use xlink:href="#d"/>
    <rect width="50" height="50" fill="green"/>
  </g>
 
  <!-- valid references -->
  <defs>
    <g id="e" transform="translate(0, 50)">
      <rect width="50" height="50" fill="green"/>
    </g>
    <use xlink:href="#g" id="f"/>
    <use xlink:href="#e" id="g"/>
    <use xlink:href="#f" id="i"/>
    <use xlink:href="#i" id="j"/>
  </defs>
  <use xlink:href="#j"/>
  
  <!-- valid references -->
  <defs>
    <use xlink:href="#l" transform="translate(50, 0)" id="k"/>
  </defs>
  <g transform="translate(50, 50)">
    <use xlink:href="#k"/>
    <g id="l">
      <rect width="50" height="50" fill="green"/>
    </g>
  </g>

  <defs>
    <g id="m" transform="translate(150, 50)">
      <rect width="50" height="50" fill="green"/>
      <use xlink:href="#n"/>
      <use xlink:href="#o" id="n"/>
      <use xlink:href="#p" id="o"/>
      <use xlink:href="#m" id="p"/>
    </g>
  </defs>
  <use xlink:href="#m"/>
</svg>
</file>

<file path="svgnative/test/shapes.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,0,1,1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,1e+20,1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,1,1e+20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(0,0,1,1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(0,0,1e+20,1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(0,0,1,1e+20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(0,0,1,1)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Ellipse(0,0,1e+20,1e+20)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/SVGNativeViewerLib.pc.in">
prefix=@CMAKE_INSTALL_PREFIX@
exec_prefix=${prefix}
libdir=@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_LIBDIR@
includedir=@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_INCLUDEDIR@/@HEADER_SUBDIR@

Name: SVGNativeViewerLib
Description: Parser and renderer for SVG Native documents
Version: @VERSION@
Requires: @REQUIRES@ 
Requires.private: @PRIVATE_REQUIRES@

Cflags: -I${includedir}
Libs: -L${libdir} -lSVGNativeViewerLib
Libs.private: @PRIVATE_LIBS@
</file>

<file path=".gitignore">
.DS_Store
svgnative/build/
viewer/
.vscode
SVGNativeViewerLib.pc
svgnative/out
.vs
</file>

<file path=".gitmodules">
[submodule "third_party/stylesheet"]
	path = third_party/stylesheet
	url = https://github.com/adobe/stylesheet.git
	branch = modifications
[submodule "third_party/cpp-base64"]
	path = third_party/cpp-base64
	url = https://github.com/ReneNyffenegger/cpp-base64.git
[submodule "third_party/boost_variant_property_tree"]
	path = third_party/boost_variant_property_tree
	url = https://github.com/dirkschulze/boost_variant_property_tree.git
	branch = v1_81_0
</file>

<file path="svgnative/example/testC/TestMain.c">
/*
Copyright 2019 Adobe.
Copyright 2019 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>.
All rights reserved.

This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>

#include "svgnative/SVGNativeCWrapper.h"

char* read_svg_input(const char* pathname)
{
    char*   buff_input;
    FILE*   file_input;
    size_t  size_input;

    file_input = fopen(pathname, "r");
    if (!file_input)
    {
        printf("Error! Could not open input file.");
        exit(EXIT_FAILURE);
    }

    fseek(file_input, 0, SEEK_END);
    size_input = ftell(file_input);
    fseek(file_input, 0, SEEK_SET);
    buff_input = malloc(size_input + 1);
    if (!buff_input)
    {
        printf("Error! Cannot allocate sufficient memory to read input SVG.");
        exit(EXIT_FAILURE);
    }
    fread(buff_input, size_input, 1, file_input);
    fclose(file_input);

    return buff_input;
}

size_t write_data(const char* pathname, const char* buff_output, size_t size_output)
{
    FILE*   file_output;
    size_t  size_written;

    file_output = fopen(pathname, "w+");
    if (!file_output)
    {
        printf("Error! Could not open output file.");
        exit(EXIT_FAILURE);
    }

    size_written = fwrite(buff_output, size_output, 1, file_output);
    fclose(file_output);
    return size_written;
}

int main(int argc, const char* argv[])
{
    svg_native_t*  sn;
    svg_native_color_map_t*  colorMap;

    char*   buff_input;
    char*   buff_output;
    size_t  size_output;

    if (argc != 3)
    {
        printf("Incorrect number of arguments.");
        return 0;
    }
    buff_input = read_svg_input(argv[1]);

    colorMap = svg_native_color_map_create();
    svg_native_color_map_add(colorMap, "test-red",   0.502,   0.0, 0.0, 1.0);
    svg_native_color_map_add(colorMap, "test-green",   0.0, 0.502, 0.0, 1.0);
    svg_native_color_map_add(colorMap, "test-blue",    0.0,   0.0, 1.0, 1.0);

    sn = svg_native_create(SVG_RENDERER_STRING, buff_input);
    svg_native_set_color_map(sn, colorMap);

    svg_native_render(sn);

    svg_native_get_output(sn, &buff_output, &size_output);
    write_data(argv[2], buff_output, size_output);
    free(buff_output);

    svg_native_destroy(sn);
    svg_native_color_map_destroy(colorMap);

    return 0;
}
</file>

<file path="svgnative/example/testSkia/TestSkia.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/SVGDocument.h"
#include "SkData.h"
#include "SkEncodedImageFormat.h"
#include "SkImage.h"
#include "SkStream.h"
#include "SkSurface.h"
#include "svgnative/ports/skia/SkiaSVGRenderer.h"

#include <fstream>
#include <iostream>
#include <string>

int main(int argc, char* const argv[])
{
    if (argc != 3)
    {
        std::cout << "Incorrect number of arguments." << std::endl;
        return 0;
    }

    std::string svgInput{};
    std::ifstream input(argv[1]);
    if (!input)
    {
        std::cout << "Error! Could not open input file." << std::endl;
        exit(EXIT_FAILURE);
    }
    for (std::string line; std::getline(input, line);)
        svgInput.append(line);
    input.close();

    auto renderer = std::make_shared<SVGNative::SkiaSVGRenderer>();

    auto doc = std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(), renderer));

    {
        // make initially default canvas and compute the bounds , after computation make
        // new canvas again of actual bounds.
        auto skRasterSurface = SkSurface::MakeRasterN32Premul(doc->Width(), doc->Height());
        auto skRasterCanvas = skRasterSurface->getCanvas();

        renderer->SetSkCanvas(skRasterCanvas);
        SVGNative::Rect bounds {0,0,0,0};
        doc->GetBoundingBox(bounds);
    }

    auto skRasterSurface = SkSurface::MakeRasterN32Premul(doc->Width(), doc->Height());
    auto skRasterCanvas = skRasterSurface->getCanvas();

    renderer->SetSkCanvas(skRasterCanvas);
    doc->Render();

    auto skImage = skRasterSurface->makeImageSnapshot();
    if (!skImage)
        return 0;
    sk_sp<SkData> pngData(skImage->encodeToData(SkEncodedImageFormat::kPNG, 100));
    if (!pngData)
        return 0;

    SkFILEWStream out(argv[2]);
    (void)out.write(pngData->data(), pngData->size());

    return 0;
}
</file>

<file path="svgnative/example/testText/TestMain.cpp">
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains
 * the property of Adobe and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Adobe and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe.
 **************************************************************************/

#include "svgnative/SVGDocument.h"
#include "svgnative/ports/string/StringSVGRenderer.h"

#include <fstream>
#include <iostream>
#include <string>

int main(int argc, char* const argv[])
{
    if (argc != 3 && argc != 4)
    {
        std::cout << "Incorrect number of arguments." << std::endl;
        return 0;
    }

    std::string svgInput{};
    std::ifstream input(argv[1]);
    if (!input)
    {
        std::cout << "Error! Could not open input file." << std::endl;
        exit(EXIT_FAILURE);
    }
    for (std::string line; std::getline(input, line);)
        svgInput.append(line);
    input.close();

    SVGNative::ColorMap colorMap = {
        {"test-red",   {{0.502,   0.0, 0.0, 1.0}}},
        {"test-green", {{  0.0, 0.502, 0.0, 1.0}}},
        {"test-blue",  {{  0.0,   0.0, 1.0, 1.0}}}
    };
    auto renderer = std::make_shared<SVGNative::StringSVGRenderer>();

    auto doc = std::unique_ptr<SVGNative::SVGDocument>(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(), renderer));
    if (!doc)
    {
        std::cout << "Error! Could not parse document." << std::endl;
        exit(EXIT_FAILURE);
    }
    if (argc == 3)
        doc->Render(colorMap);
    else
    {
        std::string id{argv[3]};
        doc->Render(id.c_str(), colorMap);
    }

    std::fstream outputStream;
    outputStream.open(argv[2], std::fstream::out);
    if (!outputStream)
    {
        std::cout << "Error! Could not write file." << std::endl;
        exit(EXIT_FAILURE);
    }
    std::string outputString{renderer->String()};
    outputStream << outputString;
    outputStream.close();

    return 0;
}
</file>

<file path="svgnative/include/svgnative/ports/skia/SkiaSVGRenderer.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_SkiaSVGRenderer_h
#define SVGViewer_SkiaSVGRenderer_h

#include "svgnative/SVGRenderer.h"
#include "svgnative/Rect.h"
#include "SkPath.h"

struct SkRect;
class SkCanvas;
class SkImage;

namespace SVGNative
{
class SkiaSVGPath final : public Path
{
public:
    SkiaSVGPath();

    void Rect(float x, float y, float width, float height) override;
    void RoundedRect(float x, float y, float width, float height, float rx, float ry) override;
    void Ellipse(float cx, float cy, float rx, float ry) override;

    void MoveTo(float x, float y) override;
    void LineTo(float x, float y) override;
    void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) override;
    void CurveToV(float x2, float y2, float x3, float y3) override;
    void ClosePath() override;

    SkPath mPath;

private:
    float mCurrentX{};
    float mCurrentY{};
};

class SkiaSVGTransform final : public Transform
{
public:
    SkiaSVGTransform(float a, float b, float c, float d, float tx, float ty);

    void Set(float a, float b, float c, float d, float tx, float ty) override;
    void Rotate(float r) override;
    void Translate(float tx, float ty) override;
    void Scale(float sx, float sy) override;
    void Concat(float a, float b, float c, float d, float tx, float ty) override;

    SkMatrix mMatrix;
};

class SkiaSVGImageData final : public ImageData
{
public:
    SkiaSVGImageData(const std::string& base64, ImageEncoding encoding);
    ~SkiaSVGImageData() override;

    float Width() const override;

    float Height() const override;

    sk_sp<SkImage> mImageData;
};

class SVG_IMP_EXP SkiaSVGRenderer final : public SVGRenderer
{
public:
    SkiaSVGRenderer();

    std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding encoding) override { return std::unique_ptr<SkiaSVGImageData>(new SkiaSVGImageData(base64, encoding)); }

    std::unique_ptr<Path> CreatePath() override { return std::unique_ptr<SkiaSVGPath>(new SkiaSVGPath); }

    std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) override
    {
        return std::unique_ptr<SkiaSVGTransform>(new SkiaSVGTransform(a, b, c, d, tx, ty));
    }

    void Save(const GraphicStyle& graphicStyle) override;
    void Restore() override;

    void DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;
    void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) override;
    Rect GetBounds(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) override;

    void SetSkCanvas(SkCanvas* canvas);

private:
    SkCanvas* mCanvas;
};

} // namespace SVGNative

#endif // SVGViewer_SkiaSVGRenderer_h
</file>

<file path="svgnative/include/svgnative/SVGDocument.h">
/*
Copyright 2014 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_SVGParser_h
#define SVGViewer_SVGParser_h

#include "Config.h"
#include "SVGRenderer.h"

#include <array>
#include <map>
#include <memory>
#include <string>
#include <vector>

#ifdef STYLE_SUPPORT
namespace StyleSheet
{
class CssDocument;
}
#endif

namespace SVGNative
{
class SVGDocumentImpl;
class SVGRenderer;
using ColorMap = std::map<std::string, std::array<float, 4>>;

class SVG_IMP_EXP SVGDocument
{
public:
    /**
     * Parses the passed string as SVG.
     * @param s SVG content as string.
     * @param renderer The renderer provides the Transform, Shape and Path interface needed at parse time and
     *      the actual renderer used during rendering process.
     * @return Returns a pointer to a new SVGDocument object.
     */
    static std::unique_ptr<SVGDocument> CreateSVGDocument(const char* s, std::shared_ptr<SVGNative::SVGRenderer> renderer);

    ~SVGDocument();

    /**
     * Get the horizontal dimension of the SVG document in local coordinates.
     * @return Horizontal dimension of the SVG document in local coordinates.
     */
    std::int32_t Width() const;

    /**
     * Get the vertical dimension of the SVG document in local coordinates.
     * @return Vertical dimension of the SVG document in local coordinates.
     */
    std::int32_t Height() const;

    /**
     * Renderer used to draw SVG content to. This was passed to ParserSVG() first.
     * @return SVGRenderer
     */
    SVGNative::SVGRenderer* Renderer() const;

#ifdef STYLE_SUPPORT
    /**
     * Add a custom CSS stylesheet to the cascading of the document.
     * @param cssDocument CSS style sheet.
     * @deprecated This method is deprecated and will get removed.
     */
    void AddCustomCSS(const StyleSheet::CssDocument* cssDocument);

    /**
     * Remove all CSS stylesheets added by AddCustomCSS.
     * @deprecated This method is deprecated and will get removed.
     */
    void ClearCustomCSS();
#endif

    /**
     * Renders the parsed SVG document to renderer. Some clients require a separation
     * between parsing and rendering to reuse the rendering tree with different
     * color variables.
     */
    void Render();

    /**
     * Renders the parsed SVG document to renderer. Some clients require a separation
     * between parsing and rendering to reuse the rendering tree with different
     * color variables.
     * The viewport of the SVG document will be scaled uniformly to fit into the area
     * defined by the width and height arguments.
     * @param width Horizontal dimension of surface.
     * @param height Vertical dimension of surface.
     */
    void Render(float width, float height);

    /**
     * Renders the parsed SVG document to renderer. Some clients require a separation
     * between parsing and rendering to reuse the rendering tree with different
     * color variables.
     * @param colorMap A string-to-Color map for pre-defined colors that replace
     *      CSS custom properties in the SVG file.
     *
     * @code
     * // Define the color map:
     * ColorMap colorMap = {
     *     {"myCustomFillColor",   {{0.52,  0.0, 0.0, 1.0}}},
     *     {"myCustomStrokeColor", {{ 0.0, 0.52, 0.0, 1.0}}}
     * };
     *
     * // Replaces colors defined in SVG with a CSS Custom Property:
     * // <svg viewBox="0 0 200 200">
     * //     <rect width="200" height="200" fill="var(--myCustomFillColor, #F00)"/>
     * //     <rect width="200" height="200" stroke="var(--myCustomStrokeColor, #0F0)"/>
     * // </svg>
     * // Note: var() consists of a custom name and, optionally, a comma separated fallback CSS color.
     * @encode
     */
    void Render(const ColorMap& colorMap);

    /**
     * Renders the parsed SVG document to renderer. Some clients require a separation
     * between parsing and rendering to reuse the rendering tree with different
     * color variables.
     * The viewport of the SVG document will be scaled uniformly to fit into the area
     * defined by the width and height arguments.
     * @param colorMap A string-to-Color map for pre-defined colors that replace
     *      CSS custom properties in the SVG file.
     * @param width Horizontal dimension of surface.
     * @param height Vertical dimension of surface.
     *
     * @code
     * // Define the color map:
     * ColorMap colorMap = {
     *     {"myCustomFillColor",   {{0.52,  0.0, 0.0, 1.0}}},
     *     {"myCustomStrokeColor", {{ 0.0, 0.52, 0.0, 1.0}}}
     * };
     *
     * // Replaces colors defined in SVG with a CSS Custom Property:
     * // <svg viewBox="0 0 200 200">
     * //     <rect width="200" height="200" fill="var(--myCustomFillColor, #F00)"/>
     * //     <rect width="200" height="200" stroke="var(--myCustomStrokeColor, #0F0)"/>
     * // </svg>
     * // Note: var() consists of a custom name and, optionally, a comma separated fallback CSS color.
     * @encode
     */
    void Render(const ColorMap& colorMap, float width, float height);

    /**
     * Renders the subtree of an element with the given XML ID.
     */
    void Render(const char* id);

    /**
     * Renders the subtree of an element with the given XML ID.
     * See /ref Render(float width, float height) for details.
     */
    void Render(const char* id, float width, float height);

    /**
     * Renders the subtree of an element with the given XML ID.
     * See /ref Render(const ColorMap& colorMap) for details.
     */
    void Render(const char* id, const ColorMap& colorMap);

    /**
     * Renders the subtree of an element with the given XML ID.
     * See /ref Render(const ColorMap& colorMap, float width, float height) for details.
     */
    void Render(const char* id, const ColorMap& colorMap, float width, float height);

    /**
     * Retrieves the bounds of the SVG Document.
     *
     * The bounds are as tightly computed as possible. The rendering port's canvas
     * is used to calculate the bounds so the user must make sure that a context has been
     * set, otherwise an assertion will fire.
     */
    bool GetBoundingBox(Rect& bounds);

    /**
     * Retrieves the bounds of the subtree of an element with the given XML ID.
     *
     * The bounds are as tightly computed as possible. The rendering port's canvas
     * is used to calculate the bounds so the user must make sure that a context has been
     * set, otherwise an assertion will fire.
     */
    bool GetBoundingBox(const char* id, Rect& bounds);
    
    void GetViewBox(Rect& viewBox);
    
private:
    SVGDocument();

    std::unique_ptr<SVGDocumentImpl> mDocument;
};

} // namespace SVGNative

#endif // SVGViewer_SVGParser_h
</file>

<file path="svgnative/src/ports/string/StringSVGRenderer.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/ports/string/StringSVGRenderer.h"

#define _USE_MATH_DEFINES
#include <cmath>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

namespace SVGNative
{
StringSVGPath::StringSVGPath() { mStringStream.precision(3); }

void StringSVGPath::Rect(float x, float y, float width, float height)
{
    mStringStream << " Rect(" << x << ',' << y << ',' << width << ',' << height << ')';
}

void StringSVGPath::RoundedRect(float x, float y, float width, float height, float rx, float ry)
{
    mStringStream << " RoundedRect(" << x << ',' << y << ',' << width << ',' << height << ',' << rx << ',' << ry << ')';
}

void StringSVGPath::Ellipse(float cx, float cy, float rx, float ry)
{
    mStringStream << " Ellipse(" << cx << ',' << cy << ',' << rx << ',' << ry << ')';
}

void StringSVGPath::MoveTo(float x, float y) { mStringStream << " M" << x << ',' << y; }

void StringSVGPath::LineTo(float x, float y) { mStringStream << " L" << x << ',' << y; }

void StringSVGPath::CurveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{
    mStringStream << " C" << x1 << ',' << y1 << ',' << x2 << ',' << y2 << ',' << x3 << ',' << y3;
}

void StringSVGPath::CurveToV(float x2, float y2, float x3, float y3) { mStringStream << " Q" << x2 << ',' << y2 << ',' << x3 << ',' << y3; }

void StringSVGPath::ClosePath() { mStringStream << " Z"; }

std::string StringSVGPath::String() const { return mStringStream.str(); }

float deg2rad(float angle);
float deg2rad(float angle) { return static_cast<float>(M_PI / 180.0 * angle); }

StringSVGTransform::StringSVGTransform(float a, float b, float c, float d, float tx, float ty) { Set(a, b, c, d, tx, ty); }

void StringSVGTransform::Set(float a, float b, float c, float d, float tx, float ty) { mTransform = {a, b, c, d, tx, ty}; }

void StringSVGTransform::Rotate(float r)
{
    r = deg2rad(r);
    float cosAngle = cos(r);
    float sinAngle = sin(r);

    auto rot = AffineTransform{cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0};
    Multiply(rot);
}

void StringSVGTransform::Translate(float tx, float ty)
{
    mTransform.e += tx * mTransform.a + ty * mTransform.c;
    mTransform.f += tx * mTransform.b + ty * mTransform.d;
}

void StringSVGTransform::Scale(float sx, float sy)
{
    mTransform.a *= sx;
    mTransform.b *= sx;
    mTransform.c *= sy;
    mTransform.d *= sy;
}

void StringSVGTransform::Concat(float a, float b, float c, float d, float tx, float ty)
{
    AffineTransform other{a, b, c, d, tx, ty};
    Multiply(other);
}

std::string StringSVGTransform::String() const
{
    std::ostringstream stringStream;
    stringStream.precision(3);
    stringStream << "matrix(" << mTransform.a << ',' << mTransform.b << ',' << mTransform.c << ',' << mTransform.d << ',' << mTransform.e
                 << ',' << mTransform.f << ')';
    return stringStream.str();
}

void StringSVGTransform::Multiply(const AffineTransform& o)
{
    AffineTransform newT;
    newT.a = o.a * mTransform.a + o.b * mTransform.c;
    newT.b = o.a * mTransform.b + o.b * mTransform.d;
    newT.c = o.c * mTransform.a + o.d * mTransform.c;
    newT.d = o.c * mTransform.b + o.d * mTransform.d;
    newT.e = o.e * mTransform.a + o.f * mTransform.c + mTransform.e;
    newT.f = o.e * mTransform.b + o.f * mTransform.d + mTransform.f;
    mTransform = newT;
}

StringSVGRenderer::StringSVGRenderer() { mStringStream.precision(3); }

std::unique_ptr<Path> StringSVGRenderer::CreatePath()
{
    return std::unique_ptr<StringSVGPath>(new StringSVGPath);
}

std::unique_ptr<Transform> StringSVGRenderer::CreateTransform(
    float a, float b, float c, float d, float tx, float ty)
{
    return std::unique_ptr<StringSVGTransform>(new StringSVGTransform(a, b, c, d, tx, ty));
}

void StringSVGRenderer::Save(const GraphicStyle& graphicStyle)
{
    WriteIndent();
    mStringStream << "[group";
    WriteGraphic(graphicStyle);
    IncIndent();
    WriteNewline();
}

void StringSVGRenderer::Restore()
{
    DecIndent();
    WriteIndent();
    mStringStream << ']';
    WriteNewline();
}

void StringSVGRenderer::DrawPath(
    const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    WriteIndent();
    mStringStream << "[path" << static_cast<const StringSVGPath&>(path).String();
    WriteGraphic(graphicStyle);

    IncIndent();
    WriteNewline();
    WriteIndent();

    WriteFill(fillStyle);
    WriteNewline();
    WriteIndent();

    WriteStroke(strokeStyle);
    mStringStream << ']';
    DecIndent();
    WriteNewline();
}

void StringSVGRenderer::DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea)
{
    WriteIndent();
    mStringStream << "[image ";
    mStringStream << "clip(" << clipArea.x << ", " << clipArea.y << ", " << clipArea.width << ", " << clipArea.height << ") ";
    mStringStream << "fill(" << fillArea.x << ", " << fillArea.y << ", " << fillArea.width << ", " << fillArea.height << ") ";
    WriteGraphic(graphicStyle);
    mStringStream << ' ' << static_cast<const StringSVGImageData&>(image).String() << ']';
    WriteNewline();
}

std::string StringSVGRenderer::String() const { return mStringStream.str(); }

void StringSVGRenderer::IncIndent() { mIndent += 4; }

void StringSVGRenderer::DecIndent() { mIndent -= 4; }

void StringSVGRenderer::WriteNewline() { mStringStream << '\n'; }

void StringSVGRenderer::WriteIndent()
{
    for (size_t i = 0; i < mIndent; ++i)
        mStringStream << ' ';
}

void StringSVGRenderer::WriteFill(const FillStyle& fillStyle)
{
    mStringStream << "fill: {";
    mStringStream << "hasFill: " << (fillStyle.hasFill ? "true" : "false");
    mStringStream << " winding: " << (fillStyle.fillRule == WindingRule::kNonZero ? "nonzero" : "evenodd");
    if (fillStyle.fillOpacity != 1.0)
        mStringStream << " opacity: " << fillStyle.fillOpacity;
    WritePaint(fillStyle.paint);
    mStringStream << '}';
}

void StringSVGRenderer::WriteStroke(const StrokeStyle& strokeStyle)
{
    mStringStream << "stroke: {";
    mStringStream << "hasStroke: " << (strokeStyle.hasStroke ? "true" : "false");
    mStringStream << " width: " << strokeStyle.lineWidth;
    if (strokeStyle.strokeOpacity != 1.0)
        mStringStream << " opacity: " << strokeStyle.strokeOpacity;
    mStringStream << " cap: ";
    if (strokeStyle.lineCap == LineCap::kButt)
        mStringStream << "butt";
    else if (strokeStyle.lineCap == LineCap::kRound)
        mStringStream << "round";
    else if (strokeStyle.lineCap == LineCap::kSquare)
        mStringStream << "square";
    mStringStream << " join: ";
    if (strokeStyle.lineJoin == LineJoin::kMiter)
        mStringStream << "miter";
    else if (strokeStyle.lineJoin == LineJoin::kRound)
        mStringStream << "round";
    else if (strokeStyle.lineJoin == LineJoin::kBevel)
        mStringStream << "bevel";
    mStringStream << " miter: " << strokeStyle.miterLimit;
    if (!strokeStyle.dashArray.empty())
    {
        mStringStream << " dash:";
        for (auto dash : strokeStyle.dashArray)
            mStringStream << ' ' << dash;
    }
    mStringStream << " dashOffset: " << strokeStyle.dashOffset;
    WritePaint(strokeStyle.paint);
    mStringStream << '}';
}

void StringSVGRenderer::WriteGraphic(const GraphicStyle& graphicStyle)
{
    if (graphicStyle.opacity != 1.0)
        mStringStream << " opacity: " << graphicStyle.opacity;
    if (graphicStyle.transform)
        mStringStream << " transform: " << static_cast<StringSVGTransform*>(graphicStyle.transform.get())->String();
    if (graphicStyle.clippingPath && graphicStyle.clippingPath->path)
    {
        mStringStream << " clipping: {";
        mStringStream << " winding: " << (graphicStyle.clippingPath->clipRule == WindingRule::kNonZero ? "nonzero" : "evenodd");
        if (graphicStyle.clippingPath->transform)
            mStringStream << " transform: " << static_cast<StringSVGTransform*>(graphicStyle.clippingPath->transform.get())->String();
        mStringStream <<  " [path" << static_cast<const StringSVGPath*>(graphicStyle.clippingPath->path.get())->String();
        mStringStream << "]}";
    }
}

void StringSVGRenderer::WritePaint(const Paint& paint)
{
    // FIXME: use static_visitor
    if (SVGNative::holds_alternative<Gradient>(paint))
    {
        auto gradient = SVGNative::get<Gradient>(paint);
        mStringStream << " paint: {";
        WriteNewline();
        IncIndent();
        WriteIndent();
        mStringStream << (gradient.type == GradientType::kLinearGradient ? "linearGradient:" : "radialGradient:");
        if (gradient.transform)
            mStringStream << " transform: " << static_cast<StringSVGTransform*>(gradient.transform.get())->String();
        if (gradient.type == GradientType::kLinearGradient)
        {
            if (std::isfinite(gradient.x1))
                mStringStream << " x1: " << gradient.x1;
            if (std::isfinite(gradient.y1))
                mStringStream << " y1: " << gradient.y1;
            if (std::isfinite(gradient.x2))
                mStringStream << " x2: " << gradient.x2;
            if (std::isfinite(gradient.y2))
                mStringStream << " y2: " << gradient.y2;
        }
        else // GradientType::kRadialGradient
        {
            if (std::isfinite(gradient.cx))
                mStringStream << " cx: " << gradient.cx;
            if (std::isfinite(gradient.cy))
                mStringStream << " cy: " << gradient.cy;
            if (std::isfinite(gradient.fx))
                mStringStream << " fx: " << gradient.fx;
            if (std::isfinite(gradient.fy))
                mStringStream << " fy: " << gradient.fy;
            if (std::isfinite(gradient.r))
                mStringStream << " r: " << gradient.r;
        }
        mStringStream << " method: ";
        if (gradient.method == SpreadMethod::kPad)
            mStringStream << "pad";
        else if (gradient.method == SpreadMethod::kReflect)
            mStringStream << "reflect";
        else if (gradient.method == SpreadMethod::kRepeat)
            mStringStream << "repeat";
        mStringStream << " stops: {";
        WriteNewline();
        IncIndent();
        for (const auto& colorStop : gradient.colorStops)
        {
            WriteIndent();
            const auto& stopColor = colorStop.second;
            mStringStream << "offset: " << colorStop.first;
            mStringStream << " rgba(" << stopColor[0] << ',' << stopColor[1] << ',' << stopColor[2] << ',' << stopColor[3] << ')';
            WriteNewline();
        }
        DecIndent();
        WriteIndent();
        mStringStream << '}';
        mStringStream << '}';
        DecIndent();
    }
    else if (SVGNative::holds_alternative<Color>(paint))
    {
        auto color = SVGNative::get<Color>(paint);
        mStringStream << " paint: rgba(" << color[0] << ',' << color[1] << ',' << color[2] << ',' << color[3] << ')';
    }
}
} // namespace SVGNative
</file>

<file path="svgnative/src/SVGStringParser.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#pragma once

#include "SVGDocumentImpl.h"
#include <map>
#include <string>

namespace SVGNative
{
namespace SVGStringParser
{
bool ParseTransform(const std::string& transformString, Transform& matrix);
bool ParseNumber(const std::string& numberString, float& number);
bool ParseAlphaValue(const std::string& numberString, float& number);
bool ParseListOfNumbers(const std::string& numberListString, std::vector<float>& numberList, bool isAllOptional = true);
bool ParseListOfLengthOrPercentage(
    const std::string& lengthOrPercentageListString, float relDimensionLength, std::vector<float>& numberList, bool isAllOptional = true);
bool ParseListOfStrings(const std::string& stringListString, std::vector<std::string>& stringList);
bool ParseLengthOrPercentage(const std::string& lengthString, float relDimensionLength, float& absLengthInUnits, bool useQuirks = false);
void ParsePathString(const std::string& pathString, Path& p);
SVGDocumentImpl::Result ParseColor(const std::string& colorString, ColorImpl& paint, bool supportsCurrentColor = true);
SVGDocumentImpl::Result ParsePaint(const std::string& colorString, const std::map<std::string, GradientImpl>& gradientMap,
    const std::array<float, 4>& viewBox, PaintImpl& paint);

} // namespace SVGStringParser

} // namespace SVGNative
</file>

<file path="svgnative/test/gradient-outside-defs.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,180,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    linearGradient: x1: 0 y1: 0 x2: 150 y2: 0 method: pad stops: {
                        offset: 0 rgba(0,0,1,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,180,150,10)
                fill: {hasFill: true winding: nonzero paint: {
                    radialGradient: cx: 75 cy: 125 fx: 75 fy: 125 r: 146 method: pad stops: {
                        offset: 0 rgba(0,0,1,1)
                        offset: 1 rgba(0,1,0,1)
                    }}}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/test/recursion.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path Rect(0,0,200,100)
                fill: {hasFill: true winding: nonzero paint: rgba(1,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path Rect(0,0,50,50)
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [group
            ]
            [group transform: matrix(1,0,0,1,50,0)
                [path Rect(0,0,50,50)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                [group
                    [group
                    ]
                ]
            ]
            [group
                [group transform: matrix(1,0,0,1,100,0)
                    [path Rect(0,0,50,50)
                        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                    [group
                        [group transform: matrix(1,0,0,1,100,0)
                            [path Rect(0,0,50,50)
                                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                        ]
                    ]
                ]
            ]
            [group transform: matrix(1,0,0,1,150,0)
                [group
                    [group transform: matrix(1,0,0,1,150,0)
                        [path Rect(0,0,50,50)
                            fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                            stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                    ]
                ]
                [path Rect(0,0,50,50)
                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                    stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            ]
            [group
                [group
                    [group
                        [group
                            [group
                                [group transform: matrix(1,0,0,1,0,50)
                                    [path Rect(0,0,50,50)
                                        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
            [group transform: matrix(1,0,0,1,50,50)
                [group
                    [group transform: matrix(1,0,0,1,50,0)
                        [group
                            [path Rect(0,0,50,50)
                                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                        ]
                    ]
                ]
                [group
                    [path Rect(0,0,50,50)
                        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                ]
            ]
            [group
                [group transform: matrix(1,0,0,1,150,50)
                    [path Rect(0,0,50,50)
                        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                    [group
                        [group
                            [group
                                [group
                                    [group transform: matrix(1,0,0,1,150,50)
                                        [path Rect(0,0,50,50)
                                            fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                            stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                                    ]
                                ]
                            ]
                        ]
                    ]
                    [group
                        [group
                            [group
                                [group transform: matrix(1,0,0,1,150,50)
                                    [path Rect(0,0,50,50)
                                        fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                        stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                                    [group
                                    ]
                                ]
                            ]
                        ]
                    ]
                    [group
                        [group
                            [group transform: matrix(1,0,0,1,150,50)
                                [path Rect(0,0,50,50)
                                    fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                    stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                                [group
                                    [group
                                    ]
                                ]
                                [group
                                ]
                            ]
                        ]
                    ]
                    [group
                        [group transform: matrix(1,0,0,1,150,50)
                            [path Rect(0,0,50,50)
                                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
                            [group
                                [group
                                    [group
                                    ]
                                ]
                            ]
                            [group
                                [group
                                ]
                            ]
                            [group
                            ]
                        ]
                    ]
                ]
            ]
        ]
    ]
]
</file>

<file path="svgnative/include/svgnative/SVGRenderer.h">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#ifndef SVGViewer_SVGRenderer_h
#define SVGViewer_SVGRenderer_h

#include "Config.h"
#include "Rect.h"

#include <array>
#include <limits>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

#if (__cplusplus >= 201703L)
#include <variant>
namespace SVGNative
{
template<class... Types>
using variant = std::variant<Types...>;
using std::get;
using std::holds_alternative;
}
#else
#include <boost/variant.hpp>

namespace SVGNative
{
template<class... Types>
using variant = boost::variant<Types...>;
using boost::get;

template<class T, class... Types>
constexpr bool holds_alternative(const boost::variant<Types...>& v) noexcept
{
    return v.type() == typeid(T);
}
}
#endif

namespace SVGNative
{
/**
 * Supported image encoding formats are PNG and JPEG.
 * The assumed encoding format based on the base64 string.
 */
enum class ImageEncoding
{
    kPNG,
    kJPEG
};

/**
 * Line caps as described in:
 * https://www.w3.org/TR/SVG2/painting.html#LineCaps
 */
enum class LineCap
{
    kButt,
    kRound,
    kSquare
};

/**
 * Line joins as described in:
 * https://www.w3.org/TR/SVG2/painting.html#LineJoin
 */
enum class LineJoin
{
    kMiter,
    kRound,
    kBevel
};

/**
 * Winding rules as described in:
 * https://www.w3.org/TR/SVG2/painting.html#WindingRule
 */
enum class WindingRule
{
    kNonZero,
    kEvenOdd
};

/**
 * Gradient type. SVG Native supports the 2 gradient types
 * * linear gradient and
 * * radial gradient.
 */
enum class GradientType
{
    kLinearGradient,
    kRadialGradient
};

/**
 * Gradient spread method.
 * * pad
 * * reflect
 * * repeat
 *
 * @note See https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementSpreadMethodAttribute
 */
enum class SpreadMethod
{
    kPad,
    kReflect,
    kRepeat
};

struct Gradient;
class Transform;
class Path;

using Color = std::array<float, 4>;
using Paint = SVGNative::variant<Color, Gradient>;
using ColorStop = std::pair<float, Color>;
using ColorMap = std::map<std::string, Color>;

/**
 * Representation of a linear gradient paint server.
 */
struct Gradient
{
    GradientType type = GradientType::kLinearGradient;
    SpreadMethod method = SpreadMethod::kPad;
    std::vector<ColorStop> colorStops; /** Color stops with offset-color pairs **/
    float x1 = std::numeric_limits<float>::quiet_NaN(); /** x1 for linearGradient **/
    float y1 = std::numeric_limits<float>::quiet_NaN(); /** y1 for linearGradient **/
    float x2 = std::numeric_limits<float>::quiet_NaN(); /** x2 for linearGradient **/
    float y2 = std::numeric_limits<float>::quiet_NaN(); /** y2 for linearGradient **/
    float cx = std::numeric_limits<float>::quiet_NaN(); /** cx for radialGradient **/
    float cy = std::numeric_limits<float>::quiet_NaN(); /** cy for radialGradient **/
    float fx = std::numeric_limits<float>::quiet_NaN(); /** fx for radialGradient **/
    float fy = std::numeric_limits<float>::quiet_NaN(); /** fy for radialGradient **/
    float r = std::numeric_limits<float>::quiet_NaN(); /** r for radialGradient **/
    std::shared_ptr<Transform> transform; /** Joined transformation matrix based to the "transform" attribute. **/
};

/**
 * Stroke style information.
 */
struct StrokeStyle
{
    bool hasStroke = false;
    float strokeOpacity = 1.0;
    float lineWidth = 1.0;
    LineCap lineCap = LineCap::kButt;
    LineJoin lineJoin = LineJoin::kMiter;
    float miterLimit = 4.0;
    std::vector<float> dashArray;
    float dashOffset = 0.0;
    Paint paint = Color{{0, 0, 0, 1.0}};
};

/**
 * Fill style information.
 */
struct FillStyle
{
    bool hasFill = true;
    WindingRule fillRule = WindingRule::kNonZero;
    float fillOpacity = 1.0;
    Paint paint = Color{{0, 0, 0, 1.0}};
};

/**
 * Representation of a 2D affine transform with 6 values.
 */
class Transform
{
public:
    virtual ~Transform() = default;

    virtual void Set(float a, float b, float c, float d, float tx, float ty) = 0;
    virtual void Rotate(float r) = 0;
    virtual void Translate(float tx, float ty) = 0;
    virtual void Scale(float sx, float sy) = 0;
    virtual void Concat(float a, float b, float c, float d, float tx, float ty) = 0;
};

struct ClippingPath
{
    ClippingPath(bool aHasClipContent, WindingRule aClipRule, std::shared_ptr<Path> aPath, std::shared_ptr<Transform> aTransform)
        : hasClipContent{aHasClipContent}
        , clipRule{aClipRule}
        , path{aPath}
        , transform{aTransform}
    {}

    bool hasClipContent = false;
    WindingRule clipRule = WindingRule::kNonZero;
    std::shared_ptr<Path> path; /** Clipping path. **/
    std::shared_ptr<Transform> transform; /** Joined transformation matrix based to the "transform" attribute. **/
};

/**
 * All compositing related properties. With the exception of the
 */
struct GraphicStyle
{
    // Add blend modes and other graphic style options here.
    float opacity = 1.0; /** Corresponds to the "opacity" CSS property. **/
    std::shared_ptr<Transform> transform; /** Joined transformation matrix based to the "transform" attribute. **/
    std::shared_ptr<ClippingPath> clippingPath;
};

/**
 * A presentation of a path.
 */
class Path
{
public:
    virtual ~Path() = default;

    virtual void Rect(float x, float y, float width, float height) = 0;
    virtual void RoundedRect(float x, float y, float width, float height, float cornerRadiusX, float cornerRadiusY) = 0;
    virtual void Ellipse(float cx, float cy, float rx, float ry) = 0;

    virtual void MoveTo(float x, float y) = 0;
    virtual void LineTo(float x, float y) = 0;
    virtual void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3) = 0;
    virtual void CurveToV(float x2, float y2, float x3, float y3) = 0;
    virtual void ClosePath() = 0;
};

/**
 * An image object generated from a base64 string.
 * The port needs to decode the Base64 string and provide
 * information about the dimensions of the image.
 **/
class ImageData
{
public:
    virtual ~ImageData() = default;

    virtual float Width() const = 0;
    virtual float Height() const = 0;
};

/**
 * Base class for deriving, platform dependent renderer classes with immediate
 * graphic library calls.
 */
class SVGRenderer
{
public:
    virtual ~SVGRenderer() = default;

    virtual std::unique_ptr<ImageData> CreateImageData(const std::string& base64, ImageEncoding) = 0;
    virtual std::unique_ptr<Path> CreatePath() = 0;
    virtual std::unique_ptr<Transform> CreateTransform(
        float a = 1.0, float b = 0.0, float c = 0.0, float d = 1.0, float tx = 0.0, float ty = 0.0) = 0;

    virtual void Save(const GraphicStyle& graphicStyle) = 0;
    virtual void Restore() = 0;

    virtual void DrawPath(
        const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle) = 0;
    virtual void DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea) = 0;
    virtual Rect GetBounds(const Path&, const GraphicStyle&, const FillStyle&, const StrokeStyle&)
    {
      throw "Bound calculation functionality not implemented in this port";
      return Rect{0, 0, 0, 0};
    }
};

class SaveRestoreHelper
{
public:
    SaveRestoreHelper(std::weak_ptr<SVGRenderer> renderer, const GraphicStyle& graphicStyle)
        : mRenderer{renderer}
    {
        if (auto renderer = mRenderer.lock())
            renderer->Save(graphicStyle);
    }

    ~SaveRestoreHelper()
    {
        if (auto renderer = mRenderer.lock())
            renderer->Restore();
    }
private:
    std::weak_ptr<SVGRenderer> mRenderer{};
};

} // namespace SVGNative

#endif // SVGViewer_SVGRenderer_h
</file>

<file path="svgnative/src/ports/gdiplus/GDIPlusSVGRenderer.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include <Windows.h>
#include <gdiplus.h>

#include "svgnative/Config.h"
#include "svgnative/ports/gdiplus/GDIPlusSVGRenderer.h"
#include "base64.h"

namespace SVGNative
{

/******************************************************************************/

Gdiplus::Color ColorToGdiplusColor(const Color& inColor)
{
    return Gdiplus::Color(
        static_cast<BYTE>(inColor[3] * 255.0),
        static_cast<BYTE>(inColor[0] * 255.0),
        static_cast<BYTE>(inColor[1] * 255.0),
        static_cast<BYTE>(inColor[2] * 255.0));
}

/******************************************************************************/

GDIPlusSVGPath::GDIPlusSVGPath()
{
}

GDIPlusSVGPath::~GDIPlusSVGPath()
{
}

void GDIPlusSVGPath::Rect(float x, float y, float width, float height)
{
    mPath.AddRectangle(Gdiplus::RectF(x, y, width, height));
}

void GDIPlusSVGPath::RoundedRect(float x, float y, float w, float h, float rx, float ry)
{
    const float dx = rx + rx;
    const float dy = ry + ry;

    mPath.AddLine(x + rx, y, x + w - dx, y);
    mPath.AddArc(x + w - dx, y, dx, dy, 270, 90);
    mPath.AddLine(x + w, y + ry, x + w, y + h - dy);
    mPath.AddArc(x + w - dx, y + h - dy, dx, dy, 0, 90);
    mPath.AddLine(x + w - dx, y + h, x + rx, y + h);
    mPath.AddArc(x, y + h - dy, dx, dy, 90, 90);
    mPath.AddLine(x, y + h - dy, x, y + ry);
    mPath.AddArc(x, y, dx, dy, 180, 90);
    mPath.CloseFigure();
}

void GDIPlusSVGPath::Ellipse(float cx, float cy, float rx, float ry)
{
    mPath.AddEllipse(cx - rx, cy - ry, rx + rx, ry + ry);
}

void GDIPlusSVGPath::MoveTo(float x, float y)
{
    mCurrentX = x;
    mCurrentY = y;
}

void GDIPlusSVGPath::LineTo(float x, float y)
{
    mPath.AddLine(mCurrentX, mCurrentY, x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void GDIPlusSVGPath::CurveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{
    mPath.AddBezier(mCurrentX, mCurrentY, x1, y1, x2, y2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void GDIPlusSVGPath::CurveToV(float x2, float y2, float x3, float y3)
{
    float cx1 = mCurrentX + 2.0f / 3.0f * (x2 - mCurrentX);
    float cy1 = mCurrentY + 2.0f / 3.0f * (y2 - mCurrentY);
    float cx2 = x3 + 2.0f / 3.0f * (x2 - x3);
    float cy2 = y3 + 2.0f / 3.0f * (y2 - y3);

    mPath.AddBezier(mCurrentX, mCurrentY, cx1, cy1, cx2, cy2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void GDIPlusSVGPath::ClosePath()
{
    mPath.CloseFigure();
}

const Gdiplus::GraphicsPath& GDIPlusSVGPath::GetGraphicsPath() const
{
    return mPath;
}

/******************************************************************************/

GDIPlusSVGTransform::GDIPlusSVGTransform(float a, float b, float c, float d, float tx, float ty)
{
    mTransform.SetElements(a, b, c, d, tx, ty);
}

void GDIPlusSVGTransform::Set(float a, float b, float c, float d, float tx, float ty)
{
    mTransform.SetElements(a, b, c, d, tx, ty);
}

void GDIPlusSVGTransform::Rotate(float r)
{
    mTransform.Rotate(r);
}

void GDIPlusSVGTransform::Translate(float tx, float ty)
{
    mTransform.Translate(tx, ty);
}

void GDIPlusSVGTransform::Scale(float sx, float sy)
{
    mTransform.Scale(sx, sy);
}

void GDIPlusSVGTransform::Concat(float a, float b, float c, float d, float tx, float ty)
{
    Gdiplus::Matrix other{a, b, c, d, tx, ty};
    mTransform.Multiply(&other);
}

const Gdiplus::Matrix& GDIPlusSVGTransform::GetMatrix() const
{
    return mTransform;
}

GDIPlusSVGImageData::GDIPlusSVGImageData(const std::string& base64, ImageEncoding encoding)
{
    std::string imageString = base64_decode(base64);
    HGLOBAL hImageData = ::GlobalAlloc(GMEM_MOVEABLE, imageString.size());
    if (hImageData)
    {
        void* imageData = ::GlobalLock(hImageData);
        if (imageData)
        {
            std::memcpy(imageData, imageString.c_str(), imageString.size());

            IStream* pImageStream{};
            if (::CreateStreamOnHGlobal(hImageData, FALSE, &pImageStream) == S_OK)
            {
                mImage = std::unique_ptr<Gdiplus::Image>(Gdiplus::Image::FromStream(pImageStream, false));
                pImageStream->Release();
            }
            ::GlobalUnlock(hImageData);
        }
        ::GlobalFree(hImageData);
    }
}

GDIPlusSVGImageData::~GDIPlusSVGImageData()
{
}

float GDIPlusSVGImageData::Width() const
{
    return static_cast<float>(mImage->GetWidth());
}

float GDIPlusSVGImageData::Height() const
{
    return static_cast<float>(mImage->GetHeight());
}

const std::unique_ptr<Gdiplus::Image>& GDIPlusSVGImageData::GetImage() const
{
    return mImage;
}

GDIPlusSVGRenderer::GDIPlusSVGRenderer()
{
}

std::unique_ptr<ImageData> GDIPlusSVGRenderer::CreateImageData(const std::string& base64, ImageEncoding encoding)
{
    return std::unique_ptr<GDIPlusSVGImageData>(new GDIPlusSVGImageData(base64, encoding));
}

std::unique_ptr<Path> GDIPlusSVGRenderer::CreatePath()
{
    return std::unique_ptr<GDIPlusSVGPath>(new GDIPlusSVGPath);
}

std::unique_ptr<Transform> GDIPlusSVGRenderer::CreateTransform(float a, float b, float c, float d, float tx, float ty)
{
    return std::unique_ptr<GDIPlusSVGTransform>(new GDIPlusSVGTransform(a, b, c, d, tx, ty));
}

void GDIPlusSVGRenderer::Save(const GraphicStyle& graphicStyle)
{
    mStateStack.push_back(mContext->Save());

    if (graphicStyle.transform)
    {
        const Gdiplus::Matrix* matrix = &dynamic_cast<GDIPlusSVGTransform*>(graphicStyle.transform.get())->GetMatrix();
        if (matrix != nullptr)
        {
            mContext->MultiplyTransform(matrix, Gdiplus::MatrixOrderPrepend);
        }
    }

    if (graphicStyle.clippingPath)
    {
        std::unique_ptr<Gdiplus::GraphicsPath> clip_path(dynamic_cast<const GDIPlusSVGPath*>(graphicStyle.clippingPath->path.get())->GetGraphicsPath().Clone());
        if (graphicStyle.clippingPath->transform)
        {
            const Gdiplus::Matrix* matrix = &dynamic_cast<GDIPlusSVGTransform*>(graphicStyle.clippingPath->transform.get())->GetMatrix();
            clip_path->Transform(matrix);
        }
        clip_path->SetFillMode(graphicStyle.clippingPath->clipRule == WindingRule::kNonZero ? Gdiplus::FillMode::FillModeWinding : Gdiplus::FillMode::FillModeAlternate);
        mContext->SetClip(clip_path.get(), Gdiplus::CombineModeIntersect);
    }

    float opacity = 1.0;
    if (mOpacityStack.size() > 0)
        opacity = mOpacityStack.top();
    mOpacityStack.push(opacity * graphicStyle.opacity);
}

void GDIPlusSVGRenderer::Restore()
{
    mContext->Restore(mStateStack.back());
    mStateStack.pop_back();
    mOpacityStack.pop();
}

std::unique_ptr<Gdiplus::Brush> GDIPlusSVGRenderer::CreateGradientBrush(const Gradient& gradient, float opacity)
{
    std::unique_ptr<Gdiplus::Brush> resultBrush;

    const size_t stopCount = gradient.colorStops.size();

    std::vector<Gdiplus::Color> presetColors;
    std::vector<float> blendPositions;
    for (const auto& colorStop : gradient.colorStops)
    {
        Color color = colorStop.second;
        color[3] *= opacity;

        if (gradient.type == GradientType::kLinearGradient)
        {
            presetColors.push_back(ColorToGdiplusColor(color));
        }
        else
        {
           presetColors.insert(presetColors.begin(), ColorToGdiplusColor(color));
        }

        blendPositions.push_back(colorStop.first);
    }

    const Gdiplus::Matrix* matrix{};
    GDIPlusSVGTransform* gdiplusSvgTransform = dynamic_cast<GDIPlusSVGTransform*>(gradient.transform.get());
    if (gdiplusSvgTransform)
    {
        matrix = &gdiplusSvgTransform->GetMatrix();
    }

    Gdiplus::WrapMode wrapMode = Gdiplus::WrapModeClamp;
    switch (gradient.method)
    {
        case SpreadMethod::kPad:
            wrapMode = Gdiplus::WrapModeClamp;
            break;
        case SpreadMethod::kReflect:
            wrapMode = Gdiplus::WrapModeTileFlipXY;
            break;
        case SpreadMethod::kRepeat:
            wrapMode = Gdiplus::WrapModeTile;
            break;
    }

    if (gradient.type == GradientType::kLinearGradient)
    {
        Gdiplus::LinearGradientBrush* linearGradientBrush = new Gdiplus::LinearGradientBrush(Gdiplus::PointF(gradient.x1, gradient.y1), Gdiplus::PointF(gradient.x2, gradient.y2),
            ColorToGdiplusColor(gradient.colorStops[0].second), ColorToGdiplusColor(gradient.colorStops[stopCount - 1].second));

        linearGradientBrush->SetInterpolationColors(presetColors.data(), blendPositions.data(), static_cast<int>(stopCount));

        if (matrix != nullptr)
        {
            linearGradientBrush->SetTransform(matrix);
        }

        linearGradientBrush->SetWrapMode(wrapMode);

        resultBrush = std::unique_ptr<Gdiplus::Brush>(linearGradientBrush);
    }
    else
    {
        SVG_ASSERT_MSG(gradient.type == GradientType::kRadialGradient, "SVG radial gradient expected.");
        Gdiplus::GraphicsPath ellipticalPath;
        ellipticalPath.AddEllipse(gradient.cx- gradient.r, gradient.cy- gradient.r, 2*gradient.r, 2*gradient.r);

        Gdiplus::PathGradientBrush* radialGradientBrush = new Gdiplus::PathGradientBrush(&ellipticalPath);
        radialGradientBrush->SetInterpolationColors(presetColors.data(), blendPositions.data(), static_cast<int>(stopCount));
        radialGradientBrush->SetCenterPoint(Gdiplus::PointF(gradient.fx, gradient.fy));

        if (matrix != nullptr)
        {
            radialGradientBrush->SetTransform(matrix);
        }

        radialGradientBrush->SetWrapMode(wrapMode);

        resultBrush = std::unique_ptr<Gdiplus::Brush>(radialGradientBrush);
    }

    return resultBrush;
}

void GDIPlusSVGRenderer::DrawPath(const Path& renderPath, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    SVG_ASSERT(mContext);
    Save(graphicStyle);

    std::unique_ptr<Gdiplus::GraphicsPath> path(dynamic_cast<const GDIPlusSVGPath&>(renderPath).GetGraphicsPath().Clone());
    if (fillStyle.fillRule == WindingRule::kEvenOdd)
        path->SetFillMode(Gdiplus::FillModeAlternate);
    else
        path->SetFillMode(Gdiplus::FillModeWinding);

    mContext->SetSmoothingMode(Gdiplus::SmoothingModeHighQuality);

    std::unique_ptr<Gdiplus::Brush> brush;
    if (fillStyle.hasFill)
    {
        if (SVGNative::holds_alternative<Color>(fillStyle.paint))
        {
            auto color = SVGNative::get<Color>(fillStyle.paint);
            color[3] *= fillStyle.fillOpacity * mOpacityStack.top();

            Gdiplus::Color brushColor = ColorToGdiplusColor(color);
            brush = std::unique_ptr<Gdiplus::Brush>(new Gdiplus::SolidBrush(brushColor));
        }
        else if (SVGNative::holds_alternative<Gradient>(fillStyle.paint))
        {
            const auto& gradient = SVGNative::get<Gradient>(fillStyle.paint);
            brush = CreateGradientBrush(gradient, fillStyle.fillOpacity);
        }

        mContext->FillPath(brush.get(), path.get());
    }

    if (strokeStyle.hasStroke)
    {
        std::unique_ptr<Gdiplus::Pen> pen;
        if (SVGNative::holds_alternative<Color>(strokeStyle.paint))
        {
            auto color = SVGNative::get<Color>(strokeStyle.paint);
            color[3] *= strokeStyle.strokeOpacity * mOpacityStack.top();

            Gdiplus::Color penColor = ColorToGdiplusColor(color);
            pen = std::unique_ptr<Gdiplus::Pen>(new Gdiplus::Pen(penColor, strokeStyle.lineWidth));
        }
        else if (SVGNative::holds_alternative<Gradient>(strokeStyle.paint))
        {
            const auto& gradient = SVGNative::get<Gradient>(fillStyle.paint);
            brush = CreateGradientBrush(gradient, fillStyle.fillOpacity * mOpacityStack.top());
            pen = std::unique_ptr<Gdiplus::Pen>(new Gdiplus::Pen(brush.get(), strokeStyle.lineWidth));
        }

        switch (strokeStyle.lineCap)
        {
            case LineCap::kButt:
                pen->SetLineCap(Gdiplus::LineCapFlat, Gdiplus::LineCapFlat, Gdiplus::DashCapFlat);
                break;
            case LineCap::kRound:
                pen->SetLineCap(Gdiplus::LineCapRound, Gdiplus::LineCapRound, Gdiplus::DashCapRound);
                break;
            case LineCap::kSquare:
                pen->SetLineCap(Gdiplus::LineCapSquare, Gdiplus::LineCapSquare, Gdiplus::DashCapFlat);
                break;
        }

        switch (strokeStyle.lineJoin)
        {
            case LineJoin::kMiter:
                pen->SetLineJoin(Gdiplus::LineJoinMiter);
                break;
            case LineJoin::kRound:
                pen->SetLineJoin(Gdiplus::LineJoinRound);
                break;
            case LineJoin::kBevel:
                pen->SetLineJoin(Gdiplus::LineJoinBevel);
                break;
        }

        if (!strokeStyle.dashArray.empty())
        {
            pen->SetDashStyle(Gdiplus::DashStyleDash);
            pen->SetDashOffset(strokeStyle.dashOffset);

            std::vector<float> dashArray = strokeStyle.dashArray;
            if (dashArray.size() % 2 == 1)
            {
                // Gdiplus doesn't do SVG's odd case which duplicates array to make it even.
                dashArray.insert(dashArray.end(), strokeStyle.dashArray.begin(), strokeStyle.dashArray.end());
            }

            pen->SetDashPattern(dashArray.data(), static_cast<int>(dashArray.size()));
        }

        pen->SetMiterLimit(strokeStyle.miterLimit);

        mContext->DrawPath(pen.get(), path.get());
    }

    Restore();
}

void GDIPlusSVGRenderer::DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea)
{
    const GDIPlusSVGImageData& gdiPlusImage(dynamic_cast<const GDIPlusSVGImageData&>(image));
    if (gdiPlusImage.GetImage())
    {
        Save(graphicStyle);

        if (clipArea.width < fillArea.width || clipArea.height < fillArea.height)
        {
            mContext->SetClip(Gdiplus::RectF(clipArea.x, clipArea.y, clipArea.width, clipArea.height));
        }

        mContext->DrawImage(gdiPlusImage.GetImage().get(), Gdiplus::RectF(fillArea.x, 0, fillArea.width, fillArea.height));

        Restore();
    }
}

} // namespace SVGNative
</file>

<file path="svgnative/test/path.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="250" viewBox="0 0 150 250">
    <polygon points=".9"/>
    <polygon points=".9 .9"/>
    <polygon points=".9 .9 .9"/>
    <polygon points=".9.9 .7.7 .6.6"/>
    <polygon points=".9.9.7.7.6.6"/>
    <polygon points=".9 .9.7 .7.6 .6"/>
    <polygon points=".9.9,.7.7,.6.6"/>
    <polygon points=".9.9 ,
    .7.7  ,  .6.6"/>
    <polygon points=".9,.9 .7,.7 .6,.6"/>
    <path d="M83.858-14H37.205a50.742,50.742,0,0,0-50.6-47,50.75,50.75,0,0,0-50.75,50.75A50.75,50.75,0,0,0-13.392,40.5c1.433,0,2.847-.074,4.25-.191V68H40.7c4.49-5.993,9.618-13.1,15.154-22A277.752,277.752,0,0,0,83.858-14Z"/>
    <path fill="green" d="M 20 100 L 40 100 L 40 120 L 20 120 z"/>
    <path fill="green" d="M 40,100 L 60,100 L 60,120 L 40,120 z"/>
    <path fill="green" d="M60,100L80,100L80,120L60,120z"/>
    <path fill="green" d="M.8e2.1e3L.1e3.1e3L.1e3.12e3L.8e2.12e3z"/>
    <path fill="green" d="M100,100Zm0,0l20,0v20zm0,0v20h20z"/>
    <path fill="green" d="M120,100,140,100,140,120,120,120z"/>
    <path fill="green" d="m20,120,20,0l0,20,-20,0z"/>
    <path fill="green" d="m.4e2.12e3.2e2.0.0.2e2-.2e2.0z"/>
    <path fill="green" d="M0,0ZZ ZM100,100 L 150,100 L 150 150 z"/>
    <path fill="green" d="   M0,0 L100,100    "/>
    <path fill="green" d="M 0 0 L 50 0 L 100 0 z L 100 100 L 0 100 z"/>
    <path fill="green" d="M 0 100 m 50 0 z m 50 0 L 100 200 L 0 200 z"/>
    <path fill="green" d="M 0 200 L 25 200 m 25 0 z m 50 0 L 100 300 L 0 300 z"/>

    <!-- negative tests -->
    <!-- Comma before segment identifier supported by WebKit & Blink; not by spec -->
    <path fill="green" d="M60,120,L80,120,L80,140,L60,140,z"/>
    <!-- Comma right after segment identifier not supported anywhere -->
    <path fill="green" d="M,80,120L,100,120L,100,140L,80,140z"/>
    <!-- No number after closePath -->
    <path fill="green" d="M0,0L60,60L60,120z2.1e3L.1e3.1e3L.1e3.1.8e2.12e3z"/>
    <!-- No commma after closePath -->
    <path fill="green" d="M100,100Z,M100,100 L 150,100 L 150 150 z"/>
    <!--The first segment must be a moveTo -->
    <path fill="green" d="    100,100"/>
    <path fill="green" d="100,100 150,100 150,150"/>
    <path fill="green" d="  L100,100 100,100"/>
    <!-- quadratic curves -->
    <path fill="green" d="M 100 100 Q 150 50 200 100 T 250 150 t 50 -100 q 50 -100 100 50"/>
</svg>
</file>

<file path="svgnative/test/path.txt">
[group transform: matrix(1,0,0,1,0,0)
    [group
        [group
            [path
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 L0.7,0.7 L0.6,0.6 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 L0.7,0.7 L0.6,0.6 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 L0.7,0.7 L0.6,0.6 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 L0.7,0.7 L0.6,0.6 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 L0.7,0.7 L0.6,0.6 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0.9,0.9 L0.7,0.7 L0.6,0.6 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M83.9,-14 L37.2,-14 C35.2,-40.5,13.2,-61,-13.4,-61 C-41.4,-61,-64.1,-38.3,-64.1,-10.2 C-64.1,17.8,-41.4,40.5,-13.4,40.5 C-12,40.5,-10.5,40.4,-9.14,40.3 L-9.14,68 L40.7,68 C45.2,62,50.3,54.9,55.9,46 C67.5,27.2,76.9,7.05,83.9,-14 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M20,100 L40,100 L40,120 L20,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M40,100 L60,100 L60,120 L40,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M60,100 L80,100 L80,120 L60,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M80,100 L100,100 L100,120 L80,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M100,100 Z M100,100 L120,100 L120,120 Z M100,100 L100,120 L120,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M120,100 L140,100 L140,120 L120,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M20,120 L40,120 L40,140 L20,140 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M40,120 L60,120 L60,140 L40,140 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,0 Z M100,100 L150,100 L150,150 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,0 L100,100
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,0 L50,0 L100,0 Z M0,0 L100,100 L0,100 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,100 M50,100 Z M100,100 L100,200 L0,200 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,200 L25,200 M50,200 Z M100,200 L100,300 L0,300 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M60,120
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M80,120 L100,120 L100,140 L80,140 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M0,0 L60,60 L60,120 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M100,100 Z
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
            [path M100,100 Q150,50,200,100 Q250,150,250,150 Q250,150,300,50 Q350,-50,400,100
                fill: {hasFill: true winding: nonzero paint: rgba(0,0.502,0,1)}
                stroke: {hasStroke: false width: 1 cap: butt join: miter miter: 4 dashOffset: 0 paint: rgba(0,0,0,1)}]
        ]
    ]
]
</file>

<file path="svgnative/src/ports/cairo/CairoSVGRenderer.cpp">
/*
Copyright 2019 suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/ports/cairo/CairoSVGRenderer.h"
#include "base64.h"
#include "svgnative/Config.h"
#include "cairo.h"
#include <math.h>
#include "CairoImageInfo.h"

namespace SVGNative
{
CairoSVGPath::CairoSVGPath()
{
#if CAIRO_HAS_IMAGE_SURFACE
    cairo_surface_t* sf = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1, 1);
#elif CAIRO_HAS_RECORDING_SURFACE
    cairo_surface_t* sf = cairo_recording_surface_create(CAIRO_CONTENT_COLOR_ALPHA, NULL);
#endif
    mPathCtx = cairo_create(sf);
}

CairoSVGPath::~CairoSVGPath()
{
    cairo_surface_t* sf = cairo_get_target(mPathCtx);

    cairo_destroy(mPathCtx);
    cairo_surface_finish(sf);
    cairo_surface_destroy(sf);
}

void CairoSVGPath::Rect(float x, float y, float width, float height)
{
    cairo_rectangle(mPathCtx, x, y, width, height);
    cairo_close_path(mPathCtx);
}

inline double deg2rad(double deg)
{
    return (deg * M_PI / 180.0);
}

inline void cairo_arc_rx_ry(cairo_t* cr, float cx, float cy, float rx, float ry, float rad1, float rad2)
{
    // cairo_scale() with too small rx (or ry) breaks Cairo context.
    // they are tested and refused by the caller, SVGDocumentImpl::ParseShape().

    if (rx == ry)
    {
        // cairo_scale(), cairo_restore() are heavy calculation for some CPUs.
        // for the cases we can draw without them, draw like this.
        cairo_arc(cr, cx, cy, rx, rad1, rad2);
    }
    else
    {
        cairo_save(cr);
        cairo_translate(cr, cx, cy);
        cairo_scale(cr, rx, ry);
        cairo_arc(cr, 0, 0, 1, rad1, rad2);
        cairo_restore(cr);
    }
}

void CairoSVGPath::RoundedRect(float x, float y, float width, float height, float rx, float ry)
{
    // Cairo does not provide single API to draw "rounded rect". See
    // https://www.cairographics.org/samples/rounded_rectangle/

    cairo_new_sub_path(mPathCtx);
    cairo_arc_rx_ry(mPathCtx, x - rx + width, y + ry,          rx, ry, deg2rad(-90), deg2rad(  0));
    cairo_arc_rx_ry(mPathCtx, x - rx + width, y - ry + height, rx, ry, deg2rad(  0), deg2rad( 90));
    cairo_arc_rx_ry(mPathCtx, x + rx,         y - ry + height, rx, ry, deg2rad( 90), deg2rad(180));
    cairo_arc_rx_ry(mPathCtx, x + rx,         y + ry,          rx, ry, deg2rad(180), deg2rad(270));
    cairo_close_path(mPathCtx);
}

void CairoSVGPath::Ellipse(float cx, float cy, float rx, float ry)
{
    // Cairo does not provide single API to draw "ellipse". See
    // https://cairographics.org/cookbook/ellipses/

    cairo_matrix_t  save_matrix;
    cairo_get_matrix(mPathCtx, &save_matrix);

    cairo_translate(mPathCtx, cx, cy);
    cairo_scale(mPathCtx, rx, ry);
    cairo_new_sub_path(mPathCtx);
    cairo_arc(mPathCtx, 0, 0, 1, 0, 2 * M_PI);

    cairo_set_matrix(mPathCtx, &save_matrix);
}

void CairoSVGPath::MoveTo(float x, float y)
{
    cairo_move_to(mPathCtx, x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void CairoSVGPath::LineTo(float x, float y)
{
    cairo_line_to(mPathCtx, x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void CairoSVGPath::CurveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{
    cairo_curve_to(mPathCtx, x1, y1, x2, y2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void CairoSVGPath::CurveToV(float x2, float y2, float x3, float y3)
{
    float cx1 = mCurrentX + 2.0f / 3.0f * (x2 - mCurrentX);
    float cy1 = mCurrentY + 2.0f / 3.0f * (y2 - mCurrentY);
    float cx2 = x3 + 2.0f / 3.0f * (x2 - x3);
    float cy2 = y3 + 2.0f / 3.0f * (y2 - y3);

    cairo_curve_to(mPathCtx, cx1, cy1, cx2, cy2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void CairoSVGPath::ClosePath()
{
    cairo_close_path(mPathCtx);
}

CairoSVGTransform::CairoSVGTransform(float a, float b, float c, float d, float tx, float ty)
{
    cairo_matrix_init(&mMatrix, a, b, c, d, tx, ty);
}

void CairoSVGTransform::Set(float a, float b, float c, float d, float tx, float ty)
{
    cairo_matrix_init(&mMatrix, a, b, c, d, tx, ty);
}

void CairoSVGTransform::Rotate(float degree)
{
    cairo_matrix_rotate(&mMatrix, deg2rad(degree) );
}

void CairoSVGTransform::Translate(float tx, float ty)
{
    cairo_matrix_translate(&mMatrix, tx, ty);
}

void CairoSVGTransform::Scale(float sx, float sy)
{
    cairo_matrix_scale(&mMatrix, sx, sy);
}

void CairoSVGTransform::Concat(float a, float b, float c, float d, float tx, float ty)
{
    cairo_matrix_t other{a, b, c, d, tx, ty};
    cairo_matrix_multiply(&mMatrix, &other, &mMatrix);
}

CairoSVGImageData::CairoSVGImageData(const std::string& base64, ImageEncoding encoding)
{
    std::string imageString = base64_decode(base64);
    const unsigned char* blob_data = (const unsigned char*)malloc(imageString.size());
    if (!blob_data)
        throw("no memory\n");
    memcpy((void *)blob_data, imageString.data(), imageString.size());

    if (encoding == ImageEncoding::kJPEG)
    {
        mImageData = _cairo_image_surface_create_from_jpeg_stream(blob_data, imageString.size());
        if (mImageData)
        {
            cairo_surface_set_mime_data(mImageData, "image/jpeg", blob_data, imageString.size(), free, (void*)blob_data);
            return;
        }
    }
    else if (encoding == ImageEncoding::kPNG)
    {
        /* this closure is used during the construction of the surface, but no need in later */
        _png_blob_closure_t png_closure{ blob_data, 0, imageString.size() };
        mImageData = cairo_image_surface_create_from_png_stream(_png_blob_read_func, &png_closure);
        if (mImageData)
        {
            cairo_surface_set_mime_data(mImageData, "image/png", blob_data, imageString.size(), free, (void*)blob_data);
            return;
        }
    }
    free((void *)blob_data);
    throw("image is broken, or not PNG or JPEG\n");
}

CairoSVGImageData::~CairoSVGImageData()
{
    cairo_surface_destroy(mImageData);
}

float CairoSVGImageData::Width() const
{
    if (!mImageData)
        return 0;
    return static_cast<float>(cairo_image_surface_get_width(mImageData));
}

float CairoSVGImageData::Height() const
{
    if (!mImageData)
        return 0;
    return static_cast<float>(cairo_image_surface_get_height(mImageData));
}

CairoSVGRenderer::CairoSVGRenderer()
{
}

CairoSVGRenderer::~CairoSVGRenderer()
{
}

inline cairo_path_t* getPathObjFromCairoSvgPath( const Path* path )
{
    cairo_t* cr = static_cast<const CairoSVGPath*>(path)->mPathCtx;
    return cairo_copy_path(cr);
}

inline cairo_path_t* getTransformedClippingPath( const ClippingPath* clippingPath )
{
    cairo_path_t* path = getPathObjFromCairoSvgPath(clippingPath->path.get());
    if (!clippingPath->transform)
        return path;

    cairo_matrix_t matrix = static_cast<const CairoSVGTransform*>(clippingPath->transform.get())->mMatrix;
    cairo_path_t* pathTransformed = (cairo_path_t*)malloc(sizeof(cairo_path_t));
    pathTransformed->num_data = path->num_data;
    pathTransformed->status = path->status;
    pathTransformed->data = (cairo_path_data_t*)malloc(path->num_data * sizeof(cairo_path_data_t));
    for (int i = 0; i < path->num_data; i += path->data[i].header.length)
    {
        pathTransformed->data[i].header = path->data[i].header;
        for (int j = 1; j < path->data[i].header.length; j ++)
        {
            double x = path->data[i+j].point.x;
            double y = path->data[i+j].point.y;
            cairo_matrix_transform_point(&matrix, &x, &y);
            pathTransformed->data[i+j].point.x = x;
            pathTransformed->data[i+j].point.y = y;
        }
    }
    cairo_path_destroy(path);
    return pathTransformed;
}

inline void setCairoFillAndClipRule(cairo_t* cr, WindingRule rule)
{
    // Cairo reuses the fill-rule to control clipping behaviour.

    switch (rule)
    {
    case WindingRule::kEvenOdd:
        cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);
        return;
    case WindingRule::kNonZero:
    default:
        cairo_set_fill_rule(cr, CAIRO_FILL_RULE_WINDING);
        return;
    }
}

void CairoSVGRenderer::Save(const GraphicStyle& graphicStyle)
{
    SVG_ASSERT(mCairo);
    cairo_save(mCairo);

    if (graphicStyle.transform)
        cairo_transform(mCairo, &(static_cast<CairoSVGTransform*>(graphicStyle.transform.get())->mMatrix));

    if (graphicStyle.clippingPath && graphicStyle.clippingPath->path)
    {
        cairo_path_t* path = getTransformedClippingPath( graphicStyle.clippingPath.get() );
        cairo_append_path(mCairo, path);
        setCairoFillAndClipRule(mCairo, graphicStyle.clippingPath->clipRule);
        cairo_clip(mCairo);
        cairo_path_destroy(path);
    }
}

void CairoSVGRenderer::Restore()
{
    SVG_ASSERT(mCairo);
    cairo_restore(mCairo);
}

inline void createCairoPattern(const Paint& paint, float opacity, cairo_pattern_t** pat)
{
    *pat = NULL;

    if (paint.type() != typeid(Gradient))
        return;

    const auto& gradient = SVGNative::get<Gradient>(paint);

    SVG_ASSERT(gradient.type <= GradientType::kRadialGradient);

    // in Cairo, gradient type might be set before setting color stops. See
    // https://www.cairographics.org/samples/gradient/
    switch (gradient.type)
    {
    case GradientType::kLinearGradient:
        *pat = cairo_pattern_create_linear(gradient.x1, gradient.y1,
                                           gradient.x2, gradient.y2);
        break;

    case GradientType::kRadialGradient:
        *pat = cairo_pattern_create_radial(gradient.fx, gradient.fy, 0,
                                           gradient.cx, gradient.cy, gradient.r);
        break;
    default:
        throw("unsupported gradient type\n");
    }

    // set transform matrix
    if (gradient.transform)
        cairo_pattern_set_matrix(*pat, &(static_cast<CairoSVGTransform*>(gradient.transform.get())->mMatrix));

    // set "stop"s of gradient
    for (const auto& stop : gradient.colorStops)
    {
        // here, ColorStop is a pair of offset (in float) and color
        const auto& stopOffset = stop.first;
        const auto& stopColor = stop.second;

        cairo_pattern_add_color_stop_rgba(*pat, stopOffset,
                                          stopColor[0],
                                          stopColor[1],
                                          stopColor[2],
                                          opacity * stopColor[3]);
    }

    // set the mode how to fill the wide area by a small pattern
    switch (gradient.method)
    {
    case SpreadMethod::kReflect:
        cairo_pattern_set_extend(*pat, CAIRO_EXTEND_REFLECT);
        break;
    case SpreadMethod::kRepeat:
        cairo_pattern_set_extend(*pat, CAIRO_EXTEND_REPEAT);
        break;
    case SpreadMethod::kPad:
        cairo_pattern_set_extend(*pat, CAIRO_EXTEND_PAD);
        break;
    default:
        cairo_pattern_set_extend(*pat, CAIRO_EXTEND_NONE);
        break;
    }
    return;
}

inline void appendCairoSvgPath(cairo_t* mCairo, const Path& path)
{
    cairo_path_t* cairoPath = getPathObjFromCairoSvgPath(&path);
    cairo_append_path(mCairo, cairoPath);
    cairo_path_destroy(cairoPath);
}

void CairoSVGRenderer::DrawPath(
    const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    SVG_ASSERT(mCairo);
    Save(graphicStyle);

    if (fillStyle.hasFill)
    {
        if (SVGNative::holds_alternative<Gradient>(fillStyle.paint))
        {
            cairo_pattern_t* pat;
            createCairoPattern(fillStyle.paint, fillStyle.fillOpacity * graphicStyle.opacity, &pat);
            cairo_set_source(mCairo, pat);
        }
        else
        {
            const auto& color = SVGNative::get<Color>(fillStyle.paint);
            cairo_set_source_rgba(mCairo,
                                  color[0],
                                  color[1],
                                  color[2],
                                  color[3] * fillStyle.fillOpacity * graphicStyle.opacity);
        }

        cairo_new_path(mCairo);
        appendCairoSvgPath(mCairo, path);
        setCairoFillAndClipRule(mCairo, fillStyle.fillRule);
        cairo_fill(mCairo);
    }
    if (strokeStyle.hasStroke)
    {
        const auto& color = SVGNative::get<Color>(strokeStyle.paint);
        cairo_set_source_rgba(mCairo,
                              color[0],
                              color[1],
                              color[2],
                              color[3] * strokeStyle.strokeOpacity * graphicStyle.opacity);

        cairo_set_line_width(mCairo, strokeStyle.lineWidth);
        cairo_set_miter_limit(mCairo, strokeStyle.miterLimit);
        switch (strokeStyle.lineCap)
        {
        case LineCap::kRound:
            cairo_set_line_cap(mCairo, CAIRO_LINE_CAP_ROUND);
            break;
        case LineCap::kSquare:
            cairo_set_line_cap(mCairo, CAIRO_LINE_CAP_SQUARE);
            break;
        case LineCap::kButt:
        default:
            cairo_set_line_cap(mCairo, CAIRO_LINE_CAP_BUTT);
        }

        switch (strokeStyle.lineJoin)
        {
        case LineJoin::kRound:
            cairo_set_line_join(mCairo, CAIRO_LINE_JOIN_ROUND);
            break;
        case LineJoin::kBevel:
            cairo_set_line_join(mCairo, CAIRO_LINE_JOIN_BEVEL);
            break;
        case LineJoin::kMiter:
        default:
            cairo_set_line_join(mCairo, CAIRO_LINE_JOIN_MITER);
        }

        if (!strokeStyle.dashArray.empty())
        {
            std::vector<double> dashes;
            for (auto dash : strokeStyle.dashArray)
                 dashes.push_back(dash);
            cairo_set_dash(mCairo, dashes.data(), strokeStyle.dashArray.size(), strokeStyle.dashOffset);
        }

        cairo_new_path(mCairo);
        appendCairoSvgPath(mCairo, path);
        cairo_stroke(mCairo);
    }
    Restore();
}

void CairoSVGRenderer::DrawImage(
    const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea)
{
    SVG_ASSERT(mCairo);
    Save(graphicStyle);
    cairo_new_path(mCairo);
    cairo_rectangle(mCairo, clipArea.x, clipArea.y, clipArea.width, clipArea.height);
    cairo_clip(mCairo);

    cairo_surface_t *mImageData = (static_cast<const CairoSVGImageData&>(image)).mImageData;

    cairo_translate(mCairo, fillArea.x, fillArea.y);
    cairo_scale(mCairo, fillArea.width / image.Width(), fillArea.height / image.Height());
    cairo_set_source_surface(mCairo, mImageData, 0, 0);
    cairo_paint_with_alpha(mCairo, graphicStyle.opacity);

    Restore();
}

void CairoSVGRenderer::SetCairo(cairo_t* cr)
{
    SVG_ASSERT(cr);
    mCairo = cr;
}

} // namespace SVGNative
</file>

<file path="svgnative/src/ports/cg/CGSVGRenderer.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include <math.h>

#include "svgnative/ports/cg/CGSVGRenderer.h"
#include "base64.h"
#include "svgnative/Config.h"

namespace SVGNative
{
CGSVGPath::CGSVGPath() { mPath = CGPathCreateMutable(); }

CGSVGPath::~CGSVGPath() { CGPathRelease(mPath); }

void CGSVGPath::Rect(float x, float y, float width, float height) { CGPathAddRect(mPath, 0, {{x, y}, {width, height}}); }

void CGSVGPath::RoundedRect(float x, float y, float width, float height, float rx, float ry)
{
    CGPathAddRoundedRect(mPath, nullptr, {{x, y}, {width, height}}, rx, ry);
}

void CGSVGPath::Ellipse(float cx, float cy, float rx, float ry)
{
    CGPathAddEllipseInRect(mPath, nullptr, {{cx - rx, cy - ry}, {2 * rx, 2 * ry}});
}

void CGSVGPath::MoveTo(float x, float y)
{
    CGPathMoveToPoint(mPath, nullptr, x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void CGSVGPath::LineTo(float x, float y)
{
    CGPathAddLineToPoint(mPath, nullptr, x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void CGSVGPath::CurveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{
    CGPathAddCurveToPoint(mPath, nullptr, x1, y1, x2, y2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void CGSVGPath::CurveToV(float x2, float y2, float x3, float y3)
{
    CGPathAddQuadCurveToPoint(mPath, nullptr, x2, y2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void CGSVGPath::ClosePath() { CGPathCloseSubpath(mPath); }

CGSVGTransform::CGSVGTransform(float a, float b, float c, float d, float tx, float ty) { mTransform = {a, b, c, d, tx, ty}; }

void CGSVGTransform::Set(float a, float b, float c, float d, float tx, float ty) { mTransform = {a, b, c, d, tx, ty}; }

void CGSVGTransform::Rotate(float degree) {
    mTransform = CGAffineTransformRotate(mTransform, degree * M_PI / 180.0);
}

void CGSVGTransform::Translate(float tx, float ty) { mTransform = CGAffineTransformTranslate(mTransform, tx, ty); }

void CGSVGTransform::Scale(float sx, float sy) { mTransform = CGAffineTransformScale(mTransform, sx, sy); }

void CGSVGTransform::Concat(float a, float b, float c, float d, float tx, float ty)
{
    mTransform = CGAffineTransformConcat({a, b, c, d, tx, ty}, mTransform);
}

CGSVGImageData::CGSVGImageData(const std::string& base64, ImageEncoding encoding)
{
    std::string imageString = base64_decode(base64);
    auto dataProvider = CGDataProviderCreateWithCFData(CFDataCreate(NULL, (const UInt8*)imageString.data(), imageString.size()));
    if (encoding == ImageEncoding::kPNG)
        mImage = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
    else if (encoding == ImageEncoding::kJPEG)
        mImage = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
}

CGSVGImageData::~CGSVGImageData()
{
    if (mImage)
        CGImageRelease(mImage);
    mImage = nullptr;
}

float CGSVGImageData::Width() const
{
    if (!mImage)
        return 0;
    return static_cast<float>(CGImageGetWidth(mImage));
}

float CGSVGImageData::Height() const
{
    if (!mImage)
        return 0;
    return static_cast<float>(CGImageGetHeight(mImage));
}

CGSVGRenderer::CGSVGRenderer() {}

void CGSVGRenderer::Save(const GraphicStyle& graphicStyle)
{
    SVG_ASSERT(mContext);
    CGContextSaveGState(mContext);
    if (graphicStyle.transform)
        CGContextConcatCTM(mContext, static_cast<CGSVGTransform*>(graphicStyle.transform.get())->mTransform);
    if (graphicStyle.clippingPath)
    {
        CGContextBeginPath(mContext);
        auto path = static_cast<const CGSVGPath*>(graphicStyle.clippingPath->path.get())->mPath;
        if (graphicStyle.clippingPath->transform)
        {
            auto newPath = CGPathCreateCopyByTransformingPath(path, &static_cast<CGSVGTransform*>(graphicStyle.clippingPath->transform.get())->mTransform);
            CGContextAddPath(mContext, newPath);
            CGPathRelease(newPath);
        }
        else
            CGContextAddPath(mContext, path);
        if (graphicStyle.clippingPath->clipRule == WindingRule::kEvenOdd)
            CGContextEOClip(mContext);
        else
            CGContextClip(mContext);
    }
    CGContextSetAlpha(mContext, graphicStyle.opacity);
    CGContextBeginTransparencyLayer(mContext, 0);
}

void CGSVGRenderer::Restore()
{
    SVG_ASSERT(mContext);
    CGContextEndTransparencyLayer(mContext);
    CGContextRestoreGState(mContext);
}

void CGSVGRenderer::DrawGradientToContext(const Gradient& gradient, float opacity)
{
    CGGradientDrawingOptions gradientDrawOptions = kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation;
    std::vector<CGFloat> components;
    std::vector<CGFloat> locations;
    for (const auto& colorStop : gradient.colorStops)
    {
        locations.push_back(colorStop.first);
        const auto& color = colorStop.second;
        components.push_back(color[0]);
        components.push_back(color[1]);
        components.push_back(color[2]);
        components.push_back(color[3] * opacity);
    }
    auto colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);
    auto gradientCG = CGGradientCreateWithColorComponents(colorSpace, components.data(), locations.data(), locations.size());
    if (gradient.type == GradientType::kLinearGradient)
        CGContextDrawLinearGradient(mContext, gradientCG, {gradient.x1, gradient.y1}, {gradient.x2, gradient.y2}, gradientDrawOptions);
    else
        CGContextDrawRadialGradient(
            mContext, gradientCG, {gradient.fx, gradient.fx}, 0, {gradient.cx, gradient.cx}, gradient.r, gradientDrawOptions);
}

void CGSVGRenderer::DrawPath(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    SVG_ASSERT(mContext);
    Save(graphicStyle);
    if (fillStyle.hasFill)
    {
        CGContextBeginPath(mContext);
        CGContextAddPath(mContext, static_cast<const CGSVGPath&>(path).mPath);
        if (SVGNative::holds_alternative<Color>(fillStyle.paint))
        {
            const auto& color = SVGNative::get<Color>(fillStyle.paint);
            CGContextSetRGBFillColor(mContext, color[0], color[1], color[2], color[3] * fillStyle.fillOpacity);
            if (fillStyle.fillRule == WindingRule::kEvenOdd)
                CGContextEOFillPath(mContext);
            else
                CGContextFillPath(mContext);
        }
        else if (SVGNative::holds_alternative<Gradient>(fillStyle.paint))
        {
            const auto& gradient = SVGNative::get<Gradient>(fillStyle.paint);
            CGContextSaveGState(mContext);

            if (gradient.transform)
                CGContextConcatCTM(mContext, static_cast<CGSVGTransform*>(gradient.transform.get())->mTransform);
            if (fillStyle.fillRule == WindingRule::kEvenOdd)
                CGContextEOClip(mContext);
            else
                CGContextClip(mContext);

            DrawGradientToContext(gradient, fillStyle.fillOpacity);

            CGContextRestoreGState(mContext);
        }
    }
    if (strokeStyle.hasStroke)
    {
        switch (strokeStyle.lineCap)
        {
        case LineCap::kButt:
            CGContextSetLineCap(mContext, kCGLineCapButt);
            break;
        case LineCap::kRound:
            CGContextSetLineCap(mContext, kCGLineCapRound);
            break;
        case LineCap::kSquare:
            CGContextSetLineCap(mContext, kCGLineCapSquare);
            break;
        }
        switch (strokeStyle.lineJoin)
        {
        case LineJoin::kMiter:
            CGContextSetLineJoin(mContext, kCGLineJoinMiter);
            break;
        case LineJoin::kRound:
            CGContextSetLineJoin(mContext, kCGLineJoinRound);
            break;
        case LineJoin::kBevel:
            CGContextSetLineJoin(mContext, kCGLineJoinBevel);
            break;
        }
        CGContextSetMiterLimit(mContext, strokeStyle.miterLimit);
        CGContextSetLineWidth(mContext, strokeStyle.lineWidth);

        CGContextBeginPath(mContext);
        CGContextAddPath(mContext, static_cast<const CGSVGPath&>(path).mPath);
        if (SVGNative::holds_alternative<Color>(strokeStyle.paint))
        {
            const auto& color = SVGNative::get<Color>(strokeStyle.paint);
            CGContextSetRGBStrokeColor(mContext, color[0], color[1], color[2], color[3] * strokeStyle.strokeOpacity);
            CGContextStrokePath(mContext);
        }
        else if (SVGNative::holds_alternative<Gradient>(strokeStyle.paint))
        {
            const auto& gradient = SVGNative::get<Gradient>(strokeStyle.paint);
            CGContextSaveGState(mContext);

            CGContextReplacePathWithStrokedPath(mContext);
            CGContextClip(mContext);
            if (gradient.transform)
                CGContextConcatCTM(mContext, static_cast<CGSVGTransform*>(gradient.transform.get())->mTransform);

            DrawGradientToContext(gradient, strokeStyle.strokeOpacity);

            CGContextRestoreGState(mContext);
        }
    }
    CGContextSetShouldAntialias(mContext, true);
    Restore();
}

void CGSVGRenderer::DrawImage(const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea)
{
    SVG_ASSERT(mContext);
    Save(graphicStyle);
    if (clipArea.width < fillArea.width || clipArea.height < fillArea.height)
        CGContextClipToRect(mContext, {{clipArea.x, clipArea.y}, {clipArea.width, clipArea.height}});
    // CG flips back the context for images
    CGContextTranslateCTM(mContext, 0, fillArea.y + fillArea.height);
    CGContextScaleCTM(mContext, 1, -1);
    CGContextDrawImage(mContext, {{fillArea.x, 0}, {fillArea.width, fillArea.height}}, static_cast<const CGSVGImageData&>(image).mImage);
    Restore();
}

} // namespace SVGNative
</file>

<file path="svgnative/src/SVGDocument.cpp">
/*
Copyright 2014 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/SVGDocument.h"
#include "SVGDocumentImpl.h"
#include "svgnative/SVGRenderer.h"
#ifdef STYLE_SUPPORT
#include "StyleSheet/Document.h"
#include "StyleSheet/Parser.h"
#endif

#include "xml/XMLParser.h"

#include <stdexcept>
#include <stdlib.h>
#include <string>

namespace SVGNative
{
std::unique_ptr<SVGDocument> SVGDocument::CreateSVGDocument(const char* s, std::shared_ptr<SVGRenderer> renderer)
{
    try
    {
        if (!renderer)
            return nullptr;
        auto xmlDocument = xml::XMLDocument::CreateXMLDocument(s);
        if (!xmlDocument)
            return nullptr;
        auto rootNode = xmlDocument->GetFirstNode();
        if (!rootNode)
            return nullptr;
        auto realSVGDoc = std::unique_ptr<SVGDocumentImpl>(new SVGDocumentImpl(renderer));
        if (!realSVGDoc)
            return nullptr;
        realSVGDoc->TraverseSVGTree(rootNode.get());

        auto retval = new SVGDocument();
        retval->mDocument = std::move(realSVGDoc);

        return std::unique_ptr<SVGDocument>(retval);
    }
    catch (...)
    {
    }

    return nullptr;
}

SVGDocument::SVGDocument() {}

SVGDocument::~SVGDocument() {}

void SVGDocument::Render()
{
    if (!mDocument)
        return;

    ColorMap colorMap;
    mDocument->Render(colorMap, mDocument->mViewBox[2], mDocument->mViewBox[3]);
}

void SVGDocument::Render(float width, float height)
{
    if (!mDocument)
        return;

    ColorMap colorMap;
    mDocument->Render(colorMap, width, height);
}

void SVGDocument::Render(const ColorMap& colorMap)
{
    if (!mDocument)
        return;

    mDocument->Render(colorMap, mDocument->mViewBox[2], mDocument->mViewBox[3]);
}

void SVGDocument::Render(const ColorMap& colorMap, float width, float height) {
    if (!mDocument)
        return;

    mDocument->Render(colorMap, width, height);
}

void SVGDocument::Render(const char* id)
{
    if (!mDocument)
        return;

    ColorMap colorMap;
    mDocument->Render(id, colorMap, mDocument->mViewBox[2], mDocument->mViewBox[3]);
}

void SVGDocument::Render(const char* id, float width, float height)
{
    if (!mDocument)
        return;

    ColorMap colorMap;
    mDocument->Render(id, colorMap, width, height);
}

void SVGDocument::Render(const char* id, const ColorMap& colorMap)
{
    if (!mDocument)
        return;

    mDocument->Render(id, colorMap, mDocument->mViewBox[2], mDocument->mViewBox[3]);
}

void SVGDocument::Render(const char* id, const ColorMap& colorMap, float width, float height)
{
    if (!mDocument)
        return;

    mDocument->Render(id, colorMap, width, height);
}

bool SVGDocument::GetBoundingBox(Rect& bounds)
{
    if (!mDocument)
        return false;
    return mDocument->GetBoundingBox(bounds);
}

bool SVGDocument::GetBoundingBox(const char *id, Rect& bounds)
{
    if (!mDocument)
        return false;
    return mDocument->GetBoundingBox(id, bounds);
}

void SVGDocument::GetViewBox(Rect& viewBox)
{
    viewBox.x = mDocument->mViewBox[0];
    viewBox.y = mDocument->mViewBox[1];
    viewBox.width = mDocument->mViewBox[2];
    viewBox.height = mDocument->mViewBox[3];
}

#ifdef DEBUG_API
bool GetSubBoundingBoxes(std::vector<Rect>& bounds)
{
    if (!mDocument)
        return false;
    return mDocument->GetSubBoundingBoxes(bounds);
}
#endif

std::int32_t SVGDocument::Width() const
{
    if (!mDocument)
        return 0;

    return static_cast<std::int32_t>(mDocument->mViewBox[2]);
}

std::int32_t SVGDocument::Height() const {
    if (!mDocument)
        return 0;

    return static_cast<std::int32_t>(mDocument->mViewBox[3]);
}

SVGRenderer* SVGDocument::Renderer() const
{
    if (!mDocument)
        return 0;

    return mDocument->mRenderer.get();
}

#ifdef STYLE_SUPPORT
void SVGDocument::AddCustomCSS(const StyleSheet::CssDocument* cssDocument)
{
    if (!mDocument)
        return;

    mDocument->AddCustomCSS(cssDocument);
}

void SVGDocument::ClearCustomCSS()
{
    if (!mDocument)
        return;

    mDocument->ClearCustomCSS();
}
#endif
} // namespace SVGNative
</file>

<file path="svgnative/src/SVGNativeCWrapper.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/SVGNativeCWrapper.h"
#include "svgnative/SVGDocument.h"
#include "svgnative/SVGRenderer.h"
#ifdef USE_CAIRO
#include "svgnative/ports/cairo/CairoSVGRenderer.h"
#endif
#ifdef USE_CG
#include "svgnative/ports/cg/CGSVGRenderer.h"
#include <CoreServices/CoreServices.h>
#include <CoreGraphics/CoreGraphics.h>
#endif
#ifdef USE_SKIA
#include "svgnative/ports/skia/SkiaSVGRenderer.h"
#include "SkCanvas.h"
#include "SkImage.h"
#endif
#ifdef USE_GDIPLUS
#include <windows.h>
#include <Gdiplus.h>
#include "svgnative/ports/gdiplus/GDIPlusSVGRenderer.h"
#endif
#ifdef USE_TEXT
#include "svgnative/ports/string/StringSVGRenderer.h"
#endif

#include <map>
#include <memory>

template <typename T>
void ignore(T &&)
{ }

struct svg_native_color_map_t_
{
    SVGNative::ColorMap mColorMap;
};

struct svg_native_t_
{
    std::shared_ptr<SVGNative::SVGRenderer> mRenderer;
    std::unique_ptr<SVGNative::SVGDocument> mDocument;
    svg_native_renderer_type_t mRendererType{SVG_RENDERER_UNKNOWN};
    svg_native_color_map_t* mColorMap{};
};

svg_native_color_map_t* svg_native_color_map_create()
{
    return reinterpret_cast<svg_native_color_map_t*>(new svg_native_color_map_t_);
}

void svg_native_color_map_add(svg_native_color_map_t* color_map, const char* color_key, float red, float green, float blue, float alpha)
{
    if (auto _color_map = dynamic_cast<svg_native_color_map_t_*>(color_map))
    {
        _color_map->mColorMap.insert({color_key, {red, green, blue, alpha}});
    }
}

void svg_native_color_map_destroy(svg_native_color_map_t* color_map)
{
    if (auto _color_map = dynamic_cast<svg_native_color_map_t_*>(color_map))
    {
        delete _color_map;
    }
}

svg_native_t* svg_native_create(svg_native_renderer_type_t renderer_type, const char* document_string)
{
    auto sn = new svg_native_t_;

    switch (renderer_type)
    {
    case SVG_RENDERER_CAIRO:
    {
#ifdef USE_CAIRO
        sn->mRenderer = std::make_shared<SVGNative::CairoSVGRenderer>();
        sn->mRendererType = renderer_type;
#endif
        break;
    }
    case SVG_RENDERER_CG:
    {
#ifdef USE_CG
        sn->mRenderer = std::make_shared<SVGNative::CGSVGRenderer>();
        sn->mRendererType = renderer_type;
#endif
        break;
    }
    case SVG_RENDERER_GDIPLUS:
    {
#ifdef USE_GDIPLUS
        sn->mRenderer = std::make_shared<SVGNative::GDIPlusSVGRenderer>();
        sn->mRendererType = renderer_type;
#endif
        break;
    }
    case SVG_RENDERER_SKIA:
    {
#ifdef USE_SKIA
        sn->mRenderer = std::make_shared<SVGNative::SkiaSVGRenderer>();
        sn->mRendererType = renderer_type;
#endif
        break;
    }
    case SVG_RENDERER_STRING:
    {
#ifdef USE_TEXT
        sn->mRenderer = std::make_shared<SVGNative::StringSVGRenderer>();
        sn->mRendererType = renderer_type;
#endif
        break;
    }
    default:
        break;
    }

    if (!sn->mRenderer)
        return nullptr;

    sn->mDocument = SVGNative::SVGDocument::CreateSVGDocument(document_string, sn->mRenderer);

    return reinterpret_cast<svg_native_t*>(sn);
}

void svg_native_set_color_map(svg_native_t* sn, svg_native_color_map_t* color_map)
{
    if (auto _sn = dynamic_cast<svg_native_t_*>(sn))
    {
        _sn->mColorMap = color_map;
    }
}

void svg_native_set_renderer(svg_native_t* sn, svg_native_renderer_t* renderer)
{
    auto _sn = dynamic_cast<svg_native_t_*>(sn);
    if (!_sn)
        return;

    switch (_sn->mRendererType)
    {
    case SVG_RENDERER_CAIRO:
    {
#ifdef USE_CAIRO
        if (auto nativeRenderer = static_cast<cairo_t*>(renderer))
        {
            if (auto snRenderer = std::dynamic_pointer_cast<SVGNative::CairoSVGRenderer>(_sn->mRenderer))
                snRenderer->SetCairo(nativeRenderer);
            return;
        }
#endif
        break;
    }
    case SVG_RENDERER_CG:
    {
#ifdef USE_CG
        if (auto nativeRenderer = static_cast<CGContextRef>(renderer))
        {
            if (auto snRenderer = std::dynamic_pointer_cast<SVGNative::CGSVGRenderer>(_sn->mRenderer))
                snRenderer->SetGraphicsContext(nativeRenderer);
            return;
        }
#endif
        break;
    }
    case SVG_RENDERER_GDIPLUS:
    {
#ifdef USE_GDIPLUS
        if (auto nativeRenderer = static_cast<Gdiplus::Graphics*>(renderer))
        {
            if (auto snRenderer = std::dynamic_pointer_cast<SVGNative::GDIPlusSVGRenderer>(_sn->mRenderer))
                snRenderer->SetGraphicsContext(nativeRenderer);
            return;
        }
#endif
        break;
    }
    case SVG_RENDERER_SKIA:
    {
#ifdef USE_SKIA
        if (auto nativeRenderer = static_cast<SkCanvas*>(renderer))
        {
            if (auto snRenderer = std::dynamic_pointer_cast<SVGNative::SkiaSVGRenderer>(_sn->mRenderer))
                snRenderer->SetSkCanvas(nativeRenderer);
            return;
        }
#endif
        break;
    }
    default:
        ignore(renderer);
        break;
    }
}

float svg_native_canvas_width(svg_native_t* sn)
{
    auto _sn = dynamic_cast<svg_native_t_*>(sn);
    if (!_sn || !_sn->mDocument)
        return 0;
    return _sn->mDocument->Width();
}

float svg_native_canvas_height(svg_native_t* sn)
{
    auto _sn = dynamic_cast<svg_native_t_*>(sn);
    if (!_sn || !_sn->mDocument)
        return 0;
    return _sn->mDocument->Height();
}

void svg_native_render(svg_native_t* sn)
{
    auto _sn = dynamic_cast<svg_native_t_*>(sn);
    if (!_sn || !_sn->mDocument)
        return;
    
    if (_sn->mColorMap)
        _sn->mDocument->Render(_sn->mColorMap->mColorMap);
    else
        _sn->mDocument->Render();
}

void svg_native_render_size(svg_native_t* sn, float width, float height)
{
    auto _sn = dynamic_cast<svg_native_t_*>(sn);
    if (!_sn || !_sn->mDocument)
        return;
    
    if (_sn->mColorMap)
        _sn->mDocument->Render(_sn->mColorMap->mColorMap, width, height);
    else
        _sn->mDocument->Render(width, height);
}

#ifdef USE_TEXT
void svg_native_get_output(svg_native_t* sn, char** buff, size_t* length)
{
    if (!buff || !length)
        return;

    *buff = NULL;
    *length = 0;

    auto _sn = dynamic_cast<svg_native_t_*>(sn);
    if (!_sn || _sn->mRendererType != SVG_RENDERER_STRING)
        return;

    auto renderer = std::dynamic_pointer_cast<SVGNative::StringSVGRenderer>(_sn->mRenderer);
    if (!renderer)
        return;

    const auto& string = renderer->String();

    auto size = string.length() + 1;
    *buff = (char*)malloc(size * sizeof(char));
    if (!(*buff))
        return;

    memcpy(*buff, string.c_str(), size);
    *length = string.length();

    return;
}
#endif

void svg_native_destroy(svg_native_t* sn)
{
    if (auto _sn = dynamic_cast<svg_native_t_*>(sn))
        delete _sn;
}
</file>

<file path="svgnative/src/ports/skia/SkiaSVGRenderer.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "svgnative/ports/skia/SkiaSVGRenderer.h"
#include "base64.h"
#include "svgnative/Config.h"
#include "SkCanvas.h"
#include "SkCodec.h"
#include "SkData.h"
#include "SkEncodedOrigin.h"
#include "SkGradientShader.h"
#include "SkImage.h"
#include "SkPoint.h"
#include "SkRect.h"
#include "SkRRect.h"
#include "SkShader.h"
#include "SkSurface.h"
#include "SkDashPathEffect.h"
#include "SkTypes.h"
#include "SkSamplingOptions.h"
#include <math.h>

namespace SVGNative
{
SkiaSVGPath::SkiaSVGPath() {}

void SkiaSVGPath::Rect(float x, float y, float width, float height) { mPath.addRect({x, y, x + width, y + height}); }

void SkiaSVGPath::RoundedRect(float x, float y, float width, float height, float rx, float ry)
{
    SkRRect rrect;
    rrect.setRectXY({x, y, x + width, y + height}, rx, ry);
    mPath.addRRect(rrect);
}

void SkiaSVGPath::Ellipse(float cx, float cy, float rx, float ry) { mPath.addOval({cx - rx, cy - ry, cx + rx, cy + ry}); }

void SkiaSVGPath::MoveTo(float x, float y)
{
    mPath.moveTo(x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void SkiaSVGPath::LineTo(float x, float y)
{
    mPath.lineTo(x, y);
    mCurrentX = x;
    mCurrentY = y;
}

void SkiaSVGPath::CurveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{
    mPath.cubicTo(x1, y1, x2, y2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void SkiaSVGPath::CurveToV(float x2, float y2, float x3, float y3)
{
    mPath.quadTo(x2, y2, x3, y3);
    mCurrentX = x3;
    mCurrentY = y3;
}

void SkiaSVGPath::ClosePath() { mPath.close(); }

SkiaSVGTransform::SkiaSVGTransform(float a, float b, float c, float d, float tx, float ty) { Set(a, b, c, d, tx, ty); }

void SkiaSVGTransform::Set(float a, float b, float c, float d, float tx, float ty) { mMatrix.setAll(a, c, tx, b, d, ty, 0, 0, 1); }

void SkiaSVGTransform::Rotate(float degree) { mMatrix.preRotate(degree); }

void SkiaSVGTransform::Translate(float tx, float ty) { mMatrix.preTranslate(tx, ty); }

void SkiaSVGTransform::Scale(float sx, float sy) { mMatrix.preScale(sx, sy, 0.0, 0.0); }

void SkiaSVGTransform::Concat(float a, float b, float c, float d, float tx, float ty)
{
    SkMatrix other;
    other.setAll(a, c, tx, b, d, ty, 0, 0, 1);
    mMatrix.preConcat(other);
}

inline sk_sp<SkImage> getOrientedImage(sk_sp<SkImage> srcImg, SkEncodedOrigin origin)
{
    int width = 0, height = 0;
    int offsetX = 0, offsetY = 0;
    int rot = 0;
    int centerX = 0, centerY = 0;

    switch (origin)
    {
    case SkEncodedOrigin::kBottomRight_SkEncodedOrigin:
        width = srcImg->width();
        height = srcImg->height();
        rot = 180;
        centerX = width / 2;
        centerY = height / 2;
        break;

    case SkEncodedOrigin::kLeftBottom_SkEncodedOrigin:
        width = srcImg->height();
        height = srcImg->width();
        offsetX = width;
        rot = 90;
        break;

    case SkEncodedOrigin::kRightTop_SkEncodedOrigin:
        width = srcImg->height();
        height = srcImg->width();
        offsetY = height;
        rot = 270;
        break;

    default:
        return nullptr;
    }

    auto skRasterSurface = SkSurface::MakeRasterN32Premul(width, height);
    auto skRasterCanvas = skRasterSurface->getCanvas();
    if (offsetX != 0 || offsetY != 0)
        skRasterCanvas->translate(offsetX, offsetY);
    if (rot != 0)
    {
        if (centerX != 0 || centerY != 0)
            skRasterCanvas->rotate(rot, centerX, centerY);
        else
            skRasterCanvas->rotate(rot);
    }
    skRasterCanvas->drawImage(srcImg, 0, 0);
    return skRasterSurface->makeImageSnapshot();
}

SkiaSVGImageData::SkiaSVGImageData(const std::string& base64, ImageEncoding /*encoding*/)
{
    std::string imageString = base64_decode(base64);
    auto skData = SkData::MakeWithCopy(imageString.data(), imageString.size());
    std::unique_ptr<SkCodec> codec = SkCodec::MakeFromData(skData, nullptr);
    if (!codec)
        return;
    SkEncodedOrigin origin = codec->getOrigin();
    if (origin == SkEncodedOrigin::kTopLeft_SkEncodedOrigin)
        mImageData = SkImage::MakeFromEncoded(skData);
    else
    {
        auto rawImg = SkImage::MakeFromEncoded(skData);
        mImageData = getOrientedImage(rawImg, origin);
    }
}

SkiaSVGImageData::~SkiaSVGImageData()
{
}

float SkiaSVGImageData::Width() const
{
    if (!mImageData)
        return 0;
    return static_cast<float>(mImageData->width());
}

float SkiaSVGImageData::Height() const
{
    if (!mImageData)
        return 0;
    return static_cast<float>(mImageData->height());
}

SkiaSVGRenderer::SkiaSVGRenderer() {}

void SkiaSVGRenderer::Save(const GraphicStyle& graphicStyle)
{
    SVG_ASSERT(mCanvas);
    if (graphicStyle.opacity != 1.0)
        mCanvas->saveLayerAlpha(nullptr, static_cast<U8CPU>(graphicStyle.opacity * 255));
    else
        mCanvas->save();
    if (graphicStyle.transform)
        mCanvas->concat(static_cast<SkiaSVGTransform*>(graphicStyle.transform.get())->mMatrix);
    if (graphicStyle.clippingPath && graphicStyle.clippingPath->path)
    {
        SkPath clippingPath(static_cast<const SkiaSVGPath*>(graphicStyle.clippingPath->path.get())->mPath);
        if (graphicStyle.clippingPath->transform)
        {
            const auto& matrix = static_cast<const SkiaSVGTransform*>(graphicStyle.clippingPath->transform.get())->mMatrix;
            clippingPath.transform(matrix);
        }
        clippingPath.setFillType(graphicStyle.clippingPath->clipRule == WindingRule::kNonZero ? SkPathFillType::kWinding : SkPathFillType::kEvenOdd);
        mCanvas->clipPath(clippingPath);
    }
}

void SkiaSVGRenderer::Restore()
{
    SVG_ASSERT(mCanvas);
    mCanvas->restore();
}

inline void CreateSkPaint(const Paint& paint, float opacity, SkPaint& skPaint)
{
    if (SVGNative::holds_alternative<Color>(paint))
    {
        const auto& color = SVGNative::get<Color>(paint);
        skPaint.setColor(SkColorSetARGB(static_cast<uint8_t>(opacity * color[3] * 255), static_cast<uint8_t>(color[0] * 255),
            static_cast<uint8_t>(color[1] * 255), static_cast<uint8_t>(color[2] * 255)));
    }
    if (SVGNative::holds_alternative<Gradient>(paint))
    {
        const auto& gradient = SVGNative::get<Gradient>(paint);
        std::vector<SkColor> colors;
        std::vector<SkScalar> pos;
        for (const auto& stop : gradient.colorStops)
        {
            pos.push_back(stop.first);
            const auto& stopColor = stop.second;
            colors.push_back(SkColorSetARGB(static_cast<uint8_t>(opacity * stopColor[3] * 255), static_cast<uint8_t>(stopColor[0] * 255),
                static_cast<uint8_t>(stopColor[1] * 255), static_cast<uint8_t>(stopColor[2] * 255)));
        }
        SkTileMode mode;
        switch (gradient.method)
        {
        case SpreadMethod::kReflect:
            mode = SkTileMode::kMirror;
            break;
        case SpreadMethod::kRepeat:
            mode = SkTileMode::kRepeat;
            break;
        case SpreadMethod::kPad:
        default:
            mode = SkTileMode::kClamp;
            break;
        }
        SkMatrix* matrix{};
        if (gradient.transform)
            matrix = &(static_cast<SkiaSVGTransform*>(gradient.transform.get())->mMatrix);
        if (gradient.type == GradientType::kLinearGradient)
        {
            SkPoint points[2] = {SkPoint::Make(gradient.x1, gradient.y1), SkPoint::Make(gradient.x2, gradient.y2)};
            skPaint.setShader(
                SkGradientShader::MakeLinear(points, colors.data(), pos.data(), static_cast<int>(colors.size()), mode, 0, matrix));
        }
        else if (gradient.type == GradientType::kRadialGradient)
        {
            skPaint.setShader(
                SkGradientShader::MakeTwoPointConical(SkPoint::Make(gradient.fx, gradient.fy), 0, SkPoint::Make(gradient.cx, gradient.cy),
                    gradient.r, colors.data(), pos.data(), static_cast<int>(colors.size()), mode, 0, matrix));
        }
    }
}

void SkiaSVGRenderer::DrawPath(
    const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    SVG_ASSERT(mCanvas);
    Save(graphicStyle);
    if (fillStyle.hasFill)
    {
        SkPaint fill;
        fill.setAntiAlias(true);
        fill.setStyle(SkPaint::kFill_Style);
        CreateSkPaint(fillStyle.paint, fillStyle.fillOpacity, fill);
        SkPath mPath = (static_cast<const SkiaSVGPath&>(path).mPath);
        mPath.setFillType(fillStyle.fillRule == WindingRule::kNonZero ? SkPathFillType::kWinding : SkPathFillType::kEvenOdd);
        mCanvas->drawPath(mPath, fill);
    }
    if (strokeStyle.hasStroke)
    {
        SkPaint stroke;
        stroke.setAntiAlias(true);
        stroke.setStyle(SkPaint::kStroke_Style);
        stroke.setStrokeWidth(strokeStyle.lineWidth);
        stroke.setStrokeMiter(strokeStyle.miterLimit);
        switch (strokeStyle.lineCap)
        {
          case LineCap::kRound:
              stroke.setStrokeCap(SkPaint::kRound_Cap);
              break;
          case LineCap::kSquare:
              stroke.setStrokeCap(SkPaint::kSquare_Cap);
              break;
          case LineCap::kButt:
          default:
              stroke.setStrokeCap(SkPaint::kButt_Cap);
        }
        switch (strokeStyle.lineJoin)
        {
          case LineJoin::kRound:
              stroke.setStrokeJoin(SkPaint::kRound_Join);
              break;
          case LineJoin::kBevel:
              stroke.setStrokeJoin(SkPaint::kBevel_Join);
              break;
          case LineJoin::kMiter:
          default:
              stroke.setStrokeJoin(SkPaint::kMiter_Join);
        }
        if (!strokeStyle.dashArray.empty())
        {
            stroke.setPathEffect(SkDashPathEffect::Make((SkScalar*)(strokeStyle.dashArray.data()),
                                                        strokeStyle.dashArray.size(),
                                                        (SkScalar)strokeStyle.dashOffset));
        }
        CreateSkPaint(strokeStyle.paint, strokeStyle.strokeOpacity, stroke);
        mCanvas->drawPath(static_cast<const SkiaSVGPath&>(path).mPath, stroke);
    }
    Restore();
}

void SkiaSVGRenderer::DrawImage(
    const ImageData& image, const GraphicStyle& graphicStyle, const Rect& clipArea, const Rect& fillArea)
{
    SVG_ASSERT(mCanvas);
    Save(graphicStyle);
    mCanvas->clipRect({clipArea.x, clipArea.y, clipArea.x + clipArea.width, clipArea.y + clipArea.height}, SkClipOp::kIntersect);
    SkSamplingOptions samplingOptions;
    mCanvas->drawImageRect(static_cast<const SkiaSVGImageData&>(image).mImageData,
        {fillArea.x, fillArea.y, fillArea.x + fillArea.width, fillArea.y + fillArea.height}, samplingOptions, nullptr);
    Restore();
}

Rect SkiaSVGRenderer::GetBounds(const Path& path, const GraphicStyle& graphicStyle, const FillStyle& fillStyle, const StrokeStyle& strokeStyle)
{
    SkRect bounds;
    SVG_ASSERT(mCanvas);
    // we save the state while applying transforms and clippings if needed
    Save(graphicStyle);
    // get the internal SkPath
    SkPath mPath = (static_cast<const SkiaSVGPath&>(path).mPath);
    mPath.setFillType(fillStyle.fillRule == WindingRule::kNonZero ? SkPathFillType::kWinding : SkPathFillType::kEvenOdd);
    // compute the tight fill bounds for the path
    bounds = mPath.computeTightBounds();
    if (strokeStyle.hasStroke)
    {
        // create the stroke paint and then find the stroke bounds
        SkPaint stroke;
        stroke.setStyle(SkPaint::kStroke_Style);
        stroke.setStrokeWidth(strokeStyle.lineWidth);
        if (!strokeStyle.dashArray.empty())
        {
            stroke.setPathEffect(SkDashPathEffect::Make((SkScalar*)(strokeStyle.dashArray.data()),
                        strokeStyle.dashArray.size(),
                        (SkScalar)strokeStyle.dashOffset));
        }
        CreateSkPaint(strokeStyle.paint, strokeStyle.strokeOpacity, stroke);
        SkPath mPath = (static_cast<const SkiaSVGPath&>(path).mPath);
        if (stroke.canComputeFastBounds())
        {
            bounds = stroke.computeFastBounds(bounds, &bounds);
        }
        else
        {
            // TODO: When would canComputeFastBounds return false and how to handle that?
        }
    }

    // if there is clipping, take the clip bounds and intersect them with
    // the bound calculated so far, then return that intersection
    if (graphicStyle.clippingPath && graphicStyle.clippingPath->path)
    {
        Rect old_bounds{bounds.x(), bounds.y(), bounds.width(), bounds.height()};
        SkIRect clip = mCanvas->getDeviceClipBounds();
        Rect clip_bounds{(float)clip.x(), (float)clip.y(), (float)clip.width(), (float)clip.height()};
        Rect new_bounds = clip_bounds;
        bounds = SkRect::MakeXYWH(new_bounds.x, new_bounds.y, new_bounds.width, new_bounds.height);
    }
    Restore();
    Rect snv_bounds = Rect{bounds.x(), bounds.y(), bounds.width(), bounds.height()};
    if (!snv_bounds.IsEmpty())
        return snv_bounds;
    else
        return Rect{0, 0, 0, 0};
}


void SkiaSVGRenderer::SetSkCanvas(SkCanvas* canvas)
{
    SVG_ASSERT(canvas);
    mCanvas = canvas;
}

} // namespace SVGNative
</file>

<file path="svgnative/src/SVGStringParser.cpp">
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "SVGStringParser.h"
#include "CSSColorKeywords.h"
#include "svgnative/SVGDocument.h"
#include <algorithm>
#include <array>
#include <vector>
#define _USE_MATH_DEFINES
#include <cmath>
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif

namespace SVGNative
{
void ArcToCurve(Path& path, float startX, float startY, float radiusX, float radiusY, float angle, bool large, bool sweep, float endX,
    float endY, float& endControlX, float& endControlY);

namespace SVGStringParser
{
using CharIt = std::string::const_iterator;

inline bool isDigit(char c)
{
    return c >= '0' && c <= '9';
}

inline bool isHex(char c)
{
    return isDigit(c) || (c >= 'a' && c <= 'f') ||  (c >= 'A' && c <= 'F');
}

inline bool isWsp(char c) { return c == ' ' || c == '\t' || c == '\n' || c == '\r'; }

inline bool SkipOptWspOrDelimiter(CharIt& pos, const CharIt& end, bool isAllOptional = true, char delimiter = ',')
{
    if (!isAllOptional && !isWsp(*pos) && *pos != delimiter)
        return false;

    while (pos < end && isWsp(*pos))
        pos++;
    if (*pos == delimiter)
        pos++;
    while (pos < end && isWsp(*pos))
        pos++;
    return pos != end;
}

inline bool SkipOptWspDelimiterOptWsp(CharIt& pos, const CharIt& end, char delimiter = ',')
{
    bool hasDelimiter{};
    while (pos < end && isWsp(*pos))
        pos++;
    if (*pos == delimiter)
    {
        hasDelimiter = true;
        pos++;
    }
    while (pos < end && isWsp(*pos))
        pos++;
    return pos != end && hasDelimiter;
}

inline bool SkipOptWspOptPercentageDelimiterOptWsp(CharIt& pos, const CharIt& end, char delimiter, bool& hasPercentage)
{
    bool hasDelimiter{};
    while (pos < end && isWsp(*pos))
        pos++;
    if (*pos == '%')
    {
        hasPercentage = true;
        pos++;
    }
    if (*pos == delimiter)
    {
        hasDelimiter = true;
        pos++;
    }
    while (pos < end && isWsp(*pos))
        pos++;
    return pos != end && hasDelimiter;
}

inline bool SkipOptWsp(CharIt& pos, const CharIt& end)
{
    while (pos < end && isWsp(*pos))
        ++pos;
    return pos != end;
}

inline bool SkipOptWspOptPercentOptWsp(CharIt& pos, const CharIt& end, bool &hasPercentage)
{
    while (pos < end && isWsp(*pos))
        ++pos;
    if (*pos == '%')
    {
        hasPercentage = true;
        pos++;
    }
    else
        hasPercentage = false;
    while (pos < end && isWsp(*pos))
        ++pos;
    return pos != end;
}

inline bool ParseDigit(CharIt& pos, const CharIt& end, std::int32_t& digit)
{
    if (pos == end || !isDigit(*pos))
        return false;
    while (pos < end && isDigit(*pos))
    {
        digit *= 10;
        digit += static_cast<std::int32_t>(*pos++ - '0');
    }
    return true;
}

static bool ParseFloatingPoint(CharIt &pos, const CharIt& end, float& number)
{
    // if there is not a single character to process, just return false
    if (pos == end)
        return false;

    number = 0;

    // by default assume it's a positive number
    float sign{1};

    // get the sign, if present
    if (*pos == '-' || *pos == '+')
    {
        if (*pos == '-')
            sign = -1;
        pos++;
        if (pos == end)
            return false;
    }

    bool hasNumber{};
    bool hasFraction{};

    // parse the number and if we don't have anything else
    // remaining, just return the number with correct sign
    while (pos < end && isDigit(*pos))
    {
        hasNumber = true;
        number *= 10;
        number += static_cast<float>(*pos++ - '0');
    }
    if (pos == end)
    {
        number *= sign;
        return std::isfinite(number);
    }

    // if there is a decimal point
    if (*pos == '.')
    {
        // skip the decimal, if no digits remain, just return
        pos++;
        if (pos == end || !isDigit(*pos))
            return false;

        // read the numbers after decimal while correctly shifting digits
        float division = 10;
        while (pos < end && isDigit(*pos))
        {
            hasFraction = true;
            number += static_cast<float>(*pos++ - '0') / division;
            division *= 10;
        }
    }

    if (!hasFraction && !hasNumber)
        return false;

    number *= sign;
    return std::isfinite(number);
}

static bool ParseScientificNumber(CharIt& pos, const CharIt& end, float& number)
{
    if (pos == end)
        return false;

    number = 0;

    float sign{1};
    float exponent{0};
    float exponentSign{1};

    if (*pos == '-' || *pos == '+')
    {
        if (*pos == '-')
            sign = -1;
        pos++;
        if (pos == end)
            return false;
    }

    bool hasNumber{};
    bool hasFraction{};
    while (pos < end && isDigit(*pos))
    {
        hasNumber = true;
        number *= 10;
        number += static_cast<float>(*pos++ - '0');
    }
    if (pos == end)
    {
        number *= sign;
        return std::isfinite(number);
    }

    if (*pos == '.')
    {
        pos++;
        if (pos == end || !isDigit(*pos))
            return false;

        float division = 10;
        while (pos < end && isDigit(*pos))
        {
            hasFraction = true;
            number += static_cast<float>(*pos++ - '0') / division;
            division *= 10;
        }
    }
    if (!hasFraction && !hasNumber)
        return false;

    if (pos == end || (*pos != 'e' && *pos != 'E'))
    {
        number *= sign;
        return std::isfinite(number);
    }

    pos++;
    if (pos == end)
        return false;

    if (*pos == '-' || *pos == '+')
    {
        if (*pos == '-')
            exponentSign = -1;
        pos++;
        if (pos == end)
            return false;
    }
    if (!isDigit(*pos))
        return false;

    while (pos < end && isDigit(*pos))
    {
        exponent *= 10.0f;
        exponent += static_cast<float>(*pos++ - '0');
    }
    if (exponent)
        number *= pow(10.0f, exponentSign * exponent);

    number *= sign;
    return std::isfinite(number);
}

static bool ParseCoordinate(CharIt& pos, const CharIt& end, float& coord)
{
    // FIXME: Remove initial SkipOptWspOrDelimiter call. Keep it here to keep
    // behavior consistent to previous implementation.
    if (!SkipOptWspOrDelimiter(pos, end))
        return false;
    if (!ParseScientificNumber(pos, end, coord))
        return false;
    return true;
}

static bool ParseCoordinatePair(CharIt& pos, const CharIt& end, float& x, float& y)
{
    // FIXME: Remove initial SkipOptWspOrDelimiter call. Keep it here to keep
    // behavior consistent to previous implementation.
    if (!SkipOptWspOrDelimiter(pos, end))
        return false;
    if (!ParseScientificNumber(pos, end, x))
        return false;
    if (!SkipOptWspOrDelimiter(pos, end))
        return false;
    if (!ParseScientificNumber(pos, end, y))
        return false;
    return true;
}

static bool ParseBool(CharIt& pos, const CharIt& end, bool& boolVal)
{
    if (!SkipOptWspOrDelimiter(pos, end))
        return false;
    if (*pos == '0')
        boolVal = false;
    else if (*pos == '1')
        boolVal = true;
    else
        return false;
    pos++;
    return true;
}

static bool ParseLengthOrPercentage(
    CharIt& pos, const CharIt& end, float relDimensionLength, float& absLengthInUnits, bool useQuirks = false)
{
    if (!ParseScientificNumber(pos, end, absLengthInUnits))
        return false;

    if (pos == end)
    {
        if (useQuirks)
            return std::isfinite(absLengthInUnits);
        return false;
    }

    if (*pos != '%' && *pos != 'c' && *pos != 'm' && *pos != 'i' && *pos != 'p')
        return useQuirks;

    auto start = pos++;
    if (*start == '%')
    {
        absLengthInUnits /= 100;
        absLengthInUnits *= relDimensionLength;
        return true;
    }

    if (pos == end)
        return false;

    // https://www.w3.org/TR/css-values-3/#absolute-lengths
    auto unit = std::string(start, start + 2);
    std::transform(unit.begin(), unit.end(), unit.begin(), ::tolower);
    if (unit.compare("cm") == 0)
        absLengthInUnits *= (96.0f / 2.54f);
    else if (unit.compare("mm") == 0)
        absLengthInUnits *= (9.6f / 2.54f);
    else if (unit.compare("in") == 0)
        absLengthInUnits *= 96.0f;
    else if (unit.compare("pc") == 0)
        absLengthInUnits *= (96.0f / 6.0f);
    else if (unit.compare("pt") == 0)
        absLengthInUnits *= (96.0f / 72.0f);
    else if (unit.compare("px") == 0)
        absLengthInUnits *= 1.0f;
    else
        return false;
    pos++;

    return true;
}

static void ParseListOfNumbers(CharIt& pos, const CharIt& end, std::vector<float>& numberList, bool isAllOptional = true)
{
    numberList.clear();

    float number{};
    if (!SkipOptWsp(pos, end))
        return;
    auto temp = pos;
    if (!ParseScientificNumber(temp, end, number))
        return;
    pos = temp;
    numberList.push_back(number);
    while (pos < end)
    {
        temp = pos;
        if (!SkipOptWspOrDelimiter(temp, end, isAllOptional))
            return;

        if (!ParseScientificNumber(temp, end, number))
            return;

        numberList.push_back(number);
        pos = temp;
    }
}

bool ParseLengthOrPercentage(const std::string& lengthString, float relDimensionLength, float& absLengthInUnits, bool useQuirks /*= false*/)
{
    auto pos = lengthString.begin();
    auto end = lengthString.end();
    SkipOptWsp(pos, end);
    if (!ParseLengthOrPercentage(pos, end, relDimensionLength, absLengthInUnits, useQuirks))
        return false;

    return !SkipOptWsp(pos, end);
}

bool ParseNumber(const std::string& numberString, float& number)
{
    auto pos = numberString.begin();
    auto end = numberString.end();

    if (!SkipOptWsp(pos, end))
        return false;
    if (!ParseScientificNumber(pos, end, number))
        return false;
    return !SkipOptWsp(pos, end);
}

bool ParseAlphaValue(const std::string& numberString, float& number)
{
    auto pos = numberString.begin();
    auto end = numberString.end();

    if (!SkipOptWsp(pos, end))
        return false;
    if (!ParseScientificNumber(pos, end, number))
        return false;
    if (pos < end && *pos == '%')
    {
        number = number/100.0f;
        pos++;
    }
    return !SkipOptWsp(pos, end);
}

bool ParseListOfNumbers(const std::string& numberListString, std::vector<float>& numberList, bool isAllOptional /*= true*/)
{
    auto pos = numberListString.begin();
    auto end = numberListString.end();

    if (!SkipOptWsp(pos, end))
        return true;

    ParseListOfNumbers(pos, end, numberList, isAllOptional);

    return !SkipOptWsp(pos, end);
}

bool ParseListOfLengthOrPercentage(const std::string& lengthOrPercentageListString, float relDimensionLength,
    std::vector<float>& numberList, bool isAllOptional /*= true*/)
{
    auto pos = lengthOrPercentageListString.begin();
    auto end = lengthOrPercentageListString.end();

    numberList.clear();

    float number{};
    if (!SkipOptWsp(pos, end))
        return false;
    auto temp = pos;
    if (!ParseLengthOrPercentage(temp, end, relDimensionLength, number, isAllOptional))
        return false;
    pos = temp;
    numberList.push_back(number);
    while (pos < end)
    {
        temp = pos;
        if (!SkipOptWspOrDelimiter(temp, end, isAllOptional))
            return false;

        if (!ParseLengthOrPercentage(temp, end, relDimensionLength, number, isAllOptional))
            return false;

        numberList.push_back(number);
        pos = temp;
    }
    return !SkipOptWsp(pos, end);
}

bool ParseListOfStrings(const std::string& stringListString, std::vector<std::string>& stringList)
{
    auto pos = stringListString.begin();
    auto end = stringListString.end();

    if (!SkipOptWsp(pos, end))
        return false;
    while (pos < end)
    {
        auto start = pos;
        while (pos < end && !isWsp(*pos))
            pos++;
        stringList.push_back({start, pos});
        SkipOptWsp(pos, end);
    }
    return true;
}

bool IsMoveCmd(char cmd)
{
    return cmd == 'M' || cmd == 'm';
}

bool IsCloseCmd(char cmd)
{
    return cmd == 'Z' || cmd == 'z';
}

void ParsePathString(const std::string& pathString, Path& p)
{
    auto pos = pathString.begin();
    auto end = pathString.end();
    if (!SkipOptWsp(pos, end))
        return;

    float startX{};
    float startY{};
    float currentX{};
    float currentY{};
    float prevControlX{}; // nanf(nullptr);
    float prevControlY{}; // nanf(nullptr);
    float prevCurvePointX{};
    float prevCurvePointY{};
    char lastCommand = 'm';
    char prev = 'm';
    // First segment must be a moveTo
    if (!SkipOptWsp(pos, end) || !IsMoveCmd(*pos))
        return;

    while (pos < end)
    {
        if (!SkipOptWsp(pos, end))
            return;
        if (!isDigit(*pos) && *pos != ',' && *pos != '-' && *pos != '.')
            prev = *pos++;
        else if (IsCloseCmd(prev))
            break;
        // Do not close a path if we do not have one yet.
        if (IsCloseCmd(lastCommand) && IsCloseCmd(prev))
            continue;
        // A previous subpath was closed. Move to last current position.
        if (!IsMoveCmd(prev) && IsCloseCmd(lastCommand))
            p.MoveTo(currentX, currentX);
        switch (prev)
        {
        case 'M':
            if (!ParseCoordinatePair(pos, end, currentX, currentY))
                return;
            p.MoveTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            prev = 'L'; // https://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands

            startX = currentX;
            startY = currentY;
            break;
        case 'm':
        {
            float newX{};
            float newY{};
            if (!ParseCoordinatePair(pos, end, newX, newY))
                return;
            currentX += newX;
            currentY += newY;
            p.MoveTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            prev = 'l'; // https://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands

            startX = currentX;
            startY = currentY;
            break;
        }
        case 'Z':
        case 'z':
            p.ClosePath();

            currentX = startX;
            currentY = startY;
            break;
        case 'L':
            if (!ParseCoordinatePair(pos, end, currentX, currentY))
                return;
            p.LineTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            break;
        case 'l':
        {
            float newX{};
            float newY{};
            if (!ParseCoordinatePair(pos, end, newX, newY))
                return;
            currentX += newX;
            currentY += newY;
            p.LineTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            break;
        }
        case 'V':
            if (!ParseCoordinate(pos, end, currentY))
                return;
            p.LineTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            break;
        case 'v':
        {
            float newY{};
            if (!ParseCoordinate(pos, end, newY))
                return;
            currentY += newY;
            p.LineTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            break;
        }
        case 'H':
            if (!ParseCoordinate(pos, end, currentX))
                return;
            p.LineTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            break;
        case 'h':
        {
            float newX{};
            if (!ParseCoordinate(pos, end, newX))
                return;
            currentX += newX;
            p.LineTo(currentX, currentY);
            prevControlX = currentX;
            prevControlY = currentY;
            break;
        }
        case 'C':
        {
            float fx1{};
            float fy1{};
            if (!ParseCoordinatePair(pos, end, fx1, fy1))
                return;
            if (!ParseCoordinatePair(pos, end, prevControlX, prevControlY))
                return;
            if (!ParseCoordinatePair(pos, end, currentX, currentY))
                return;
            p.CurveTo(fx1, fy1, prevControlX, prevControlY, currentX, currentY);
            break;
        }
        case 'c':
        {
            float fx1{};
            float fy1{};
            if (!ParseCoordinatePair(pos, end, fx1, fy1))
                return;
            fx1 += currentX;
            fy1 += currentY;
            if (!ParseCoordinatePair(pos, end, prevControlX, prevControlY))
                return;
            prevControlX += currentX;
            prevControlY += currentY;
            float newX{};
            float newY{};
            if (!ParseCoordinatePair(pos, end, newX, newY))
                return;
            currentX += newX;
            currentY += newY;
            p.CurveTo(fx1, fy1, prevControlX, prevControlY, currentX, currentY);

            break;
        }
        case 'S':
        {
            prevControlX = 2 * currentX - prevControlX;
            prevControlY = 2 * currentY - prevControlY;
            float tempX{};
            float tempY{};
            if (!ParseCoordinatePair(pos, end, tempX, tempY))
                return;
            if (!ParseCoordinatePair(pos, end, currentX, currentY))
                return;
            p.CurveTo(prevControlX, prevControlY, tempX, tempY, currentX, currentY);
            prevControlX = tempX;
            prevControlY = tempY;
            break;
        }
        case 's':
        {
            float fx1 = 2 * currentX - prevControlX;
            float fx2 = 2 * currentY - prevControlY;
            if (!ParseCoordinatePair(pos, end, prevControlX, prevControlY))
                return;
            prevControlX += currentX;
            prevControlY += currentY;
            float newX{};
            float newY{};
            if (!ParseCoordinatePair(pos, end, newX, newY))
                return;
            currentX += newX;
            currentY += newY;
            p.CurveTo(fx1, fx2, prevControlX, prevControlY, currentX, currentY);

            break;
        }
        case 'Q':
        {
            // https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands

            float fx{};
            float fy{};
            if (!ParseCoordinatePair(pos, end, fx, fy))
                return;
            if (!ParseCoordinatePair(pos, end, currentX, currentY))
                return;
            p.CurveToV(fx, fy, currentX, currentY);

            prevCurvePointX = fx;
            prevCurvePointY = fy;

            break;
        }
        case 'q':
        {
            // https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands

            float fx{};
            float fy{};
            if (!ParseCoordinatePair(pos, end, fx, fy))
                return;
            fx += currentX;
            fy += currentY;
            float newX{};
            float newY{};
            if (!ParseCoordinatePair(pos, end, newX, newY))
                return;
            currentX += newX;
            currentY += newY;
            p.CurveToV(fx, fy, currentX, currentY);

            prevCurvePointX = fx;
            prevCurvePointY = fy;

            break;
        }
        case 'T':
        {
            // https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands

            float nextX{};
            float nextY{};
            if (!ParseCoordinatePair(pos, end, nextX, nextY))
                return;

            if (lastCommand != 'T' && lastCommand != 't' && lastCommand != 'Q' && lastCommand != 'q') {
                prevCurvePointX = currentX;
                prevCurvePointY = currentY;
            } else {
                // reflect previous control point
                prevCurvePointX = currentX + (currentX - prevCurvePointX);
                prevCurvePointY = currentY + (currentY - prevCurvePointY);
            }

            p.CurveToV(prevCurvePointX, prevCurvePointY, nextX, nextY);

            currentX = nextX;
            currentY = nextY;

            break;
        }
        case 't':
        {
            // https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands

            float nextX{};
            float nextY{};
            if (!ParseCoordinatePair(pos, end, nextX, nextY))
                return;
            nextX += currentX;
            nextY += currentY;

            if (lastCommand != 'T' && lastCommand != 't' && lastCommand != 'Q' && lastCommand != 'q') {
                prevCurvePointX = currentX;
                prevCurvePointY = currentY;
            } else {
                // reflect previous control point
                prevCurvePointX = currentX + (currentX - prevCurvePointX);
                prevCurvePointY = currentY + (currentY - prevCurvePointY);
            }

            p.CurveToV(prevCurvePointX, prevCurvePointY, nextX, nextY);

            currentX = nextX;
            currentY = nextY;

            break;
        }
        case 'A':
        case 'a':
        {
            float rx{};
            float ry{};
            if (!ParseCoordinatePair(pos, end, rx, ry))
                return;

            float angle{};
            if (!ParseCoordinate(pos, end, angle))
                return;

            bool flagLarge{};
            bool flagSweep{};
            if (!ParseBool(pos, end, flagLarge))
                return;
            if (!ParseBool(pos, end, flagSweep))
                return;

            float startX = currentX;
            float startY = currentY;

            if (prev == 'A')
            {
                // absolute
                if (!ParseCoordinatePair(pos, end, currentX, currentY))
                    return;
            }
            else
            {
                // relative
                float newX{};
                float newY{};
                if (!ParseCoordinatePair(pos, end, newX, newY))
                    return;
                currentX += newX;
                currentY += newY;
            }

            SVG_ASSERT(angle == 0);

            ArcToCurve(p, startX, startY, rx, ry, angle, flagLarge, flagSweep, currentX, currentY, prevControlX, prevControlY);

            SVG_PARSE_TRACE("parsePathString ArcToCurve: controlPoint: " << prevControlX << "," << prevControlY);

            break;
        }
        default:
        {
            if (isalpha(prev))
                SVG_PARSE_TRACE("parsePathString UNHANDLED: " << prev);

            prev = *pos++;
            break;
        }
        }

        lastCommand = prev;
    }
}

bool ParseTransform(const std::string& transformString, Transform& matrix)
{
    // https://www.w3.org/TR/css-transforms-1/#svg-syntax
    auto pos = transformString.begin();
    auto end = transformString.end();
    if (!SkipOptWsp(pos, end))
        return false;

    bool isFirstTransform{true};
    while (pos < end)
    {
        if (!SkipOptWsp(pos, end))
            return true;
        if (!isFirstTransform && *pos == ',')
        {
            if (!SkipOptWspOrDelimiter(pos, end, false))
                return false;
        }
        auto length = std::distance(pos, end);
        if (length >= 6 && std::string(pos, pos + 6).compare("matrix") == 0)
        {
            pos += 6;
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != '(')
                return false;
            std::vector<float> numberList;
            ParseListOfNumbers(pos, end, numberList);
            if (numberList.size() != 6 || !SkipOptWsp(pos, end))
                return false;
            if (*pos++ != ')')
                return false;
            matrix.Concat(numberList[0], numberList[1], numberList[2], numberList[3], numberList[4], numberList[5]);
        }
        else if (length >= 9 && std::string(pos, pos + 9).compare("translate") == 0)
        {
            pos += 9;
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != '(')
                return false;
            std::vector<float> numberList;
            ParseListOfNumbers(pos, end, numberList);
            auto size = numberList.size();
            if ((size != 1 && size != 2) || !SkipOptWsp(pos, end))
                return false;
            if (*pos++ != ')')
                return false;
            matrix.Translate(numberList[0], (size == 1 ? 0 : numberList[1]));
        }
        else if (length >= 5 && std::string(pos, pos + 5).compare("scale") == 0)
        {
            pos += 5;
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != '(')
                return false;
            std::vector<float> numberList;
            ParseListOfNumbers(pos, end, numberList);
            auto size = numberList.size();
            if ((size != 1 && size != 2) || !SkipOptWsp(pos, end))
                return false;
            if (*pos++ != ')')
                return false;
            matrix.Scale(numberList[0], (size == 1 ? numberList[0] : numberList[1]));
        }
        else if (length >= 6 && std::string(pos, pos + 6).compare("rotate") == 0)
        {
            pos += 6;
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != '(')
                return false;
            std::vector<float> numberList;
            ParseListOfNumbers(pos, end, numberList);
            auto size = numberList.size();
            if ((size != 1 && size != 3) || !SkipOptWsp(pos, end))
                return false;
            if (*pos++ != ')')
                return false;
            if (size == 3)
            {
                matrix.Translate(numberList[1], numberList[2]);
                matrix.Rotate(numberList[0]);
                matrix.Translate(-numberList[1], -numberList[2]);
            }
            else
                matrix.Rotate(numberList[0]);
        }
        else if (length >= 5 && std::string(pos, pos + 5).compare("skewX") == 0)
        {
            pos += 5;
            float number{};
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != '(')
                return false;
            if (!SkipOptWsp(pos, end))
                return false;
            if (!ParseScientificNumber(pos, end, number))
                return false;
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != ')')
                return false;
            number *= M_PI / 180.0f;
            matrix.Concat(1.0f, 0.0f, tan(number), 1.0f, 0.0f, 0.0f);
        }
        else if (length >= 5 && std::string(pos, pos + 5).compare("skewY") == 0)
        {
            pos += 5;
            float number{};
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != '(')
                return false;
            if (!SkipOptWsp(pos, end))
                return false;
            if (!ParseScientificNumber(pos, end, number))
                return false;
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos++ != ')')
                return false;
            number *= M_PI / 180.0f;
            matrix.Concat(1.0f, tan(number), 0.0f, 1.0f, 0.0f, 0.0f);
        }
        else
            return false;
        isFirstTransform = false;
    }
    return true;
}

static bool ParseCustomPropertyName(CharIt& pos, const CharIt& end, std::string& customPropertyName)
{
    if (pos == end || *pos++ != '-')
        return false;
    if (pos == end || *pos++ != '-')
        return false;
    if (pos == end)
        return false;
    auto startPos = pos;
    // TODO: Relax requirements and allow non-ASCII and escaped characters as well. Requires UTF8 support.
    while (isDigit(*pos) || (*pos >= 'A' && *pos <= 'Z') || (*pos >= 'a' && *pos <= 'z') || *pos == '_' || *pos == '-')
    {
        if (++pos == end)
            return false;
    }
    customPropertyName = std::string(startPos, pos);
    return !customPropertyName.empty();
}

static bool ParseColor(CharIt& pos, const CharIt& end, ColorImpl& paint, bool supportsCurrentColor, SVGDocumentImpl::Result& result)
{
    if (!SkipOptWsp(pos, end))
        return false;

    Color color{{0.0f, 0.0f, 0.0f, 1.0f}};
    if (*pos == '#')
    {
        auto start = ++pos;
        while (pos < end && isHex(*pos))
            pos++;
        std::string hexString(start, pos);
        auto num = stoi(hexString, nullptr, 16);
        if (hexString.size() == 3)
        {
            // Hex color with 3 characters: #FF0 -> #FFFF00
            color[0] = (num / 0x100) / 15.0f;
            color[1] = ((num / 0x10) % 0x10) / 15.0f;
            color[2] = (num % 0x10) / 15.0f;
        }
        else if (hexString.size() == 6)
        {
            // Hex color with 6 characters: #FFFF00
            color[0] = (num / 0x10000) / 255.0f;
            color[1] = ((num / 0x100) % 0x100) / 255.0f;
            color[2] = (num % 0x100) / 255.0f;
        }
        else
        {
            result = SVGDocumentImpl::Result::kInvalid;
            return false;
        }
        paint = color;
        result = SVGDocumentImpl::Result::kSuccess;
        return true;
    }

    auto length = std::distance(pos, end);
    if (length >= 4)
    {
        std::string char4string(pos, pos + 4);
        std::transform(char4string.begin(), char4string.end(), char4string.begin(), ::tolower);
        if (char4string.compare("rgb(") == 0)
        {
            result = SVGDocumentImpl::Result::kInvalid;
            pos += 4;
            float r{};
            float g{};
            float b{};
            bool hasRPercentage = false;
            bool hasGPercentage = false;
            bool hasBPercentage = false;
            if (!SkipOptWsp(pos, end))
                return false;
            if (!ParseFloatingPoint(pos, end, r))
                return false;
            if (!SkipOptWspOptPercentageDelimiterOptWsp(pos, end, ',', hasRPercentage))
                return false;
            if (!ParseFloatingPoint(pos, end, g))
                return false;
            if (!SkipOptWspOptPercentageDelimiterOptWsp(pos, end, ',', hasGPercentage))
                return false;
            if (!ParseFloatingPoint(pos, end, b))
                return false;
            if (!SkipOptWspOptPercentOptWsp(pos, end, hasBPercentage))
                return false;
            if (*pos++ != ')')
                return false;
            if (hasRPercentage != hasGPercentage || hasRPercentage != hasBPercentage)
                return false;
            float base = hasRPercentage ? 100.0f: 255.0f;
            if (!hasRPercentage)
            {
                r = std::floor(r);
                b = std::floor(b);
                g = std::floor(g);
            }
            color[0] = std::min(base, r) / base;
            color[1] = std::min(base, g) / base;
            color[2] = std::min(base, b) / base;
            paint = color;
            result = SVGDocumentImpl::Result::kSuccess;
            return true;
        }
        if (char4string.compare("var(") == 0)
        {
            result = SVGDocumentImpl::Result::kInvalid;
            pos += 4;
            if (!SkipOptWsp(pos, end))
                return false;
            std::string customPropertyName;
            if (!ParseCustomPropertyName(pos, end, customPropertyName))
                return false;
            ColorImpl fallbackPaint = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
            if (!SkipOptWsp(pos, end))
                return false;
            if (*pos != ')')
            {
                if (!SkipOptWspDelimiterOptWsp(pos, end))
                    return false;
                if (!ParseColor(pos, end, fallbackPaint, true, result) || result != SVGDocumentImpl::Result::kSuccess)
                    return false;
                if (!SkipOptWsp(pos, end))
                    return false;
                if (*pos != ')')
                    return false;
            }
            pos++;
            if (!SVGNative::holds_alternative<Color>(fallbackPaint))
            {
                // Fallback color was a variable. This is allowed according to
                // CSS syntax but requires recursive C++ variables. Ignoring it
                // and setting fallback color to black is a simpler approach for now.
                fallbackPaint = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
            }
            paint = Variable{customPropertyName, SVGNative::get<Color>(fallbackPaint)};
            result = SVGDocumentImpl::Result::kSuccess;
            return true;
        }
    }

    // Parse CSS named Colors.
    for (const auto& namedColor : gCSSNamedColors)
    {
        auto namedColorSize = namedColor.length;
        if (std::distance(pos, end) < static_cast<const long>(namedColorSize))
            continue;
        std::string nameString(pos, pos + namedColorSize);
        std::transform(nameString.begin(), nameString.end(), nameString.begin(), ::tolower);
        if (std::string(nameString).compare(namedColor.colorName) == 0)
        {
            color = namedColor.color;
            paint = color;
            result = SVGDocumentImpl::Result::kSuccess;
            pos += namedColorSize;
            return true;
        }
    }

    if (length >= 12 && supportsCurrentColor)
    {
        std::string currentColorString(pos, pos + 12);
        std::transform(currentColorString.begin(), currentColorString.end(), currentColorString.begin(), ::tolower);
        if (currentColorString.compare("currentcolor") == 0)
        {
            paint = ColorKeys::kCurrentColor;
            result = SVGDocumentImpl::Result::kSuccess;
            pos += 12;
            return true;
        }
    }

    result = SVGDocumentImpl::Result::kInvalid;
    return false;
}

SVGDocumentImpl::Result ParseColor(const std::string& colorString, ColorImpl& paint, bool supportsCurrentColor /*= true*/)
{
    auto pos = colorString.begin();
    auto end = colorString.end();
    SVGDocumentImpl::Result result{SVGDocumentImpl::Result::kInvalid};
    if (ParseColor(pos, end, paint, supportsCurrentColor, result))
        return result;
    return SVGDocumentImpl::Result::kInvalid;
}

SVGDocumentImpl::Result ParsePaint(const std::string& colorString, const std::map<std::string, GradientImpl>& gradientMap,
    const std::array<float, 4>& viewBox, PaintImpl& paint)
{
    SVGDocumentImpl::Result result{SVGDocumentImpl::Result::kSuccess};
    if (!colorString.size())
        return SVGDocumentImpl::Result::kInvalid;

    auto pos = colorString.begin();
    auto end = colorString.end();
    if (!SkipOptWsp(pos, end))
        return SVGDocumentImpl::Result::kInvalid;

    SVGDocumentImpl::Result urlResult{SVGDocumentImpl::Result::kInvalid};
    if (std::distance(pos, end) >= 5)
    {
        std::string urlString(pos, pos + 5);
        if (urlString.find("url(#") == 0)
        {
            pos += urlString.size();
            auto startPos = pos;
            bool success{};
            while (pos != end)
            {
                if (*pos++ == ')')
                {
                    success = true;
                    break;
                }
            }
            if (!success || (pos != end && !isWsp(*pos)))
                return SVGDocumentImpl::Result::kInvalid;
            std::string idString(startPos, pos - 1);
            auto it = gradientMap.find(idString);
            if (it != gradientMap.end())
            {
                // * No color stops means the same as if 'none' was specified.
                // * 1 color stop means solid color fill.
                // https://www.w3.org/TR/SVG11/pservers.html#GradientStops (see notes at the end)
                // Can not be determined earlier.
                auto gradient = it->second;
                if (gradient.internalColorStops.empty())
                    return SVGDocumentImpl::Result::kDisabled;
                else if (gradient.internalColorStops.size() == 1)
                    paint = SVGNative::get<Color>(std::get<1>(gradient.internalColorStops.front()));
                else
                {
                    // Percentage values that do neither correlate to horizontal nor vertical dimensions
                    // need to be relative to the hypotenuse of both. Example: r="50%"
                    float sqr = sqrtf(viewBox[2] * viewBox[2] + viewBox[3] * viewBox[3]);
                    if (gradient.type == GradientType::kLinearGradient)
                    {
                        // https://www.w3.org/TR/SVG11/pservers.html#LinearGradients
                        gradient.x1 = std::isfinite(gradient.x1) ? gradient.x1 : 0;
                        gradient.y1 = std::isfinite(gradient.y1) ? gradient.y1 : 0;
                        gradient.x2 = std::isfinite(gradient.x2) ? gradient.x2 : viewBox[2];
                        gradient.y2 = std::isfinite(gradient.y2) ? gradient.y2 : 0;
                    }
                    else
                    {
                        // https://www.w3.org/TR/SVG11/pservers.html#RadialGradients
                        gradient.cx = std::isfinite(gradient.cx) ? gradient.cx : 0.5f * viewBox[2];
                        gradient.cy = std::isfinite(gradient.cy) ? gradient.cy : 0.5f * viewBox[3];
                        gradient.fx = std::isfinite(gradient.fx) ? gradient.fx : gradient.cx;
                        gradient.fy = std::isfinite(gradient.fy) ? gradient.fy : gradient.cy;
                        gradient.r = std::isfinite(gradient.r) ? gradient.r : 0.5f * sqr;
                    }
                    paint = gradient;
                }
            }
        }
    }
    if (!SkipOptWsp(pos, end))
        return result;

    ColorImpl altPaint;
    if (std::distance(pos, end) >= 4 && std::string(pos, pos + 4).compare("none") == 0)
    {
        pos += 4;
        if (urlResult == SVGDocumentImpl::Result::kInvalid)
            result = SVGDocumentImpl::Result::kDisabled;
    }
    else
    {
        if (!ParseColor(pos, end, altPaint, true, result))
            return result;
    }

    if (!SkipOptWsp(pos, end))
    {
        if (urlResult == SVGDocumentImpl::Result::kInvalid && result != SVGDocumentImpl::Result::kInvalid)
        {
			//Convert from ColorImpl to PaintImpl. Although PaintImpl supports a superset of types, std doesn't know how to deal with the conversion.
			if (SVGNative::holds_alternative<Color>(altPaint))
			{
				paint = SVGNative::get<Color>(altPaint);
			}
			else if (SVGNative::holds_alternative<Variable>(altPaint))
			{
				paint = SVGNative::get<Variable>(altPaint);
			}
			else if (SVGNative::holds_alternative<ColorKeys>(altPaint))
			{
				paint = SVGNative::get<ColorKeys>(altPaint);
			}
        }
        return result;
    }

    return SVGDocumentImpl::Result::kInvalid;
}

} // namespace SVGStringParser

} // namespace SVGNative
</file>

<file path=".circleci/config.yml">
version: 2.1

orbs:
  windows: circleci/windows@2.3.0

jobs:
  build_test:
    docker:
      - image: cimg/base:2023.12
    steps:
      - run:
          name: Installing Build System
          command: 'sudo apt-get update && sudo apt-get install git python2.7 libxml2-dev'
      - run:
          name: Installing Build System
          command: 'sudo apt-get update && sudo apt-get install wget && sudo apt-get install zlib1g-dev && sudo apt-get install libcurl4-openssl-dev cmake'
      - checkout
      - run: git submodule sync
      - run: git submodule update --init
      - run:
          name: Creating Build Files
          command: 'cd svgnative && cmake -Bbuild/linux -H.'
      - run:
          name: Creating Binary Files
          command: 'cd svgnative && cmake --build build/linux'
      - run:
          name: Run Tests
          command: 'cd svgnative && /usr/bin/python2.7 script/runTest.py --test=test'
      - run:
          name: Creating Build Files With libxml2
          command: 'cd svgnative && cmake -Bbuild/linux-libxml2 -H. -DPLATFORM_XML=ON'
      - run:
          name: Creating Binary Files With libxml2
          command: 'cd svgnative && cmake --build build/linux-libxml2'
      - run:
          name: Run Tests With libxml2
          command: 'cd svgnative && /usr/bin/python2.7 script/runTest.py --test=test --program=build/linux-libxml2/example/testText/testSVGNative'
  build_with_clang:
    docker:
      - image: cimg/base:2023.12
    steps:
      - run:
          name: Installing Build System
          command: 'sudo apt-get update && sudo apt-get install git clang++-11 python2.7'
      - run:
          name: Installing Build System
          command: 'sudo apt-get update && sudo apt-get install wget && sudo apt-get install zlib1g-dev && sudo apt-get install libcurl4-openssl-dev cmake'
      - checkout
      - run: git submodule sync
      - run: git submodule update --init
      - run:
          name: Creating Build Files
          command: 'cd svgnative && cmake -Bbuild/linux -H. -DCMAKE_CXX_COMPILER=clang++-11 -DLIB_ONLY=ON'
      - run:
          name: Creating Binary Files
          command: 'cd svgnative && cmake --build build/linux'
  build_with_style_support:
    docker:
      - image: cimg/base:2023.12
    steps:
      - run:
          name: Installing Build System
          command: 'sudo apt-get update && sudo apt-get install git libboost-system-dev python2.7'
      - run:
          name: Installing Build System
          command: 'sudo apt-get update && sudo apt-get install wget && sudo apt-get install zlib1g-dev && sudo apt-get install libcurl4-openssl-dev cmake'
      - checkout
      - run: git submodule sync
      - run: git submodule update --init
      - run:
          name: Creating Build Files
          command: 'cd svgnative && cmake -Bbuild/linux -H. -DSTYLE=ON'
      - run:
          name: Creating Binary Files
          command: 'cd svgnative && cmake --build build/linux'
  build_with_cocoa:
    macos:
      xcode: "14.2.0"
    steps:
      - checkout
      - run: git submodule sync
      - run: git submodule update --init
      - run:
          name: Installing dependencies
          command: HOMEBREW_NO_AUTO_UPDATE=1 HOMEBREW_NO_INSTALL_CLEANUP=1 brew install cmake
      - run:
          name: Creating Build Files
          command: 'cd svgnative && cmake -Bbuild/mac -H. -DCG=ON'
      - run:
          name: Creating Binary Files
          command: 'cd svgnative && cmake --build build/mac'
  build_with_gdi_d2d:
    executor: windows/default
    steps:
      - checkout
      - run: git submodule sync
      - run: git submodule update --init
      - run:
          name: Installing CMake
          command: |
            $global:ProgressPreference = 'SilentlyContinue'
            $cmakeVersion = "3.16.2"
            $url = "https://github.com/Kitware/CMake/releases/download/v" + $cmakeVersion + "/cmake-" + $cmakeVersion + "-win64-x64.zip"
            $outputDir = (Get-Item -Path ".\").FullName
            $outputZip = $outputDir + "\cmake.zip"
            (New-Object System.Net.WebClient).DownloadFile($url, $outputZip)
            Expand-Archive -LiteralPath $outputZip -DestinationPath $outputDir -Force
      - run:
          name: Creating Build Files - GDI+
          command: |
            $cmakeVersion = "3.16.2"
            $env:Path += ";" + (Get-Item -Path ".\").FullName + "\cmake-" + $cmakeVersion + "-win64-x64\bin"
            cd .\svgnative
            cmake -Bbuild/win . -G "Visual Studio 16 2019" -DGDIPLUS=ON
      - run:
          name: Creating Binary Files - GDI+
          command: |
            $cmakeVersion = "3.16.2"
            $env:Path += ";" + (Get-Item -Path ".\").FullName + "\cmake-" + $cmakeVersion + "-win64-x64\bin"
            cd .\svgnative
            cmake --build build/win
      - run:
          name: Creating Build Files - Direct2D
          command: |
            $cmakeVersion = "3.16.2"
            $env:Path += ";" + (Get-Item -Path ".\").FullName + "\cmake-" + $cmakeVersion + "-win64-x64\bin"
            cd .\svgnative
            cmake -Bbuild/win-d2d . -G "Visual Studio 16 2019" -DD2D=ON
      - run:
          name: Creating Binary Files - Direct2D
          command: |
            $cmakeVersion = "3.16.2"
            $env:Path += ";" + (Get-Item -Path ".\").FullName + "\cmake-" + $cmakeVersion + "-win64-x64\bin"
            cd .\svgnative
            cmake --build build/win-d2d
      - run:
          name: Creating Build Files - Shared Lib
          command: |
            $cmakeVersion = "3.16.2"
            $env:Path += ";" + (Get-Item -Path ".\").FullName + "\cmake-" + $cmakeVersion + "-win64-x64\bin"
            cd .\svgnative
            cmake -Bbuild/win-shared . -G "Visual Studio 16 2019" -DGDIPLUS=ON -DSHARED=ON
      - run:
          name: Creating Binary Files - Shared Lib
          command: |
            $cmakeVersion = "3.16.2"
            $env:Path += ";" + (Get-Item -Path ".\").FullName + "\cmake-" + $cmakeVersion + "-win64-x64\bin"
            cd .\svgnative
            cmake --build build/win-shared
workflows:
  version: 2
  build_and_test:
    jobs:
      - build_test
      - build_with_style_support
      - build_with_clang
      - build_with_cocoa
      - build_with_gdi_d2d
</file>

<file path="svgnative/src/SVGDocumentImpl.h">
/*
Copyright 2014 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#pragma once

#include "svgnative/Rect.h"
#include "svgnative/SVGRenderer.h"
#ifdef STYLE_SUPPORT
#include "StyleSheet/Document.h"
#include "StyleSheet/Parser.h"
#endif

#include <array>
#include <map>
#include <set>
#include <stack>
#include <string>
#include <tuple>
#include <vector>

namespace SVGNative
{
namespace xml
{
    class XMLNode;
}

struct GradientImpl;

// At this point we just support 'currentColor'
enum class ColorKeys
{
    kCurrentColor
};

using Variable = std::pair<std::string, Color>;
using ColorImpl = SVGNative::variant<Color, Variable, ColorKeys>;
using PaintImpl = SVGNative::variant<Color, GradientImpl, Variable, ColorKeys>;
using ColorStopImpl = std::tuple<float, ColorImpl, float>;
#ifdef STYLE_SUPPORT
using PropertySet = StyleSheet::CssPropertySet;
#else
using PropertySet = std::map<std::string, std::string>;
#endif

struct GradientImpl : public Gradient
{
    std::vector<ColorStopImpl> internalColorStops;
};

struct FillStyleImpl : public FillStyle
{
    PaintImpl internalPaint = Color{{0.0f, 0.0f, 0.0f, 1.0f}};

    // Other inherited properties. We handle them here for simplicity.
    bool visibility{true};
    ColorImpl color = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
    WindingRule clipRule = WindingRule::kNonZero;
};

struct StrokeStyleImpl : public StrokeStyle
{
    PaintImpl internalPaint = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
};

struct GraphicStyleImpl : public GraphicStyle
{
    // Other non-inherited properties
    bool display{true};
    float stopOpacity{1.0f};
    ColorImpl stopColor = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
};

class SVGDocumentImpl
{
public:
    enum class ElementType
    {
        kImage,
        kGraphic,
        kGroup,
        kReference
    };

    struct Element
    {
        Element(GraphicStyleImpl& aGraphicStyle, std::set<std::string>& aClasses)
            : graphicStyle{aGraphicStyle}
            , classNames{aClasses}
        {
        }

        virtual ~Element() = default;

        GraphicStyleImpl graphicStyle;
        std::set<std::string> classNames;
        virtual ElementType Type() const = 0;
    };

    struct Image : public Element
    {
        Image(GraphicStyleImpl& aGraphicStyle, std::set<std::string>& aClasses, std::shared_ptr<ImageData> aImageData,
            const Rect& aClipArea, const Rect& aFillArea)
            : Element(aGraphicStyle, aClasses)
            , imageData{std::move(aImageData)}
            , clipArea{aClipArea}
            , fillArea{aFillArea}
        {
        }

        std::shared_ptr<ImageData> imageData;
        Rect clipArea;
        Rect fillArea;
        ElementType Type() const override { return ElementType::kImage; }
    };

    struct Group : public Element
    {
        Group(GraphicStyleImpl& aGraphicStyle, std::set<std::string>& aClasses)
            : Element(aGraphicStyle, aClasses)
        {
        }

        std::vector<std::shared_ptr<Element>> children;
        ElementType Type() const override { return ElementType::kGroup; }
    };

    struct Graphic : public Element
    {
        Graphic(GraphicStyleImpl& aGraphicStyle, std::set<std::string>& aClasses, FillStyleImpl& aFillStyle, StrokeStyleImpl& aStrokeStyle,
            std::shared_ptr<Path> aPath)
            : Element(aGraphicStyle, aClasses)
            , fillStyle{aFillStyle}
            , strokeStyle{aStrokeStyle}
            , path{std::move(aPath)}
        {
        }

        FillStyleImpl fillStyle;
        StrokeStyleImpl strokeStyle;
        std::shared_ptr<Path> path;

        ElementType Type() const override { return ElementType::kGraphic; }
    };

    struct Reference : public Element
    {
        Reference(GraphicStyleImpl& aGraphicStyle, std::set<std::string>& aClasses, FillStyleImpl& aFillStyle, StrokeStyleImpl& aStrokeStyle,
            std::string aHref)
            : Element(aGraphicStyle, aClasses)
            , fillStyle{aFillStyle}
            , strokeStyle{aStrokeStyle}
            , href{std::move(aHref)}
        {
        }

        FillStyleImpl fillStyle;
        StrokeStyleImpl strokeStyle;
        std::string href;

        ElementType Type() const override { return ElementType::kReference; }
    };

    SVGDocumentImpl(std::shared_ptr<SVGRenderer> renderer);
    ~SVGDocumentImpl() {}

    void TraverseSVGTree(xml::XMLNode* rootNode);

    enum class Result
    {
        kSuccess,
        kInvalid,
        kDisabled
    };

    enum class LengthType
    {
        kHorizontal,
        kVertical,
        kDiagonal
    };

#ifdef STYLE_SUPPORT
    void AddCustomCSS(const StyleSheet::CssDocument* cssDocument);
    void ClearCustomCSS();
#endif
    void Render(const ColorMap& colorMap, float width, float height);
    void Render(const char* id, const ColorMap& colorMap, float width, float height);

    bool GetBoundingBox(Rect& bounds);
    bool GetBoundingBox(const char* id, Rect& bounds);
#ifdef DEBUG_API
    bool GetSubBoundingBoxes(std::vector<Rect>& bounds);
    bool GetSubBoundingBoxes(const char* id, std::vector<Rect>& bounds);
#endif

    std::array<float, 4> mViewBox;
    std::shared_ptr<SVGRenderer> mRenderer;

private:
    float ParseLengthFromAttr(const xml::XMLNode* child, const char* attrName, LengthType lengthType = LengthType::kHorizontal, float fallback = 0);
    float RelativeLength(LengthType lengthType) const;

    float ParseColorStop(const xml::XMLNode* node, std::vector<SVGNative::ColorStopImpl>& colorStops, float lastOffset);
    void ParseColorStops(xml::XMLNode* node, SVGNative::GradientImpl& gradient);
    void ParseGradient(xml::XMLNode* gradient);

    void ParseChildren(xml::XMLNode* node);
    void ParseChild(xml::XMLNode* node);

    std::unique_ptr<Path> ParseShape(xml::XMLNode* node);

    GraphicStyleImpl ParseGraphic(const xml::XMLNode* node, FillStyleImpl& fillStyle, StrokeStyleImpl& strokeStyle, std::set<std::string>& classNames);
    void ParseFillProperties(FillStyleImpl& fillStyle, const PropertySet& propertySet);
    void ParseStrokeProperties(StrokeStyleImpl& strokeStyle, const PropertySet& propertySet);
    void ParseGraphicsProperties(GraphicStyleImpl& graphicsStyle, const PropertySet& propertySet);

    PropertySet ParsePresentationAttributes(const xml::XMLNode* node);

    void RenderElement(const Element& element, const ColorMap& colorMap, float width, float height);
    void ExtractBounds(const Element& element);

    void TraverseTree(const ColorMap& colorMap, const Element&);

    void ApplyCSSStyle(
        const std::set<std::string>& classNames, GraphicStyleImpl& graphicStyle, FillStyleImpl& fillStyle, StrokeStyleImpl& strokeStyle);
    void ParseStyleAttr(const xml::XMLNode* node, std::vector<PropertySet>& propertySets, std::set<std::string>& classNames);
    void ParseStyle(const xml::XMLNode* child);

    void AddChildToCurrentGroup(std::shared_ptr<Element> element, std::string idString);

private:
    const xml::XMLNode* mRootNode{};

    // All stroke and fill CSS properties are so called
    // inherited CSS properties. Ancestors can define the
    // stroke properties for descendants. Descendants override
    // specifies from ancestors.
    // We need to keep the stack of settings in based on DOM
    // hierarchy.
    std::stack<StrokeStyleImpl> mStrokeStyleStack;
    std::stack<FillStyleImpl> mFillStyleStack;
#ifdef DEBUG_API
    std::vector<Rect> mBounds;
#else
    Rect mBound{0, 0, 0, 0};
#endif

#ifdef STYLE_SUPPORT
    const StyleSheet::CssDocument* mOverrideStyle{};
    StyleSheet::CssDocument mCSSInfo;
    StyleSheet::CssDocument mCustomCSSInfo;
#endif

    // Temporary resources. Will get cleaned-up after parsing.
    std::map<std::string, GradientImpl> mGradients;
    std::map<std::string, std::shared_ptr<ClippingPath>> mClippingPaths;
    std::stack<std::shared_ptr<Group>> mGroupStack;

    // Render tree created during parsing.
    std::shared_ptr<Group> mGroup;
    std::map<std::string, std::shared_ptr<Element>> mIdToElementMap;

    // Visited nodes to detect cycles.
    std::set<const Element*> mVisitedElements;

#if DEBUG
    std::string mTitle;
#endif
};

} // namespace SVGNative
</file>

<file path="README.md">
# SVG Native Viewer

[![CircleCI](https://circleci.com/gh/adobe/svg-native-viewer.svg?style=svg)](https://circleci.com/gh/adobe/svg-native-viewer)

SVG Native viewer is a library that parses and renders SVG Native
documents.

## SVG Native
SVG Native is an upcoming specification of the SVG WG based on [SVG
OpenType](https://docs.microsoft.com/en-us/typography/opentype/spec/svg)
. SVG Native will be a strict subset of SVG 1.1 and SVG 2.0.

### Supported features in SVG Native (in comparison to SVG1.1/SVG2)
* No stylesheet support (CSS/XSL) with the exception of the basic
inheritance model and the following presentation attributes:
    * `clip-path`
    * `clip-rule`
    * `color`
    * `display`
    * `fill`
    * `fill-opacity`
    * `fill-rule`
    * `opacity`
    * `stroke`
    * `stroke-dasharray`
    * `stroke-dashoffset`
    * `stroke-linecap`
    * `stroke-linejoin`
    * `stroke-miterlimit`
    * `stroke-opacity`
    * `stroke-width`
    * `stop-color`
    * `stop-opacity`
    * `visibility`
* CSS properties do not support any default property values like
  `inherit`, `initial`, `unset`, or `revert`.
* No support for scripting, interactions, events, animations, filters,
  masks, patterns, texts.
* No support for inner `<svg>` or `<symbol>` elements.
* No support for XML namespaces with the exception of the SVG namespace
  and the Xlink namespace.
* No support of `objectBoundingBox` on `gradientUnits` or
  `clipPathUnits`.
* The `var()` CSS value function is limited to the CSS properties
  `fill`, `stroke`, `stop-color` and `color`. Only color values are
  allowed. `currentColor` is supported.

A valid SVG Native document is always a valid SVG1.1/2.0 document.

## SVG Native Viewer Library

SVG Native Viewer is a C++11 based project and can either be included
in the source code of a client directly or linked statically or
dynamically.

For rendering, SVG Native Viewer requires a rendering port. Already
existing ports include:
* **StringSVGRenderer** for testing purposes,
* **CGSVGRenderer** a rendering port using CoreGraphics (Quartz 2D).
* **SkiaSVGRenderer** a rendering port using Skia. (**Skia requires a C++14 compatible compiler!**)
* **CairoSVGRenderer** a rendering port using Cairo Graphics.
* **GDIPlusSVGRenderer** a rendering port using GDI+.
* **D2DSVGRenderer** a rendering port using Direct2D.

New ports need to inherit from **SVGRenderer** and implement the
virtual functions.

Here an example how to use SVG Native Viewer with Skia
**SkiaSVGRenderer**:

```cpp
// Create the renderer object
auto renderer = std::make_shared<SVGNative::SkiaSVGRenderer>();

// Create SVGDocument object and parse the passed SVG string.
auto doc = std::unique_ptr<SVGNative::SVGDocument>
(SVGNative::SVGDocument::CreateSVGDocument(svgInput.c_str(), renderer));

// Setup SkSurface for drawing
auto skRasterSurface = SkSurface::MakeRasterN32Premul(doc->Width(),
                                                      doc->Height());
auto skRasterCanvas = skRasterSurface->getCanvas();

// Pass SkCanvas to renderer object
renderer->SetSkCanvas(skRasterCanvas);

// Pass drawing commands for SVG document to renderer.
doc->Render();

// Pass drawing commands for SVG document to renderer the element (and
// its descendants)
// with the XML ID "ref1".
std::string id1{"ref1"}
doc->Render(id1);

// The Render() function may get called multiple times. This can be
// used to render a combination of glyphs specified in the same SVG
// document.
std::string id2{"ref2"}
doc->Render(id2);
```

Refer to the examples in the `example/` directory for other port
examples.

## Requirements
### Submodules

This repository uses submodules. To initiate and keep submodules
up-to-date run the following command:

```
git submodule update --init
```

Submodules are located in the `third_party/` directory. Used submodules:
* [stylesheet](https://github.com/adobe/stylesheet/tree/modifications)
  **(optional)** Needed if compiled with limited CSS style support
(deprecated).
* [cpp-base64](https://github.com/ReneNyffenegger/cpp-base64)
  **(optional)** Needed by some ports for decoding base64 encoded raster
image support.
* [boost_variant_property_tree](https://github.com/dirkschulze/boost_variant_property_tree)
  **(optional)** Minimal version of Boost stripped down to the
  requirements of `variant` and `property_tree`. Used if Boost was not
  installed on the system.


### Windows

Install:
* [CMake](https://cmake.org) Download and run the installer
* [Boost](https://www.boost.org) Download the ZIP-package and extract
  the package into `C:>\Program Files\boost_x.y.z\` (See below how to
  specify a different Boost installation directory by a CMake option.)
* [MS Visual Studio 2017 or
  up](https://visualstudio.microsoft.com/vs/whatsnew/) Download and
  install with the installer. Make sure Visual C++ gets installed. (You
  maybe be able to use the "Community" version for free for
  non-commercial/enterprise use. See the website from MS for license
  details.)

### OSX
With Homebrew:
```
brew install cmake
brew install llvm
brew install boost
```

### LINUX

* Apt
```
sudo apt-get install build-essential libboost-system-dev cmake
```

## Building

### Create project files

For Windows 64 bit:
```
cmake -Bbuild/win64 -H. -G "Visual Studio 15 2017 Win64"
```

For Windows 32 bit:
```
cmake -Bbuild/win32 -H. -G "Visual Studio 15 2017"
```
_Omit `-H` when running in PowerShell._

For macOS
```
cmake -Bbuild/mac -H. -G "Xcode"
```

For Linux
```
cmake -Bbuild/linux -H.
```
On Linux you may choose to use GCC or Clang/LLVM. Add the following to
the command above to choose between one and the other:
* `-DCMAKE_CXX_COMPILER=g++` for GCC
* `-DCMAKE_CXX_COMPILER=clang` for Clang/LLVM

On Windows you may choose to use Clang/LLVM as compiler. For help,
follow the instructions of the linked MS Visual Studio [LLVM
Extension](https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain). 
Add ` -T "LLVM"` to the project generation command above.

To specify a different Boost installation directory on Windows use the
following command:
* `-DBOOST_ROOT=X:\path\to\boost`

The following arguments can be passed with the `-D` flag and the
options `ON` or `OFF`:
* `LIB_ONLY` Only compile the library without examples. Default `OFF`.
* `SHARED` If `ON`, builds a dynamic library. Static otherwise. Default
  `OFF`.
* `PLATFORM_XML` If `ON`, uses libxml2 or Epat if provided by the
  system. Otherwise RapidXML via boost. Default `OFF`.
* `TEXT` adds the _Text_ port to the library. Default `ON`.
* `CG` adds the _CoreGraphics/Quartz2D_ port to the library. Default
  `OFF`.
* `SKIA` adds the _Skia_ port to the library. Default `OFF`.
* `GDIPLUS` adds the _GDI+_ port to the library. Default `OFF`.
* `D2D` adds the _Direct2D_ port to the library. Default `OFF`.
* `CAIRO` adds the _Cairo Graphics_ port to the library. Default `OFF`.
* `TESTING` enables automated testing using Google Tests. Default `ON`.

To enable the deprecated CSS styling support:
* `STYLE` adds limited, deprecated support for `<style>` element and
  `style` attribute. Default `OFF`. _(This option will get removed
  eventually.)_

The following example creates project files for the library with the
Text, CoreGraphics/Quartz2D and Skia port and the example applications.
**Example:**
```
cmake -Bbuild/mac -H. -G "Xcode" -DCG=ON -DSKIA=ON
```

**Note:** For testing, build with the `TEXT` option set to `ON` and
 `LIB_ONLY` option set to `OFF`. (The default for both.)

### Build

Replace `win64` with your platform (`mac` for Xcode on macOS)
```
cmake --build build/win64 --config Release
```

## Boost requirements

Only the header version of Boost is required. The following Boost
features are used:
* Boost RapidXML _(Can be replaced by libxml2.)_
* `boost::variant` to handle different SVG paint types of `fill` and
 `stroke` as well as different color value types.
* Boost string functions like `boost::tokenizer`, `boost::trim`. _(Only
used by deprecated CSS `<style>` element parsing.)_

## Tests
SVG Native Viewer has two testing mechanisms. A python script that performs the renderings on the *Text* port and compares the renderings with the existing ones and automated software testing using Google Tests framework. 

### *Text* port testing
To use the python script:
1. Make sure your system has Python installed.
2. By default, CMake creates the project files for
**SVGNativeViewerLib** and **testSVGNative**. Follow the steps above to
build the test app.
3. Run
  ```
  python script/runTest.py --tests=test/
  ```
  Here the argument list of **runTest.py**:
  * `--test` the folder with the test files.
  * `--program` the path to **testSVGNative**. If not provided uses the
    default, relative build path.
  * `--debug` Debug build or Release build of **testSVGNative**. Only
    relevant if `--program` was not set and defaults to `--debug`.
### Google Test based testing
In order to build and run the tests, pass the argument `-DTESTING=ON` when running Cmake. Cmake will automatically download and build Google Tests and compile the tests. In order to run the tests you can run `make test` or just use `ctest` in the build folder.

Ultimately, we aim to improve software unit testing as well as add rendering tests to ensure that SVG Native Viewer's renderings are accurate.

## Known limitations in SVG Native Viewer
* `preserveAspectRatio` is not supported on the `<svg>` element yet.
* Furthermore, there might be limitations on certain platforms. (E.g.
  missing gradient spread-method support on CoreGraphics.)

## Contributing

Contributions are welcomed! Read the [Contributing
Guide](./.github/CONTRIBUTING.md) for more information.

## Licensing

This project is licensed under the Apache V2 License. See
[LICENSE](LICENSE) for more information.
</file>

<file path="svgnative/CMakeLists.txt">
#[[
cd build
cmake -Bbuild/win64 -H. -G "Visual Studio 15 2017 Win64"
cmake -Bbuild/win32 -H. -G "Visual Studio 15 2017"
cmake -Bbuild/mac -H. -G "Xcode"
cmake -Bbuild/linux -H.

cmake --build build/win64 --config Release
]]

# Version of SVGNativeViewerLib based on semver (major-, minor-, patch-release)
set(VERSION "0.9.0")

cmake_minimum_required(VERSION 3.11.0)
if (CMAKE_VERSION VERSION_GREATER "3.15")
    cmake_policy(SET CMP0091 NEW)
endif()

set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
project(SVGNativeViewer)
enable_language(CXX)
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)

if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
    if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.8.1)
        message(FATAL_ERROR "Minimum supported GCC version: 4.8.1. Currently used version: ${CMAKE_CXX_COMPILER_VERSION}")
    endif()
endif()
message(STATUS "CMAKE_VERSION: ${CMAKE_VERSION}")
message(STATUS "CMAKE_GENERATOR: ${CMAKE_GENERATOR}")
message(STATUS "CMAKE_SYSTEM_NAME: ${CMAKE_SYSTEM_NAME}")
message(STATUS "CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
message(STATUS "CMAKE_CXX_COMPILER: ${CMAKE_CXX_COMPILER}")
message(STATUS "CMAKE_CXX_COMPILER_VERSION: ${CMAKE_CXX_COMPILER_VERSION}")

################################
# CMake Arguments
################################
include(CMakeDependentOption)

option(LIB_ONLY "Create a project for library only" OFF)
option(SHARED "Make library dynamic")
option(PLATFORM_XML "Uses the XML parser provided by the platform" OFF)

option(TEXT "Enable Text port for testing" ON)
option(CG "Enable CoreGraphics/Quartz2D port")
option(SKIA "Enable Skia port")
option(GDIPLUS "Enable GDI+ port")
option(D2D "Enable Direct2D port")
option(STYLE "Enable deprecated CSS Styling support")
option(CAIRO "Enable Cairo port")
option(TESTING "Enable automated testing using Google Tests" ON)

CMAKE_DEPENDENT_OPTION(USE_SHARED "Dynamic library" TRUE "SHARED" FALSE)
CMAKE_DEPENDENT_OPTION(USE_PLATFORM_XML "Platform XML parser" TRUE "PLATFORM_XML" FALSE)

CMAKE_DEPENDENT_OPTION(USE_TEXT "Text port for testing" TRUE "TEXT" FALSE)
CMAKE_DEPENDENT_OPTION(USE_CG "CoreGraphics needs to be enabled and run on macOS/iOS" TRUE "APPLE;CG" FALSE)
CMAKE_DEPENDENT_OPTION(USE_SKIA "Skia" TRUE "SKIA" FALSE)
CMAKE_DEPENDENT_OPTION(USE_GDIPLUS "GDI+ port" TRUE "MSVC;GDIPLUS" FALSE)
CMAKE_DEPENDENT_OPTION(USE_D2D "Direct2D port" TRUE "MSVC;D2D" FALSE)
CMAKE_DEPENDENT_OPTION(USE_CAIRO "Cairo" TRUE "CAIRO" FALSE)

CMAKE_DEPENDENT_OPTION(USE_TEXT_EXAMPLE "Text port for testing" TRUE "NOT LIB_ONLY;TEXT" FALSE)
CMAKE_DEPENDENT_OPTION(USE_C_EXAMPLE "C Wrapper port for demonstration" TRUE "NOT LIB_ONLY;TEXT" FALSE)
CMAKE_DEPENDENT_OPTION(USE_CG_EXAMPLE "CoreGraphics needs to be enabled and run on macOS/iOS" TRUE "NOT LIB_ONLY;USE_CG" FALSE)
CMAKE_DEPENDENT_OPTION(USE_SKIA_EXAMPLE "Skia" TRUE "NOT LIB_ONLY;SKIA" FALSE)
CMAKE_DEPENDENT_OPTION(USE_GDIPLUS_EXAMPLE "GDI+ example app" TRUE "NOT LIB_ONLY;GDIPLUS" FALSE)
CMAKE_DEPENDENT_OPTION(USE_D2D_EXAMPLE "Direct2D example app" TRUE "NOT LIB_ONLY;D2D" FALSE)
CMAKE_DEPENDENT_OPTION(USE_CAIRO_EXAMPLE "Cairo example" TRUE "NOT LIB_ONLY;CAIRO" FALSE)

find_package(PkgConfig)

################################
# setting for Skia
################################
if(SKIA)
    set(CMAKE_CXX_STANDARD 14)
    include(FindSkia)
    if (NOT SKIA_AVAILABLE)
        message(FATAL_ERROR "Fatal error: Skia port is requested, but no usable Skia library was found.")
    endif()
endif()

################################
# setting for Cairo
################################
if(CAIRO)
    # cmake wants to have full pathname of libcairo, instead of compiler flags.
    # thus FindCairo.cmake works better than pkg_check_modules(CAIRO cairo)
    include(FindCairo)
    if(NOT CAIRO_FOUND)
        message(FATAL_ERROR "Fatal error: Cairo port is requested, but CAIRO developers' files are missing.")
    else()
       # FindJPEG.cmake does not use pkg-config, we do as FindCairo.cmake.
       pkg_check_modules(PC_JPEG libjpeg)
       if (PC_JPEG_FOUND)
           FIND_PATH(JPEG_INCLUDE_DIRS NAMES jpeglib.h HINTS ${PC_JPEG_INCLUDEDIR})
           FIND_LIBRARY(JPEG_LIBRARY NAMES jpeg HINTS ${PC_JPEG_LIBDIR})
       else()
           include(FindJPEG)
       endif()
       if (NOT PC_JPEG_FOUND AND NOT JPEG_FOUND)
           message(FATAL_ERROR "Fatal error: Cairo port requires LIBJPEG developers' files.")
       endif()
    endif()
endif()

################################
# Other Attributes
################################
if(EXISTS "${CMAKE_TOOLCHAIN_FILE}")
    # do not apply any global settings if the toolchain
    # is being configured externally
elseif(MSVC)
    #add_definitions(/FI"${CMAKE_CURRENT_SOURCE_DIR}/public/include/CloudAI/ai/ASConfig.h")
    # Visual Studio pedantic build settings
    # warning C4512: assignment operator could not be generated
    # warning C4316: object allocated on the heap may not be aligned
    # set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /WX /wd4512 /wd4316")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zp8")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /we4302 /we4189")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /wd4290 /wd4335 /wd4355 /wd4814 /wd4091 /TP")
    if (NOT USE_SKIA)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /std:c++11")
    endif()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zc:sizedDealloc-")

    if (DEFINED WIN32_OBJECT_TYPE)
        if (CMAKE_VERSION VERSION_LESS "3.15")
            message(STATUS "CMake is too old (< 3.15), maybe output project file has wrong switch in /MT or /MD.")
            set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ${WIN32_OBJECT_TYPE}d")
            set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} ${WIN32_OBJECT_TYPE}")
            set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELEASE} ${WIN32_OBJECT_TYPE}")
            set(CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_RELEASE} ${WIN32_OBJECT_TYPE}")
        elseif(WIN32_OBJECT_TYPE STREQUAL "/MT")
            set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
        elseif(WIN32_OBJECT_TYPE STREQUAL "/MD")
            set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL")
        endif()
    endif()
elseif(APPLE)
    # GCC or Clang
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Wextra")
else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Wextra")
endif()
message(STATUS "CMAKE_CXX_STANDARD: ${CMAKE_CXX_STANDARD}")

set(dll_version)
if(WIN32)
    set(dll_version ${dll_version} src/win/version.rc)

    string(REPLACE "." "," VER_FILEVERSION ${VERSION})

    add_definitions(-DVER_FILEVERSION=${VER_FILEVERSION})
    add_definitions(-DVER_FILEVERSION_STR="${VERSION}")
    add_definitions(-DVER_PRODUCTVERSION=${VER_FILEVERSION})
    add_definitions(-DVER_PRODUCTVERSION_STR="${VERSION}")

endif()

if(STYLE)
    # Enable CSS style support. This feature is deprecated and will get removed.
    add_definitions(-DSTYLE_SUPPORT)
endif()
# Expose CMake definitions as preprocessor macros
if(USE_CAIRO)
    add_definitions(-DUSE_CAIRO)
endif()
if(USE_CG)
    add_definitions(-DUSE_CG)
endif()
if(USE_GDIPLUS)
    add_definitions(-DUSE_GDIPLUS)
endif()
if(USE_D2D)
    add_definitions(-DUSE_D2D)
endif()
if (USE_SKIA)
    add_definitions(-DUSE_SKIA)
endif()
if(USE_TEXT)
    add_definitions(-DUSE_TEXT)
endif()


##############################
# Demo/Testing applications
##############################
if(USE_TEXT_EXAMPLE)
    add_subdirectory(example/testText)
endif()
if(USE_CG_EXAMPLE)
    add_subdirectory(example/testCocoaCG)
endif()
if (USE_SKIA_EXAMPLE)
    add_subdirectory(example/testSkia)
endif()
if (USE_GDIPLUS_EXAMPLE)
    add_subdirectory(example/testGDIPlus)
endif()
if (USE_D2D_EXAMPLE)
    add_subdirectory(example/testD2D)
endif()
if (USE_C_EXAMPLE)
    add_subdirectory(example/testC)
endif()
if (USE_CAIRO_EXAMPLE)
    add_subdirectory(example/testCairo)
endif()

##############################
# CPP and Headers for Library
##############################
file(GLOB gl_public
    include/SVGDocument.h
    include/SVGNativeCWrapper.h
    include/SVGRenderer.h
    include/Rect.h
)
file(GLOB gl_source
    src/Constants.h
    src/SVGDocumentImpl.h
    src/SVGDocumentImpl.cpp
    src/SVGDocument.cpp
    src/Rect.cpp
    src/SVGRenderer.cpp
    src/Interval.h
    src/Interval.cpp
    src/SVGNativeCWrapper.cpp
    src/SVGParserArcToCurve.cpp
    src/SVGStringParser.h
    src/SVGStringParser.cpp
)

set(gl_deprecated_styling)
if(STYLE)
file(GLOB gl_deprecated_styling
    src/DeprecatedSVGDocumentImpl.cpp
)
endif()

#####################################################
# Rendering ports, and collect gl_headers to install
#####################################################
file(GLOB gl_headers ${PROJECT_SOURCE_DIR}/include/*.h)

set(text_port)
if(USE_TEXT)
file(GLOB text_port
    src/ports/string/StringSVGRenderer.h
    src/ports/string/StringSVGRenderer.cpp
)
set(gl_headers ${gl_headers} ${PROJECT_SOURCE_DIR}/ports/string/StringSVGRenderer.h)
endif()

set(cg_port)
if(USE_CG)
file(GLOB cg_port
    src/ports/cg/CGSVGRenderer.h
    src/ports/cg/CGSVGRenderer.cpp
    ../third_party/cpp-base64/base64.h
    ../third_party/cpp-base64/base64.cpp
)
set(gl_headers ${gl_headers} ${PROJECT_SOURCE_DIR}/ports/cg/CGSVGRenderer.h)
endif()

set(skia_port)
if (USE_SKIA)
file(GLOB skia_port
    src/ports/skia/SkiaSVGRenderer.h
    src/ports/skia/SkiaSVGRenderer.cpp
    ../third_party/cpp-base64/base64.h
    ../third_party/cpp-base64/base64.cpp
)
set(gl_headers ${gl_headers} ${PROJECT_SOURCE_DIR}/ports/skia/SkiaSVGRenderer.h)
if (NOT MSVC)
    set_source_files_properties(ports/skia/SkiaSVGRenderer.cpp PROPERTIES COMPILE_FLAGS -Wno-pedantic)
endif()
endif()

set(gdiplus_port)
if (USE_GDIPLUS)
file(GLOB gdiplus_port
    src/ports/gdiplus/GDIPlusSVGRenderer.h
    src/ports/gdiplus/GDIPlusSVGRenderer.cpp
    ../third_party/cpp-base64/base64.h
    ../third_party/cpp-base64/base64.cpp
)
set(gl_headers ${gl_headers} ${PROJECT_SOURCE_DIR}/ports/gdiplus/GDIPlusSVGRenderer.h)
endif()

set(d2d_port)
if (USE_D2D)
file(GLOB d2d_port
    src/ports/d2d/D2DSVGRenderer.h
    src/ports/d2d/D2DSVGRenderer.cpp
    ../third_party/cpp-base64/base64.h
    ../third_party/cpp-base64/base64.cpp
)
set(gl_headers ${gl_headers} ${PROJECT_SOURCE_DIR}/ports/d2d/D2DSVGRenderer.h)
endif()

set(cairo_port)
if (USE_CAIRO)
file(GLOB cairo_port
    src/ports/cairo/CairoSVGRenderer.h
    src/ports/cairo/CairoSVGRenderer.cpp
    src/ports/cairo/CairoImageInfo.h
    src/ports/cairo/CairoImageInfo.c
    ../third_party/cpp-base64/base64.h
    ../third_party/cpp-base64/base64.cpp
)
set(gl_headers ${gl_headers} ${PROJECT_SOURCE_DIR}/ports/cairo/CairoSVGRenderer.h)
endif()

##############################
# XML parser
##############################

set(XML_PARSER_SOURCE "src/xml/RapidXMLParser.cpp")
if (USE_PLATFORM_XML)
include(FindEXPAT)
find_package(EXPAT)
if (EXPAT_FOUND)
    set(XML_PARSER_SOURCE "src/xml/ExpatXMLParser.cpp")
else()
find_package(LibXml2)
if (LIBXML2_FOUND)
    set(XML_PARSER_SOURCE "src/xml/LibXMLParser.cpp")
endif(LIBXML2_FOUND)
endif(EXPAT_FOUND)
endif(USE_PLATFORM_XML)

file(GLOB xml_parser
    src/xml/XMLParser.h
    ${XML_PARSER_SOURCE}
)

##############################
# Library settings
##############################
set(svgNative_src
    ${gl_public}
    ${gl_deprecated_styling}
    ${gl_source}
    ${text_port}
    ${cg_port}
    ${skia_port}
    ${gdiplus_port}
    ${d2d_port}
    ${cairo_port}
    ${dll_version}
    ${xml_parser}
)

if (USE_SHARED)
add_definitions(-DBUILDING_DLL)
add_library(SVGNativeViewerLib SHARED ${svgNative_src})
else()
add_library(SVGNativeViewerLib STATIC ${svgNative_src})
endif()

##############################
# Header search paths
##############################
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_include_directories(SVGNativeViewerLib PRIVATE "${CMAKE_CURRENT_SOURCE_DIR}/src")
if(STYLE)
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/stylesheet/include")
endif()
if (USE_CG)
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/cpp-base64")
endif()
if (USE_SKIA)
if (NOT DEFINED SKIA_SOURCE_DIR)
    set(SKIA_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/skia")
endif()
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}")
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}/include/codec")
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}/include/config")
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}/include/core")
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}/include/effects")
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}/include/encode")
target_include_directories(SVGNativeViewerLib PUBLIC "${SKIA_SOURCE_DIR}/include/gpu")
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/cpp-base64")
endif()
if (USE_GDIPLUS)
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/cpp-base64")
endif()
if (USE_D2D)
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/cpp-base64")
endif()
if (USE_CAIRO)
target_include_directories(SVGNativeViewerLib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/../third_party/cpp-base64")
target_include_directories(SVGNativeViewerLib PUBLIC "${CAIRO_INCLUDE_DIRS}")
endif()

##############################
# Library search paths
##############################
set(PRIVATE_LIBS)
set(REQUIRES)
set(PRIVATE_REQUIRES)
set(PORTS_INCLUDES)

if(USE_CG)
    target_link_libraries(SVGNativeViewerLib "-framework CoreGraphics")
    target_link_libraries(SVGNativeViewerLib "-framework CoreFoundation")
    set(PRIVATE_LIBS "${PRIVATE_LIBS} -framework CoreGraphics -framework CoreFoundation")
    set(PORTS_INCLUDES "${PORTS_INCLUDES} -I\${includedir}/ports/cg")
endif()

if (USE_SKIA)
    target_link_libraries(SVGNativeViewerLib "${SKIA_LIBRARY_PATH}")
    set(PRIVATE_LIBS "${PRIVATE_LIBS} ${SKIA_LIBRARY_LDFLAGS}")
    set(PORTS_INCLUDES "${PORTS_INCLUDES} -I\${includedir}/ports/skia")
endif()

if (USE_GDIPLUS)
    target_link_libraries(SVGNativeViewerLib "gdiplus.lib")
    set(PRIVATE_LIBS "${PRIVATE_LIBS} gdiplus.lib")
endif()

if (USE_D2D)
    target_link_libraries(SVGNativeViewerLib "d2d1.lib")
    set(PRIVATE_LIBS "${PRIVATE_LIBS} d2d1.lib")
endif()

if (USE_CAIRO)
    target_link_libraries(SVGNativeViewerLib "${CAIRO_LIBRARIES}")
    target_link_libraries(SVGNativeViewerLib "${JPEG_LIBRARY}")
    target_include_directories(SVGNativeViewerLib PUBLIC "${CAIRO_INCLUDE_DIRS}")
    target_include_directories(SVGNativeViewerLib PRIVATE "${JPEG_INCLUDE_DIRS}")
    set(PRIVATE_REQUIRES "${PRIVATE_REQUIRES} cairo")
    set(PORTS_INCLUDES "${PORTS_INCLUDES} -I\${includedir}/ports/cairo")

    # sometimes JPEG is not managed by pkg-config
    if (PC_JPEG_FOUND)
        set(PRIVATE_REQUIRES "${PRIVATE_REQUIRES} libjpeg")
    else()
        get_filename_component(JPEG_LIBRARY_DIR ${JPEG_LIBRARY} DIRECTORY)
        set(PRIVATE_LIBS "${PRIVATE_LIBS} -L${JPEG_LIBRARY_DIR} -ljpeg")
    endif()
endif()

if (EXPAT_FOUND)
    target_link_libraries(SVGNativeViewerLib "${EXPAT_LIBRARIES}")
    target_include_directories(SVGNativeViewerLib PUBLIC  "${EXPAT_INCLUDE_DIRS}")
    if (PC_EXPAT_VERSION) # if expat is managed by pkg-config
        set(PRIVATE_REQUIRES "${PRIVATE_REQUIRES} expat")
    else() # if expat is out of pkg-config
        get_filename_component(EXPAT_LIB_DIR "${EXPAT_LIBRARIES}" DIRECTORY)
        set(PRIVATE_LIBS "${PRIVATE_LIBS} -L${EXPAT_LIB_DIR} -lexpat")
    endif()
endif(EXPAT_FOUND)

if (LIBXML2_FOUND)
    target_link_libraries(SVGNativeViewerLib "${LIBXML2_LIBRARIES}")
    target_include_directories(SVGNativeViewerLib PUBLIC  "${LIBXML2_INCLUDE_DIR}")
    if (PC_LIBXML_VERSION) # if libxml2 is managed by pkg-config
        set(PRIVATE_REQUIRES "${PRIVATE_REQUIRES} libxml-2.0")
    else() # if libxml2 is out of pkg-config
        get_filename_component(LIBXML2_LIB_DIR "${LIBXML2_LIBRARY}" DIRECTORY)
        set(PRIVATE_LIBS "${PRIVATE_LIBS} -L${LIBXML2_LIB_DIR} -lxml2")
    endif()
endif(LIBXML2_FOUND)

# CMake has no additional file to record the dependency for the static library,
# we have to put direct dependencies into pkg-config files.
if (NOT USE_SHARED)
    set(REQUIRES "${PRIVATE_REQUIRES}")
    set(PRIVATE_REQUIRES "")
endif()

set_target_properties(SVGNativeViewerLib PROPERTIES LINKER_LANGUAGE CXX)

# Give system or user provided Boost version precedence 
set(Boost_USE_STATIC_LIBS OFF)
find_package(Boost)
if(NOT Boost_FOUND)
    message(STATUS "Falling back to minimal boost")
    set(BOOST_INCLUDEDIR ${CMAKE_CURRENT_SOURCE_DIR}/../third_party/boost_variant_property_tree/)
    set(BOOST_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../third_party/boost_variant_property_tree/boost/)
    find_package(Boost)
    if(NOT Boost_FOUND)
        message(FATAL_ERROR "Fatal error: Boost (version >= 1.55) required.")
    endif()
endif()
if(Boost_FOUND)
    target_include_directories(SVGNativeViewerLib PUBLIC ${Boost_INCLUDE_DIRS})
endif()

##############################
# Creating pkg-config file
##############################
include(GNUInstallDirs)

set(BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}")
set(SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
set(CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")
set(CMAKE_INSTALL_BINDIR "${CMAKE_INSTALL_BINDIR}")
set(CMAKE_INSTALL_LIBDIR "${CMAKE_INSTALL_LIBDIR}")
set(CMAKE_INSTALL_INCLUDEDIR "${CMAKE_INSTALL_INCLUDEDIR}")
set(PRIVATE_LIBS "${PRIVATE_LIBS}")
set(REQUIRES "${REQUIRES}")
set(PRIVATE_REQUIRES "${PRIVATE_REQUIRES}")
set(PORTS_INCLUDES "${PORTS_INCLUDES}")
set(HEADER_SUBDIR "svgnative")
CONFIGURE_FILE("${CMAKE_CURRENT_SOURCE_DIR}/SVGNativeViewerLib.pc.in"
               "${CMAKE_CURRENT_BINARY_DIR}/SVGNativeViewerLib.pc" @ONLY)
CONFIGURE_FILE("${CMAKE_CURRENT_SOURCE_DIR}/SVGNativeViewerLib-uninstalled.pc.in"
               "${CMAKE_CURRENT_BINARY_DIR}/SVGNativeViewerLib-uninstalled.pc" @ONLY)


################################
# setup Google Test for testing
################################
if (TESTING)
    enable_testing()
    include(FetchContent)
    # FetchContent_Declare(googletest GIT_REPOSITORY https://github.com/google/googletest.git)    
    FetchContent_Declare(googletest URL https://github.com/google/googletest/archive/e2239ee6043f73722e7aa812a459f54a28552929.zip)    
    # For Windows: Prevent overriding the parent project's compiler/linker settings
    set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
    message(STATUS "Fetching Google Test framework for automated testing")
    FetchContent_MakeAvailable(googletest)
    message(STATUS "Successfully fetched Google Test framework")
    add_subdirectory(tests)
endif()

##############################
# Installation
##############################

# library
install(
    TARGETS SVGNativeViewerLib
    EXPORT SVGNativeViewerLib-targets
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    COMPONENT libraries)

# headers
install(
    FILES ${gl_headers}
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${HEADER_SUBDIR}
    COMPONENT headers)

# pkg-config file
install(
    FILES ${CMAKE_CURRENT_BINARY_DIR}/SVGNativeViewerLib.pc
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig
    COMPONENT pkgconfig)
</file>

<file path="svgnative/src/SVGDocumentImpl.cpp">
/*
Copyright 2014 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

#include "SVGDocumentImpl.h"

#include "Constants.h"
#include "svgnative/SVGDocument.h"
#include "svgnative/SVGRenderer.h"
#include "SVGStringParser.h"
#include "xml/XMLParser.h"

#include <cmath>
#include <limits>

using namespace SVGNative::xml;

namespace SVGNative
{
constexpr std::array<const char*, 14> gInheritedPropertyNames{{
    kColorProp,
    kClipRuleProp,
    kFillProp,
    kFillRuleProp,
    kFillOpacityProp,
    kStrokeProp,
    kStrokeDasharrayProp,
    kStrokeDashoffsetProp,
    kStrokeLinecapProp,
    kStrokeLinejoinProp,
    kStrokeMiterlimitProp,
    kStrokeOpacityProp,
    kStrokeWidthProp,
    kVisibilityProp
}};

constexpr std::array<const char*, 5> gNonInheritedPropertyNames{{
    kClipPathProp,
    kDisplayProp,
    kOpacityProp,
    kStopOpacityProp,
    kStopColorProp
}};

template <typename T>
bool isCloseToZero(T x)
{
    return std::abs(x) < std::numeric_limits<T>::epsilon();
}

SVGDocumentImpl::SVGDocumentImpl(std::shared_ptr<SVGRenderer> renderer)
    : mViewBox{{0, 0, 320.0f, 200.0f}}
    , mRenderer{renderer}
{
    mFillStyleStack.push(FillStyleImpl());
    mStrokeStyleStack.push(StrokeStyleImpl());

    GraphicStyleImpl graphicStyle{};
    std::set<std::string> classNames;
    mGroup = std::make_shared<Group>(graphicStyle, classNames);
    mGroupStack.push(mGroup);
}

void SVGDocumentImpl::TraverseSVGTree(XMLNode* rootNode)
{
    if (!rootNode || strcmp(rootNode->GetName(), kSvgElem))
        return;
    mRootNode = rootNode;

    auto viewBoxAttr = rootNode->GetAttribute(kViewBoxAttr);
    if (!viewBoxAttr.found)
    {
        mViewBox[0] = SVGDocumentImpl::ParseLengthFromAttr(rootNode, kXAttr, LengthType::kHorizontal, mViewBox[0]);
        mViewBox[1] = SVGDocumentImpl::ParseLengthFromAttr(rootNode, kYAttr, LengthType::kVertical, mViewBox[1]);
        mViewBox[2] = SVGDocumentImpl::ParseLengthFromAttr(rootNode, kWidthAttr, LengthType::kHorizontal, mViewBox[2]);
        mViewBox[3] = SVGDocumentImpl::ParseLengthFromAttr(rootNode, kHeightAttr, LengthType::kVertical, mViewBox[3]);
    }
    else
    {
        std::vector<float> numberList;
        if (SVGStringParser::ParseListOfNumbers(viewBoxAttr.value, numberList) && numberList.size() == 4)
            mViewBox = {{numberList[0], numberList[1], numberList[2], numberList[3]}};
    }

#if DEBUG
    auto dataNameAttr = rootNode->GetAttribute(kDataNameAttr);
    if (dataNameAttr.found)
        mTitle = dataNameAttr.value;
#endif

    ParseChild(rootNode);

    // Clear all temporary sets
    mGradients.clear();
    mClippingPaths.clear();
    mRootNode = nullptr;
}

float SVGDocumentImpl::RelativeLength(LengthType lengthType) const
{
    float relLength{};
    switch (lengthType)
    {
    case LengthType::kHorizontal:
        relLength = mViewBox[2];
        break;
    case LengthType::kVertical:
        relLength = mViewBox[3];
        break;
    case LengthType::kDiagonal:
        relLength = sqrtf(mViewBox[2] * mViewBox[2] + mViewBox[3] * mViewBox[3]);
        break;
    default:
        break;
    }
    return relLength;
}

float SVGDocumentImpl::ParseLengthFromAttr(const XMLNode* node, const char* attrName, LengthType lengthType, float fallback)
{
    if (!node)
        return fallback;

    float number{};
    auto attr = node->GetAttribute(attrName);
    if (!attr.found || !SVGStringParser::ParseLengthOrPercentage(attr.value, RelativeLength(lengthType), number, true))
        return fallback;

    return number;
}

void SVGDocumentImpl::ParseChildren(XMLNode* node)
{
    SVG_ASSERT(node != nullptr);

    for (auto child = node->GetFirstNode(); child != nullptr; child = child->GetNextSibling())
    {
        ParseChild(child.get());
    }
}

void SVGDocumentImpl::ParseChild(XMLNode* child)
{
    SVG_ASSERT(child != nullptr);

    auto fillStyle = mFillStyleStack.top();
    auto strokeStyle = mStrokeStyleStack.top();
    std::set<std::string> classNames;
    auto graphicStyle = ParseGraphic(child, fillStyle, strokeStyle, classNames);

    std::string idString;
    auto idAttr = child->GetAttribute(kIdAttr);
    if (idAttr.found)
        idString = idAttr.value;

    // Check if we have a shape rect, circle, ellipse, line, polygon, polyline
    // or path first.
    if (auto path = ParseShape(child))
    {
        AddChildToCurrentGroup(std::unique_ptr<Graphic>(new Graphic(graphicStyle, classNames, fillStyle, strokeStyle, std::move(path))), std::move(idString));
        return;
    }

    // Look at all elements that are no shapes.
    const auto elementName = child->GetName();
    if (!strcmp(elementName, kGElem) || (!strcmp(elementName, kSvgElem) && child == mRootNode))
    {
        mFillStyleStack.push(fillStyle);
        mStrokeStyleStack.push(strokeStyle);

        auto group = std::make_shared<Group>(graphicStyle, classNames);
        AddChildToCurrentGroup(group, std::move(idString));
        mGroupStack.push(group);

        ParseChildren(child);

        mGroupStack.pop();
        mFillStyleStack.pop();
        mStrokeStyleStack.pop();
    }
    else if (!strcmp(elementName, kDefsElem))
    {
        mFillStyleStack.push(fillStyle);
        mStrokeStyleStack.push(strokeStyle);

        // Create dummmy group. All children w/o id will get cleaned up.
        mGroupStack.push(std::make_shared<Group>(graphicStyle, classNames));

        ParseChildren(child);

        mGroupStack.pop();
        mFillStyleStack.pop();
        mStrokeStyleStack.pop();
    }
    else if (!strcmp(elementName, kImageElem))
    {
        std::unique_ptr<ImageData> imageData;
        auto hrefAttr = child->GetAttribute(kHrefAttr, kXlinkNS);
        if (hrefAttr.found)
        {
            const std::string dataURL = hrefAttr.value;
            ImageEncoding encoding{};
            unsigned short base64Offset{22};
            if (dataURL.find(kDataUrlPngVal) == 0)
                encoding = ImageEncoding::kPNG;
            else if (dataURL.find(kDataUrlJpgVal) == 0)
                encoding = ImageEncoding::kJPEG;
            else if (dataURL.find(kDataUrlJpegVal) == 0)
            {
                encoding = ImageEncoding::kJPEG;
                base64Offset = 23;
            }
            else
                return;
            imageData = mRenderer->CreateImageData(dataURL.substr(base64Offset), encoding);
        }

        if (imageData)
        {
            const float imageWidth = ParseLengthFromAttr(child, kWidthAttr, LengthType::kHorizontal);
            const float imageHeight = ParseLengthFromAttr(child, kHeightAttr, LengthType::kVertical);

            Rect clipArea{ParseLengthFromAttr(child, kXAttr, LengthType::kHorizontal),
                ParseLengthFromAttr(child, kYAttr, LengthType::kVertical),
                ParseLengthFromAttr(child, kWidthAttr, LengthType::kHorizontal, imageWidth),
                ParseLengthFromAttr(child, kHeightAttr, LengthType::kVertical, imageHeight)};

            std::string align;
            std::string meetOrSlice;
            std::vector<std::string> attrStringValues;
            auto preserveAspectRatioAttr = child->GetAttribute(kPreserveAspectRatioAttr);
            if (preserveAspectRatioAttr.found
                && SVGStringParser::ParseListOfStrings(preserveAspectRatioAttr.value, attrStringValues)
                && attrStringValues.size() >= 1 && attrStringValues.size() <= 2)
            {
                align = attrStringValues[0];
                if (attrStringValues.size() == 2)
                    meetOrSlice = attrStringValues[1];
            }

            Rect fillArea{clipArea};
            if (align.compare(kNoneVal) != 0)
            {
                fillArea.width = imageWidth;
                fillArea.height = imageHeight;
                float scaleX = clipArea.width / imageWidth;
                float scaleY = clipArea.height / imageHeight;
                float scale{};
                if (meetOrSlice.compare(kSliceVal) == 0)
                    scale = std::max(scaleX, scaleY);
                else
                    scale = std::min(scaleX, scaleY);
                fillArea.width *= scale;
                fillArea.height *= scale;

                if (align.compare(kXMinYMinVal) == 0)
                {
                    fillArea.x = clipArea.x;
                    fillArea.y = clipArea.y;
                }
                else if (align.compare(kXMidYMinVal) == 0)
                {
                    fillArea.x = (clipArea.x + clipArea.width / 2) - fillArea.width / 2;
                    fillArea.y = clipArea.y;
                }
                else if (align.compare(kXMaxYMinVal) == 0)
                {
                    fillArea.x = clipArea.x + clipArea.width - fillArea.width;
                    fillArea.y = clipArea.y;
                }
                else if (align.compare(kXMinYMidVal) == 0)
                {
                    fillArea.x = clipArea.x;
                    fillArea.y = (clipArea.y + clipArea.height / 2) - fillArea.height / 2;
                }
                else if (align.compare(kXMaxYMidVal) == 0)
                {
                    fillArea.x = clipArea.x + clipArea.width - fillArea.width;
                    fillArea.y = (clipArea.y + clipArea.height / 2) - fillArea.height / 2;
                }
                else if (align.compare(kXMinYMaxVal) == 0)
                {
                    fillArea.x = clipArea.x;
                    fillArea.y = clipArea.y + clipArea.height - fillArea.height;
                }
                else if (align.compare(kXMidYMaxVal) == 0)
                {
                    fillArea.x = (clipArea.x + clipArea.width / 2) - fillArea.width / 2;
                    fillArea.y = clipArea.y + clipArea.height - fillArea.height;
                }
                else if (align.compare(kXMaxYMaxVal) == 0)
                {
                    fillArea.x = clipArea.x + clipArea.width - fillArea.width;
                    fillArea.y = clipArea.y + clipArea.height - fillArea.height;
                }
                else // default and "xMidYMid"
                {
                    fillArea.x = (clipArea.x + clipArea.width / 2) - fillArea.width / 2;
                    fillArea.y = (clipArea.y + clipArea.height / 2) - fillArea.height / 2;
                }
            }

            // Do not render 0-sized elements.
            if (imageWidth && imageHeight && clipArea.width && clipArea.height && fillArea.width && fillArea.height)
            {
                auto image = std::unique_ptr<Image>(new Image(graphicStyle, classNames, std::move(imageData), clipArea, fillArea));
                AddChildToCurrentGroup(std::move(image), std::move(idString));
            }
        }
    }
    else if (!strcmp(elementName, kUseElem))
    {
        auto hrefAttr = child->GetAttribute(kHrefAttr, kXlinkNS);
        if (!hrefAttr.found || !hrefAttr.value || hrefAttr.value[0] != '#')
            return;

        const float x = ParseLengthFromAttr(child, kXAttr, LengthType::kHorizontal);
        const float y = ParseLengthFromAttr(child, kYAttr, LengthType::kVertical);
        if (!isCloseToZero(x) || !isCloseToZero(y))
        {
            if (!graphicStyle.transform)
                graphicStyle.transform = mRenderer->CreateTransform();
            graphicStyle.transform->Concat(1, 0, 0, 1, x, y);
        }

        std::string href{(hrefAttr.value + 1)};
        AddChildToCurrentGroup(std::make_shared<Reference>(graphicStyle, classNames, fillStyle, strokeStyle, std::move(href)), std::move(idString));
    }
    else if (!strcmp(elementName, kSymbolElem))
    {
        // FIXME: Do not render <symbol> outside of <defs> section.
        // FIXME: Remove support for symbol ASAP.
        auto attr = child->GetAttribute(kViewBoxAttr);
        if (attr.found)
        {
            std::vector<float> numberList;
            if (SVGStringParser::ParseListOfNumbers(attr.value, numberList) && numberList.size() == 4)
                graphicStyle.transform = mRenderer->CreateTransform(1, 0, 0, 1, -numberList[0], -numberList[1]);
        }

        auto group = std::make_shared<Group>(graphicStyle, classNames);
        AddChildToCurrentGroup(group, std::move(idString));
        mGroupStack.push(group);

        ParseChildren(child);

        mGroupStack.pop();
    }
    else if (!strcmp(elementName, kLinearGradientElem) || !strcmp(elementName, kRadialGradientElem))
    {
        mFillStyleStack.push(fillStyle);
        mStrokeStyleStack.push(strokeStyle);

        ParseGradient(child);

        mFillStyleStack.pop();
        mStrokeStyleStack.pop();
    }
#ifdef STYLE_SUPPORT
    else if (!strcmp(elementName, kStyleElem))
        ParseStyle(child);
#endif
    else if (!strcmp(elementName, kClipPathElem))
    {
        auto id = child->GetAttribute(kIdAttr);
        if (!id.found)
            return;

        mFillStyleStack.push(fillStyle);
        mStrokeStyleStack.push(strokeStyle);

        // SVG only allows shapes (and <use> elements referencing shapes) as children of
        // <clipPath>. Ignore all other elements.
        bool hasClipContent{false};
        for (auto clipPathChild = child->GetFirstNode(); clipPathChild != nullptr; clipPathChild = clipPathChild->GetNextSibling())
        {
            // WebKit and Blink allow the clipping path if there is at least one valid basic shape child.
            if (auto path = ParseShape(clipPathChild.get()))
            {
                std::unique_ptr<Transform> transform;
                auto attr = clipPathChild->GetAttribute(kTransformAttr);
                if (attr.found)
                {
                    SVG_ASSERT(mRenderer != nullptr);
                    transform = mRenderer->CreateTransform();
                    if (!SVGStringParser::ParseTransform(attr.value, *transform))
                        transform.reset();
                }
                auto fillStyleChild = mFillStyleStack.top();
                auto strokeStyleChild = mStrokeStyleStack.top();
                std::set<std::string> classNames;
                ParseGraphic(child, fillStyleChild, strokeStyleChild, classNames);
                mClippingPaths[id.value] = std::make_shared<ClippingPath>(true, fillStyleChild.clipRule, std::move(path), std::move(transform));
                hasClipContent = true;
                break;
            }
        }
        if (!hasClipContent)
            mClippingPaths[id.value] = std::make_shared<ClippingPath>(false, WindingRule::kNonZero, nullptr, nullptr);
        mFillStyleStack.pop();
        mStrokeStyleStack.pop();
    }
}

std::unique_ptr<Path> SVGDocumentImpl::ParseShape(XMLNode* child)
{
    SVG_ASSERT(child != nullptr);

    const auto elementName = child->GetName();
    if (!strcmp(elementName, kRectElem))
    {
        float x = ParseLengthFromAttr(child, kXAttr, LengthType::kHorizontal);
        float y = ParseLengthFromAttr(child, kYAttr, LengthType::kVertical);

        float width = ParseLengthFromAttr(child, kWidthAttr, LengthType::kHorizontal);
        float height = ParseLengthFromAttr(child, kHeightAttr, LengthType::kVertical);

        // SVG requires to disable rendering if width or height are 0.
        if (isCloseToZero(width) || isCloseToZero(height))
            return nullptr;

        auto rxAttr = child->GetAttribute(kRxAttr);
        auto ryAttr = child->GetAttribute(kRyAttr);

        float rx{};
        float ry{};
        if (rxAttr.found && ryAttr.found)
        {
            rx = ParseLengthFromAttr(child, kRxAttr, LengthType::kHorizontal);
            ry = ParseLengthFromAttr(child, kRyAttr, LengthType::kVertical);
        }
        else if (rxAttr.found)
        {
            // the svg spec says that rect elements that specify a rx but not a ry
            // should use the rx value for ry
            rx = ParseLengthFromAttr(child, kRxAttr, LengthType::kHorizontal);
            ry = rx;
        }
        else if (ryAttr.found)
        {
            // the svg spec says that rect elements that specify a ry but not a rx
            // should use the ry value for rx
            ry = ParseLengthFromAttr(child, kRyAttr, LengthType::kVertical);
            rx = ry;
        }
        else
        {
            rx = 0;
            ry = 0;
        }

        rx = std::min(rx, width / 2.0f);
        ry = std::min(ry, height / 2.0f);

        auto path = mRenderer->CreatePath();
        if (isCloseToZero(rx) || isCloseToZero(ry))
        {
            path->Rect(x, y, width, height);
        }
        else
        {
            path->RoundedRect(x, y, width, height, rx, ry);
        }
        return path;
    }
    else if (!strcmp(elementName, kEllipseElem) || !strcmp(elementName, kCircleElem))
    {
        float rx{}, ry{};

        if (!strcmp(elementName, kEllipseElem))
        {
            rx = ParseLengthFromAttr(child, kRxAttr, LengthType::kHorizontal);
            ry = ParseLengthFromAttr(child, kRyAttr, LengthType::kVertical);
        }
        else
        {
            rx = ParseLengthFromAttr(child, kRAttr, LengthType::kDiagonal);
            ry = rx;
        }

        // SVG requires to disable rendering if rx or ry are 0.
        if (isCloseToZero(rx) || isCloseToZero(ry))
            return nullptr;

        float cx = ParseLengthFromAttr(child, kCxAttr, LengthType::kHorizontal);
        float cy = ParseLengthFromAttr(child, kCyAttr, LengthType::kVertical);

        auto path = mRenderer->CreatePath();
        path->Ellipse(cx, cy, rx, ry);

        return path;
    }
    else if (!strcmp(elementName, kPolygonElem) || !strcmp(elementName, kPolylineElem))
    {
        auto attr = child->GetAttribute(kPointsAttr);
        if (!attr.found)
            return nullptr;
        // This does not follow the spec which requires at least one space or comma between
        // coordinate pairs. However, Blink and WebKit do it the same way.
        std::vector<float> numberList;
        SVGStringParser::ParseListOfNumbers(attr.value, numberList);
        auto size = numberList.size();
        auto path = mRenderer->CreatePath();
        if (size > 1)
        {
            if (size % 2 == 1)
                --size;
            decltype(size) i{};
            path->MoveTo(numberList[i], numberList[i + 1]);
            i += 2;
            for (; i < size; i += 2)
                path->LineTo(numberList[i], numberList[i + 1]);
            if (!strcmp(elementName, kPolygonElem))
                path->ClosePath();
        }

        return path;
    }
    else if (!strcmp(elementName, kPathElem))
    {
        auto attr = child->GetAttribute(kDAttr);
        if (!attr.found)
            return nullptr;

        auto path = mRenderer->CreatePath();
        SVGStringParser::ParsePathString(attr.value, *path);

        return path;
    }
    else if (!strcmp(elementName, kLineElem))
    {
        auto path = mRenderer->CreatePath();
        path->MoveTo(ParseLengthFromAttr(child, kX1Attr, LengthType::kHorizontal), ParseLengthFromAttr(child, kY1Attr, LengthType::kVertical));
        path->LineTo(ParseLengthFromAttr(child, kX2Attr, LengthType::kHorizontal), ParseLengthFromAttr(child, kY2Attr, LengthType::kVertical));

        return path;
    }
    return nullptr;
}

GraphicStyleImpl SVGDocumentImpl::ParseGraphic(
    const XMLNode* node, FillStyleImpl& fillStyle, StrokeStyleImpl& strokeStyle, std::set<std::string>& classNames)
{
    SVG_ASSERT(node != nullptr);

    std::vector<PropertySet> propertySets;
    propertySets.push_back(ParsePresentationAttributes(node));
    ParseStyleAttr(node, propertySets, classNames);

    GraphicStyleImpl graphicStyle{};
    for (const auto& propertySet : propertySets)
    {
        ParseGraphicsProperties(graphicStyle, propertySet);
        ParseFillProperties(fillStyle, propertySet);
        ParseStrokeProperties(strokeStyle, propertySet);
    }

    auto transformAttr = node->GetAttribute(kTransformAttr);
    if (transformAttr.found && node != mRootNode) // Ignore transforms on root SVG node
    {
        SVG_ASSERT(mRenderer != nullptr);
        graphicStyle.transform = mRenderer->CreateTransform();
        if (!SVGStringParser::ParseTransform(transformAttr.value, *graphicStyle.transform))
            graphicStyle.transform.reset();
    }

    return graphicStyle;
}

static inline void AddDetectedProperty(const XMLNode* node, PropertySet& propertySet, const char* propertyName)
{
    auto attr = node->GetAttribute(propertyName);
    if (attr.found)
        propertySet.insert({propertyName, attr.value});
}

PropertySet SVGDocumentImpl::ParsePresentationAttributes(const XMLNode* node)
{
    SVG_ASSERT(node != nullptr);

    PropertySet propertySet;
    for (const auto& propertyName : gInheritedPropertyNames)
        AddDetectedProperty(node, propertySet, propertyName);
    for (const auto& propertyName : gNonInheritedPropertyNames)
        AddDetectedProperty(node, propertySet, propertyName);
    return propertySet;
}

void SVGDocumentImpl::ParseFillProperties(FillStyleImpl& fillStyle, const PropertySet& propertySet)
{
    auto prop = propertySet.find(kFillProp);
    auto iterEnd = propertySet.end();
    if (prop != iterEnd)
    {
        auto result = SVGStringParser::ParsePaint(prop->second, mGradients, mViewBox, fillStyle.internalPaint);
        if (result == SVGDocumentImpl::Result::kDisabled)
            fillStyle.hasFill = false;
        else if (result == SVGDocumentImpl::Result::kSuccess)
            fillStyle.hasFill = true;
    }

    prop = propertySet.find(kFillOpacityProp);
    if (prop != iterEnd)
    {
        float opacity{};
        if (SVGStringParser::ParseAlphaValue(prop->second, opacity))
            fillStyle.fillOpacity = std::max<float>(0.0, std::min<float>(1.0, opacity));
    }

    prop = propertySet.find(kFillRuleProp);
    if (prop != iterEnd)
    {
        if (prop->second == kEvenoddVal)
            fillStyle.fillRule = WindingRule::kEvenOdd;
        else if (prop->second == kNonzeroVal)
            fillStyle.fillRule = WindingRule::kNonZero;
    }

    // Other inherited properties
    prop = propertySet.find(kColorProp);
    if (prop != iterEnd)
    {
        ColorImpl color = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
        auto result = SVGStringParser::ParseColor(prop->second, color, false);
        if (result == SVGDocumentImpl::Result::kSuccess)
            fillStyle.color = color;
    }

    prop = propertySet.find(kVisibilityProp);
    if (prop != iterEnd)
    {
        const auto& visibilityString = prop->second;
        if (visibilityString == kHiddenVal)
            fillStyle.visibility = false;
        else if (visibilityString == kCollapseVal || visibilityString == kVisibleVal)
            fillStyle.visibility = true;
    }

    prop = propertySet.find(kClipRuleProp);
    if (prop != iterEnd)
    {
        if (prop->second == kEvenoddVal)
            fillStyle.clipRule = WindingRule::kEvenOdd;
        else if (prop->second == kNonzeroVal)
            fillStyle.clipRule = WindingRule::kNonZero;
    }
}

void SVGDocumentImpl::ParseStrokeProperties(StrokeStyleImpl& strokeStyle, const PropertySet& propertySet)
{
    auto prop = propertySet.find(kStrokeProp);
    auto iterEnd = propertySet.end();
    if (prop != iterEnd)
    {
        auto result = SVGStringParser::ParsePaint(prop->second, mGradients, mViewBox, strokeStyle.internalPaint);
        if (result == SVGDocumentImpl::Result::kDisabled)
            strokeStyle.hasStroke = false;
        else if (result == SVGDocumentImpl::Result::kSuccess)
            strokeStyle.hasStroke = true;
    }

    prop = propertySet.find(kStrokeWidthProp);
    if (prop != iterEnd)
    {
        float strokeWidth{};
        // Ignore stroke-width if invalid or negative.
        if (SVGStringParser::ParseLengthOrPercentage(prop->second, RelativeLength(LengthType::kDiagonal), strokeWidth, true)
            && strokeWidth >= 0)
            strokeStyle.lineWidth = strokeWidth;
        // Disable stroke on a stroke-width of 0.
        if (strokeWidth == 0.0)
            strokeStyle.hasStroke = false;
    }

    prop = propertySet.find(kStrokeLinecapProp);
    if (prop != iterEnd)
    {
        if (prop->second == kRoundVal)
            strokeStyle.lineCap = LineCap::kRound;
        else if (prop->second == kSquareVal)
            strokeStyle.lineCap = LineCap::kSquare;
    }

    prop = propertySet.find(kStrokeLinejoinProp);
    if (prop != iterEnd)
    {
        if (prop->second == kRoundVal)
            strokeStyle.lineJoin = LineJoin::kRound;
        else if (prop->second == kBevelVal)
            strokeStyle.lineJoin = LineJoin::kBevel;
    }

    prop = propertySet.find(kStrokeMiterlimitProp);
    if (prop != iterEnd)
    {
        float miter{};
        // Miter must be bigger 1. Otherwise ignore.
        if (SVGStringParser::ParseNumber(prop->second, miter) && miter >= 1)
            strokeStyle.miterLimit = miter;
    }

    prop = propertySet.find(kStrokeDashoffsetProp);
    if (prop != iterEnd)
    {
        float strokeDashoffset{};
        if (SVGStringParser::ParseLengthOrPercentage(prop->second, RelativeLength(LengthType::kDiagonal), strokeDashoffset, true))
            strokeStyle.dashOffset = strokeDashoffset;
    }

    prop = propertySet.find(kStrokeDasharrayProp);
    if (prop != iterEnd)
    {
        float diagonal = sqrtf(mViewBox[2] * mViewBox[2] + mViewBox[3] * mViewBox[3]);
        if (!SVGStringParser::ParseListOfLengthOrPercentage(prop->second.c_str(), diagonal, strokeStyle.dashArray, true))
            strokeStyle.dashArray.clear();
        for (auto it = strokeStyle.dashArray.begin(); it < strokeStyle.dashArray.end(); ++it)
        {
            if (*it < 0)
            {
                strokeStyle.dashArray.clear();
                break;
            }
        }
        const auto sizeOfDashArray = strokeStyle.dashArray.size();
        if (sizeOfDashArray % 2 != 0)
        {
            // If stroke-dasharray[] is odd-sized, the array should be twiced.
            // See SVG 1.1 (2nd ed), 11.4 "Stroke Properties" for detail.
            strokeStyle.dashArray.reserve(sizeOfDashArray * 2);
            for (size_t i = 0; i < sizeOfDashArray; ++i)
                strokeStyle.dashArray.push_back(strokeStyle.dashArray[i]);
        }
    }

    prop = propertySet.find(kStrokeOpacityProp);
    if (prop != iterEnd)
    {
        float opacity{};
        if (SVGStringParser::ParseAlphaValue(prop->second, opacity))
            strokeStyle.strokeOpacity = std::max<float>(0.0, std::min<float>(1.0, opacity));
    }
}

void SVGDocumentImpl::ParseGraphicsProperties(GraphicStyleImpl& graphicStyle, const PropertySet& propertySet)
{
    auto prop = propertySet.find(kOpacityProp);
    auto iterEnd = propertySet.end();
    if (prop != iterEnd)
    {
        float opacity{};
        if (SVGStringParser::ParseAlphaValue(prop->second, opacity))
            graphicStyle.opacity = std::max<float>(0.0, std::min<float>(1.0, opacity));
    }

    prop = propertySet.find(kClipPathProp);
    if (prop != iterEnd)
    {
        // FIXME: Use proper parser.
        const auto urlLength = strlen(kUrlVal);
        const auto& valueString = prop->second;
        auto id = valueString.substr(urlLength, valueString.size() - urlLength - 1);
        auto clippingPathIt = mClippingPaths.find(id);
        if (clippingPathIt != mClippingPaths.end())
            graphicStyle.clippingPath = clippingPathIt->second;
    }

    prop = propertySet.find(kDisplayProp);
    if (prop != iterEnd)
    {
        if (prop->second.compare(kNoneVal))
            graphicStyle.display = false;
    }

    prop = propertySet.find(kStopOpacityProp);
    if (prop != iterEnd)
    {
        float opacity{};
        if (SVGStringParser::ParseAlphaValue(prop->second, opacity))
            graphicStyle.stopOpacity = std::max<float>(0.0, std::min<float>(1.0, opacity));
    }

    prop = propertySet.find(kStopColorProp);
    if (prop != iterEnd)
    {
        ColorImpl color = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
        const auto result = SVGStringParser::ParseColor(prop->second, color, true);
        if (result == SVGDocumentImpl::Result::kSuccess)
            graphicStyle.stopColor = color;
    }
}

float SVGDocumentImpl::ParseColorStop(const XMLNode* node, std::vector<ColorStopImpl>& colorStops, float lastOffset)
{
    SVG_ASSERT(node != nullptr);

    auto fillStyle = mFillStyleStack.top();
    auto strokeStyle = mStrokeStyleStack.top();
    std::set<std::string> classNames;
    auto graphicStyle = ParseGraphic(node, fillStyle, strokeStyle, classNames);

    // * New stops may never appear before previous stops. Use offset of previous stop otherwise.
    // * Stops must be in the range [0.0, 1.0].
    float offset{};
    auto attr = node->GetAttribute(kOffsetAttr);
    offset = (attr.found && SVGStringParser::ParseAlphaValue(attr.value, offset)) ? offset : lastOffset;
    offset = std::max<float>(lastOffset, offset);
    offset = std::min<float>(1.0, std::max<float>(0.0, offset));

    ColorImpl& paint = graphicStyle.stopColor;
    if (SVGNative::holds_alternative<ColorKeys>(paint))
    {
        // Value is "currentColor". Simply set value to CSS color property.
        paint = fillStyle.color;
    }

    graphicStyle.stopOpacity = std::max<float>(0.0, std::min<float>(1.0, graphicStyle.stopOpacity));

    colorStops.push_back(std::make_tuple(offset, paint, graphicStyle.stopOpacity));
    return offset;
}

void SVGDocumentImpl::ParseColorStops(XMLNode* node, GradientImpl& gradient)
{
    SVG_ASSERT(node != nullptr);

    float lastOffset{};
    std::vector<ColorStopImpl> colorStops;
    for (auto child = node->GetFirstNode(); child != nullptr; child = child->GetNextSibling())
    {
        if (!strcmp(child->GetName(), kStopElem))
            lastOffset = ParseColorStop(child.get(), colorStops, lastOffset);
    }
    // Make sure we always have stops in the range 0% and 100%.
    if (colorStops.size() > 1)
    {
        const auto& firstStop = colorStops.front();
        if (std::get<0>(firstStop) != 0.0f)
            colorStops.insert(colorStops.begin(), std::make_tuple(0.0f, std::get<1>(firstStop), std::get<2>(firstStop)));
        const auto& lastStop = colorStops.back();
        if (std::get<0>(lastStop) != 1.0f)
            colorStops.push_back(std::make_tuple(1.0f, std::get<1>(lastStop), std::get<2>(lastStop)));
    }
    // Keep the color stops from referenced gradients if the current gradient
    // has none.
    if (!colorStops.empty())
        gradient.internalColorStops = colorStops;
}

void SVGDocumentImpl::ParseGradient(XMLNode* node)
{
    SVG_ASSERT(node != nullptr);

    GradientImpl gradient{};

    // SVG allows referencing other gradients. For now, we only look at already parsed
    // gradients. Since we add the current gradient after successful parsing,
    // this also avoids circular references.
    // https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementHrefAttribute
    auto attr = node->GetAttribute(kHrefAttr, kXlinkNS);
    if (attr.found)
    {
        std::string href{attr.value};
        // href starts with a #, ignore it.
        auto it = mGradients.find(href.substr(1));
        if (it != mGradients.end())
            gradient = it->second;
    }

    ParseColorStops(node, gradient);

    const auto elementName = node->GetName();
    if (!strcmp(elementName, kLinearGradientElem))
        gradient.type = GradientType::kLinearGradient;
    else if (!strcmp(elementName, kRadialGradientElem))
        gradient.type = GradientType::kRadialGradient;
    else
    {
        SVG_ASSERT_MSG(false, "Gradient parser called with invalid element");
        return;
    }

    // TODO: Do we want to support `gradientUnits="objectBoundingBox"` at all?
    // This would require us to get the bounding box of the filled/stroked shape
    // when the gradient gets applied.

    if (gradient.type == GradientType::kLinearGradient)
    {
        // https://www.w3.org/TR/SVG11/pservers.html#LinearGradients
        gradient.x1 = ParseLengthFromAttr(node, kX1Attr, LengthType::kHorizontal, gradient.x1);
        gradient.y1 = ParseLengthFromAttr(node, kY1Attr, LengthType::kVertical, gradient.y1);
        gradient.x2 = ParseLengthFromAttr(node, kX2Attr, LengthType::kHorizontal, gradient.x2);
        gradient.y2 = ParseLengthFromAttr(node, kY2Attr, LengthType::kVertical, gradient.y2);
    }
    else
    {
        // https://www.w3.org/TR/SVG11/pservers.html#RadialGradients
        gradient.cx = ParseLengthFromAttr(node, kCxAttr, LengthType::kHorizontal, gradient.cx);
        gradient.cy = ParseLengthFromAttr(node, kCyAttr, LengthType::kVertical, gradient.cy);
        gradient.fx = ParseLengthFromAttr(node, kFxAttr, LengthType::kHorizontal, gradient.fx);
        gradient.fy = ParseLengthFromAttr(node, kFyAttr, LengthType::kVertical, gradient.fy);
        gradient.r = ParseLengthFromAttr(node, kRAttr, LengthType::kDiagonal, gradient.r);
    }

    attr = node->GetAttribute(kSpreadMethodAttr);
    if (attr.found)
    {
        const auto spreadMethodString = attr.value;
        if (!strcmp(spreadMethodString, kPadVal))
            gradient.method = SpreadMethod::kPad;
        else if (!strcmp(spreadMethodString, kReflectVal))
            gradient.method = SpreadMethod::kReflect;
        else if (!strcmp(spreadMethodString, kRepeatVal))
            gradient.method = SpreadMethod::kRepeat;
    }
    attr = node->GetAttribute(kGradientTransformAttr);
    if (attr.found)
    {
        SVG_ASSERT(mRenderer != nullptr);
        gradient.transform = mRenderer->CreateTransform();
        if (!SVGStringParser::ParseTransform(attr.value, *gradient.transform))
            gradient.transform.reset();
    }

    attr = node->GetAttribute(kIdAttr);
    if (attr.found)
        mGradients.insert({attr.value, gradient});
}

void SVGDocumentImpl::Render(const ColorMap& colorMap, float width, float height)
{
    SVG_ASSERT(mGroup);
    if (!mGroup)
        return;

    RenderElement(*mGroup, colorMap, width, height);
}

void SVGDocumentImpl::Render(const char* id, const ColorMap& colorMap, float width, float height)
{
    // Referenced glyph identifiers shall be rendered as if they were contained in a <defs> section under
    // the root SVG element:
    // Therefore, the referenced shape/group should:
    // * inherit property values from the root SVG element,
    // * ignore all styling and transforms on ancestors.
    // https://docs.microsoft.com/en-us/typography/opentype/spec/svg#glyph-identifiers
    auto elementIter = mIdToElementMap.find(id);
    if (elementIter != mIdToElementMap.end())
        RenderElement(*elementIter->second, colorMap, width, height);
}

void SVGDocumentImpl::RenderElement(const Element& element, const ColorMap& colorMap, float width, float height)
{
    float scale = width / mViewBox[2];
    if (scale > height / mViewBox[3])
        scale = height / mViewBox[3];

    GraphicStyleImpl graphicStyle{};
    graphicStyle.transform = mRenderer->CreateTransform();
    graphicStyle.transform->Translate(-1 * mViewBox[0], -1 * mViewBox[1]);
    graphicStyle.transform->Scale(scale, scale);

    auto saveRestore = SaveRestoreHelper{mRenderer, graphicStyle};

    TraverseTree(colorMap, element);
    SVG_ASSERT(mVisitedElements.empty());
}

bool SVGDocumentImpl::GetBoundingBox(Rect& bound)
{
    SVG_ASSERT(mGroup);
    if (!mGroup)
        return false;

    GraphicStyleImpl graphicStyle{};
    graphicStyle.transform = mRenderer->CreateTransform();
    graphicStyle.transform->Translate(-1 * mViewBox[0], -1 * mViewBox[1]);
    auto saveRestore = SaveRestoreHelper{mRenderer, graphicStyle};
    ExtractBounds(*mGroup);
    SVG_ASSERT(mVisitedElements.empty());

    Rect sumBound{0, 0, 0, 0};
#ifdef DEBUG_API
    for(auto const& bound : mBounds)
        sumBound = sumBound | bound;
#else
    sumBound = mBound;
#endif
    bound = sumBound;
    return true;
}

bool SVGDocumentImpl::GetBoundingBox(const char* id, Rect& bound)
{
    SVG_ASSERT(mGroup);
    if (!mGroup)
        return false;

    // TODO: Maybe this needs fixing as I'm not doing any scaling, we must
    // figure out a way to supply width/height for this I guess?
    GraphicStyleImpl graphicStyle{};
    graphicStyle.transform = mRenderer->CreateTransform();
    graphicStyle.transform->Translate(-1 * mViewBox[0], -1 * mViewBox[1]);
    auto saveRestore = SaveRestoreHelper{mRenderer, graphicStyle};
    const auto elementIter = mIdToElementMap.find(id);
    SVG_ASSERT(elementIter != mIdToElementMap.end());
    ExtractBounds(*elementIter->second);
    SVG_ASSERT(mVisitedElements.empty());

    Rect sumBound{0, 0, 0, 0};
#ifdef DEBUG_API
    for(auto const& bound : mBounds)
        sumBound = sumBound | bound;
#else
    sumBound = mBound;
#endif
    bound = sumBound;
    return true;
}

#ifdef DEBUG_API
bool GetSubBoundingBoxes(std::vector<Rect>& bounds);
{
    SVG_ASSERT(mGroup);
    if (!mGroup)
        return false;
    GraphicStyleImpl graphicStyle{};
    graphicStyle.transform = mRenderer->CreateTransform();
    graphicStyle.transform->Translate(-1 * mViewBox[0], -1 * mViewBox[1]);
    auto saveRestore = SaveRestoreHelper{mRenderer, graphicStyle};
    ExtractBounds(*mGroup);
    SVG_ASSERT(mVisitedElements.empty());
    bounds = mBounds;
    return true;
}

bool GetSubBoundingBoxes(const char* id, std::vector<Rect>& bounds);
{
    SVG_ASSERT(mGroup);
    if (!mGroup)
        return false;
    GraphicStyleImpl graphicStyle{};
    graphicStyle.transform = mRenderer->CreateTransform();
    graphicStyle.transform->Translate(-1 * mViewBox[0], -1 * mViewBox[1]);
    auto saveRestore = SaveRestoreHelper{mRenderer, graphicStyle};
    const auto elementIter = mIdToElementMap.find(id);
    SVG_ASSERT(elementIter != mIdToElementMap.end());
    ExtractBounds(*elementIter->second);
    SVG_ASSERT(mVisitedElements.empty());
    bounds = mBounds;
    return true;
}
#endif

void SVGDocumentImpl::ExtractBounds(const Element& element)
{
    // This function is based on the TraverseTree function, we just calculate
    // the bounds instead of doing any drawing.

    auto graphicStyle = element.graphicStyle;
    FillStyleImpl fillStyle{};
    StrokeStyleImpl strokeStyle{};
    // Has no bound contribution if there is no clipContent and clip path is set
    if (graphicStyle.clippingPath && !graphicStyle.clippingPath->hasClipContent)
        return;

    switch (element.Type())
    {
        case ElementType::kReference:
            {
                const auto& reference = static_cast<const Reference&>(element);
                const auto it = mVisitedElements.find(&reference);
                if (it != mVisitedElements.end())
                    break; // We found a cycle. Do not continue rendering.
                auto insertResult = mVisitedElements.insert(&reference);

                // Render referenced content.
                auto refIt = mIdToElementMap.find(reference.href);
                if (refIt != mIdToElementMap.end())
                {
                    ApplyCSSStyle(reference.classNames, graphicStyle, fillStyle, strokeStyle);
                    auto saveRestore = SaveRestoreHelper{mRenderer, reference.graphicStyle};
                    ExtractBounds(*(refIt->second));
                }

                // Done processing current element.
                mVisitedElements.erase(insertResult.first);
                break;
            }
        case ElementType::kGraphic:
            {
                const auto& graphic = static_cast<const Graphic&>(element);
                // TODO: Since we keep the original fill, stroke and color property values
                // we should be able to do w/o a copy.
                fillStyle = graphic.fillStyle;
                strokeStyle = graphic.strokeStyle;
                ApplyCSSStyle(graphic.classNames, graphicStyle, fillStyle, strokeStyle);
                Rect bounds = mRenderer->GetBounds(*(graphic.path.get()), graphicStyle, fillStyle, strokeStyle);
                if (!bounds.IsEmpty())
                {
#ifdef DEBUG_API
                    mBounds.push_back(bounds);
#else
                    mBound = mBound | bounds;
#endif
                }
                break;
            }
        case ElementType::kImage:
            {
                const auto& image = static_cast<const Image&>(element);
                ApplyCSSStyle(image.classNames, graphicStyle, fillStyle, strokeStyle);
                // TODO: How to handle image's bounds?
                auto path = mRenderer->CreatePath();
                path->Rect(image.fillArea.x, image.fillArea.y, image.fillArea.width, image.fillArea.height);
                Rect bounds = mRenderer->GetBounds(*path.get(), GraphicStyle{}, FillStyle{}, StrokeStyle{});
                if (!bounds.IsEmpty())
                {
#ifdef DEBUG_API
                    mBounds.push_back(bounds);
#else
                    mBound = mBound | bounds;
#endif
                }
                break;
            }
        case ElementType::kGroup:
            {
                const auto& group = static_cast<const Group&>(element);
                ApplyCSSStyle(group.classNames, graphicStyle, fillStyle, strokeStyle);
                auto saveRestore = SaveRestoreHelper{mRenderer, group.graphicStyle};
                for (const auto& child : group.children)
                    ExtractBounds(*child);
                break;
            }
        default:
            SVG_ASSERT_MSG(false, "Unknown element type");
    }
}

void SVGDocumentImpl::AddChildToCurrentGroup(std::shared_ptr<Element> element, std::string idString)
{
    SVG_ASSERT(!mGroupStack.empty());
    if (mGroupStack.empty())
        return;

    mGroupStack.top()->children.push_back(element);

    if (!idString.empty() && mIdToElementMap.find(idString) == mIdToElementMap.end())
        mIdToElementMap.emplace(std::move(idString), element);
}

static void ResolveColorImpl(const ColorMap& colorMap, const ColorImpl& colorImpl, Color& color)
{
    if (SVGNative::holds_alternative<Variable>(colorImpl))
    {
        const auto& var = SVGNative::get<Variable>(colorImpl);
        const auto colorIt = colorMap.find(var.first);
        color = colorIt != colorMap.end() ? colorIt->second : var.second;
    }
    else if (SVGNative::holds_alternative<Color>(colorImpl))
        color = SVGNative::get<Color>(colorImpl);
    else
        // Can only be reached if fallback color value of var() is currentColor.
        color = Color{{0.0f, 0.0f, 0.0f, 1.0f}};
}

static void ResolvePaintImpl(const ColorMap& colorMap, const PaintImpl& internalPaint, const Color& currentColor, Paint& paint)
{
    if (SVGNative::holds_alternative<Variable>(internalPaint))
    {
        const auto& var = SVGNative::get<Variable>(internalPaint);
        const auto colorIt = colorMap.find(var.first);
        paint = colorIt != colorMap.end() ? colorIt->second : var.second;
    }
    else if (SVGNative::holds_alternative<GradientImpl>(internalPaint))
    {
        // Stop colors may have variables as well.
        const auto& internalGradient = SVGNative::get<GradientImpl>(internalPaint);
        paint = std::move(internalGradient);
        auto& gradient = SVGNative::get<Gradient>(paint);
        for (const auto& colorStop : internalGradient.internalColorStops)
        {
            Color stopColor{{0, 0, 0, 1.0}};
            const auto& colorImpl = std::get<1>(colorStop);
            if (SVGNative::holds_alternative<Variable>(colorImpl))
            {
                const auto& var = SVGNative::get<Variable>(colorImpl);
                const auto colorIt = colorMap.find(var.first);
                stopColor = colorIt != colorMap.end() ? colorIt->second : var.second;
            }
            else if (SVGNative::holds_alternative<Color>(colorImpl))
                stopColor = SVGNative::get<Color>(colorImpl);
            else
            {
                SVG_ASSERT_MSG(false, "Unhandled ColorImpl type");
            }
            stopColor[3] *= std::get<2>(colorStop);
            gradient.colorStops.push_back({std::get<0>(colorStop), stopColor});
        }
    }
    else if (SVGNative::holds_alternative<Color>(internalPaint))
        paint = SVGNative::get<Color>(internalPaint);
    else if (SVGNative::holds_alternative<ColorKeys>(internalPaint))
        // currentColor is the only possible enum value for now.
        paint = currentColor;
    else
        SVG_ASSERT_MSG(false, "Unhandled PaintImpl type");
}

void SVGDocumentImpl::TraverseTree(const ColorMap& colorMap, const Element& element)
{
    // Inheritance doesn't work for override styles. Since override styles
    // are deprecated, we are not going to fix this nor is this expected by
    // (still existing) clients.
    auto graphicStyle = element.graphicStyle;
    FillStyleImpl fillStyle{};
    StrokeStyleImpl strokeStyle{};
    // Do not draw element if an applied clipPath has no content.
    if (graphicStyle.clippingPath && !graphicStyle.clippingPath->hasClipContent)
        return;
    switch (element.Type())
    {
    case ElementType::kReference:
    {
        const auto& reference = static_cast<const Reference&>(element);
        const auto it = mVisitedElements.find(&reference);
        if (it != mVisitedElements.end())
            break; // We found a cycle. Do not continue rendering.
        auto insertResult = mVisitedElements.insert(&reference);

        // Render referenced content.
        auto refIt = mIdToElementMap.find(reference.href);
        if (refIt != mIdToElementMap.end())
        {
            ApplyCSSStyle(reference.classNames, graphicStyle, fillStyle, strokeStyle);
            auto saveRestore = SaveRestoreHelper{mRenderer, reference.graphicStyle};
            TraverseTree(colorMap, *(refIt->second));
        }

        // Done processing current element.
        mVisitedElements.erase(insertResult.first);
        break;
    }
    case ElementType::kGraphic:
    {
        const auto& graphic = static_cast<const Graphic&>(element);
        // TODO: Since we keep the original fill, stroke and color property values
        // we should be able to do w/o a copy.
        fillStyle = graphic.fillStyle;
        strokeStyle = graphic.strokeStyle;
        ApplyCSSStyle(graphic.classNames, graphicStyle, fillStyle, strokeStyle);
        // If we have a CSS var() function we need to replace the placeholder with
        // an actual color from our externally provided color map here.
        Color color{{0.0f, 0.0f, 0.0f, 1.0f}};
        ResolveColorImpl(colorMap, fillStyle.color, color);
        ResolvePaintImpl(colorMap, fillStyle.internalPaint, color, fillStyle.paint);
        ResolvePaintImpl(colorMap, strokeStyle.internalPaint, color, strokeStyle.paint);
        mRenderer->DrawPath(*(graphic.path.get()), graphicStyle, fillStyle, strokeStyle);
        break;
    }
    case ElementType::kImage:
    {
        const auto& image = static_cast<const Image&>(element);
        ApplyCSSStyle(image.classNames, graphicStyle, fillStyle, strokeStyle);
        mRenderer->DrawImage(*(image.imageData.get()), graphicStyle, image.clipArea, image.fillArea);
        break;
    }
    case ElementType::kGroup:
    {
        const auto& group = static_cast<const Group&>(element);
        ApplyCSSStyle(group.classNames, graphicStyle, fillStyle, strokeStyle);
        auto saveRestore = SaveRestoreHelper{mRenderer, group.graphicStyle};
        for (const auto& child : group.children)
            TraverseTree(colorMap, *child);
        break;
    }
    default:
        SVG_ASSERT_MSG(false, "Unknown element type");
    }
}

#ifndef STYLE_SUPPORT
// Deprecated style support
void SVGDocumentImpl::ApplyCSSStyle(
    const std::set<std::string>&, GraphicStyleImpl&, FillStyleImpl&, StrokeStyleImpl&) {}
void SVGDocumentImpl::ParseStyleAttr(const XMLNode*, std::vector<PropertySet>&, std::set<std::string>&) {}
void SVGDocumentImpl::ParseStyle(const XMLNode*) {}
#endif

} // namespace SVGNative
</file>

</files>
