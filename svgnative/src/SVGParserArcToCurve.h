```cpp
#ifndef SVGDOCUMENT_H
#define SVGDOCUMENT_H
#include "svgnative/SVGDocument.h"
#include "svgnative/SVGRenderer.h"
#define _USE_MATH_DEFINES
#include<cmath>
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif
namespace SVGNative{void RotatePoint(float&x,float&y,float angle);void RotatePoint(float&){SVG_ASSERT(false);}void AddArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,float endX,float endY,float startAngle,float endAngle,float&endControlX,float&endControlY);void AddArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float,float endX,float endY,float startAngle,float endAngle,float&endControlX,float&endControlY){float t=tan((endAngle-startAngle)/4);float hx=radiusX*t*4/3;float hy=radiusY*t*4/3;float startCPX=startX+hx*sin(startAngle);float startCPY=startY-hy*cos(startAngle);startCPX=2*startX-startCPX;startCPY=2*startY-startCPY;float endCPX=endX+hx*sin(endAngle);float endCPY=endY-hy*cos(endAngle);path.CurveTo(startCPX,startCPY,endCPX,endCPY,endX,endY);endControlX=endCPX;endControlY=endCPY;SVG_PARSE_TRACE("AddArcToCurve startAngle="<<(startAngle*180/M_PI)<<" endAngle="<<(endAngle*180/M_PI));SVG_PARSE_TRACE("AddArcToCurve startCP=("<<startCPX<<","<<startCPY<<")endCP=("<<endCPX<<","<<endCPY<<")EndPoint=("<<endX<<","<<endY<<")");}void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool sweep,float endX,float endY,float startAngle,float endAngle,float centerX,float centerY,float&endControlX,float&endControlY);void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool sweep,float endX,float endY,float startAngle,float endAngle,float centerX,float centerY,float&endControlX,float&endControlY){float angleDiff=endAngle-startAngle;if(std::abs(angleDiff)>M_PI*120.0f/180.0f){float endAngleNext=endAngle;float endXNext=endX;float endYNext=endY;endAngle=startAngle+(M_PI*120.0f/180.0f)*((sweep&&(endAngle>startAngle))?1:-1);endX=centerX+radiusX*cos(endAngle);endY=centerY+radiusY*sin(endAngle);AddArcToCurve(path,startX,startY,radiusX,radiusY,angle,endX,endY,startAngle,endAngle,endControlX,endControlY);ArcToCurve(path,endX,endY,radiusX,radiusY,angle,sweep,endXNext,endYNext,endAngle,endAngleNext,centerX,centerY,endControlX,endControlY);}else{AddArcToCurve(path,startX,startY,radiusX,radiusY,angle,endX,endY,startAngle,endAngle,endControlX,endControlY);}}void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool large,bool sweep,float endX,float endY,float&endControlX,float&endControlY);void ArcToCurve(SVGNative::Path&path,float startX,float startY,float radiusX,float radiusY,float angle,bool large,bool sweep,float endX,float endY,float&endControlX,float&endControlY){SVG_ASSERT(angle==0);if(radiusX==0||radiusY==0){path.LineTo(endX,endY);return;}SVG_ASSERT(radiusX==radiusY);SVG_ASSERT(radiusX!=0&&radiusY!=0);SVG_PARSE_TRACE("ArcToCurve----------------------------------------------");SVG_PARSE_TRACE("parsePathString ArcToCurve:rx="<<radiusX<<" ry="<<radiusY<<" large="<<large<<" sweep="<<sweep<<" previous=("<<startX<<","<<startY<<")"<<" next=("<<endX<<","<<endY<<")");angle=M_PI/180*angle;if(radiusX!=radiusY)SVG_PARSE_TRACE("parsePathString ELLIPTICAL:"<<angle);float hx=(startX-endX)/2;float hy=(startY-endY)/2;float validateRadii=(hx*hx)/(radiusX*radiusX)+(hy*hy)/(radiusY*radiusY);if(validateRadii>1){radiusX=radiusX*sqrt(validateRadii);radiusY=radiusY*sqrt(validateRadii);}SVG_PARSE_TRACE("ArcToCurve final radii:rx="<<radiusX<<" ry="<<radiusY);float radiusX2(radiusX*radiusX);float radiusY2(radiusY*radiusY);float HX2(hx*hx);float HY2(hy*hy);float k=(radiusX2*radiusY2-radiusX2*HY2-radiusY2*HX2)/(radiusX2*HY2+radiusY2*HX2);k=sqrt(std::abs(k))*(large==sweep?-1:1);float centerX=k*(radiusX*hy/radiusY);float centerY=k*(-radiusY*hx/radiusX);centerX+=(startX+endX)/2;centerY+=(startY+endY)/2;SVG_PARSE_TRACE("parsePathString ArcToCurve:center("<<centerX<<","<<centerY<<")");SVG_PARSE_TRACE("parsePathString ArcToCurve:radius("<<sqrt((centerX-startX)*(centerX-startX)+(centerY-startY)*(centerY-startY))<<","<<sqrt((centerX-endX)*(centerX-endX)+(centerY-endY)*(centerY-endY))<<")");float aS=(startY-centerY)/radiusY;float aE=(endY-centerY)/radiusY;aS=std::min(aS,1.0f);aS=std::max(aS,-1.0f);aE=std::min(aE,1.0f);aE=std::max(aE,-1.0f);SVG_ASSERT_MSG(aS>=-1&&aS<=1,"aS:"<<aS);SVG_ASSERT_MSG(aE>=-1&&aE<=1,"aE:"<<aE);float startAngle=asin(aS);float endAngle=asin(aE);if(startX<centerX)startAngle