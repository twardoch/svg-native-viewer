
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<memory.h>
#include<sys/stat.h>
#include<assert.h>
#include<string.h>
#if defined(__MINGW32__)||defined(__DMC__)||defined(_MSC_VER)||defined(__POCC__)
# ifndef WIN32
# define WIN32
# endif
#else 
# include<unistd.h>
#endif
#ifdef DEBUG
static int debugMask=0;
# define debug0(F,M)if((F)&debugMask){fprintf(stderr,M);}
# define debug1(F,M,A)if((F)&debugMask){fprintf(stderr,M,A);}
# define debug2(F,M,A,B)if((F)&debugMask){fprintf(stderr,M,A,B);}
# define debug3(F,M,A,B,C)if((F)&debugMask){fprintf(stderr,M,A,B,C);}
# define PARSER 0x00000001
# define DECL_DUMP 0x00000002
# define TOKENIZER 0x00000004
#else 
# define debug0(Flags,Format)
# define debug1(Flags,Format,A)
# define debug2(Flags,Format,A,B)
# define debug3(Flags,Format,A,B,C)
#endif
#define INTERFACE 1
#define EXPORT_INTERFACE 1
#define EXPORT
typedef struct Token Token;struct Token{const char*zText;int nText;int eType;int nLine;Token*pComment;Token*pNext;Token*pPrev;};typedef struct InStream InStream;struct InStream{const char*z;int i;int nLine;};typedef struct Decl Decl;struct Decl{char*zName;const char*zFile;char*zIf;char*zFwd;char*zFwdCpp;char*zDecl;char*zExtra;int extraType;struct Include*pInclude;int flags;Token*pComment;Token tokenCode;Decl*pSameName;Decl*pSameHash;Decl*pNext;};
#define DP_Forward 0x001
#define DP_Declared 0x002
#define DP_Export 0x004
#define DP_Local 0x008
#define DP_Flag 0x010
#define DP_Cplusplus 0x020
#define DP_ExternCReqd 0x040
#define DP_ExternReqd 0x080
#define DeclHasProperty(D,P)(((D)->flags&(P))==(P))
#define DeclHasAnyProperty(D,P)(((D)->flags&(P))!=0)
#define DeclSetProperty(D,P)(D)->flags|=(P)
#define DeclClearProperty(D,P)(D)->flags&=~(P)
#define PS_Extern 0x000800
#define PS_Export 0x001000
#define PS_Export2 0x002000
#define PS_Typedef 0x004000
#define PS_Static 0x008000
#define PS_Interface 0x010000
#define PS_Method 0x020000
#define PS_Local 0x040000
#define PS_Local2 0x080000
#define PS_Public 0x100000
#define PS_Protected 0x200000
#define PS_Private 0x400000
#define PS_PPP 0x700000
#define TY_Class 0x00100000
#define TY_Subroutine 0x00200000
#define TY_Macro 0x00400000
#define TY_Typedef 0x00800000
#define TY_Variable 0x01000000
#define TY_Structure 0x02000000
#define TY_Union 0x04000000
#define TY_Enumeration 0x08000000
#define TY_Defunct 0x10000000
typedef struct Ifmacro Ifmacro;struct Ifmacro{int nLine;char*zCondition;Ifmacro*pNext;int flags;};typedef struct Include Include;struct Include{char*zFile;char*zIf;char*zLabel;Include*pNext;};typedef struct Ident Ident;struct Ident{char*zName;Ident*pCollide;Ident*pNext;};
#define IDENT_HASH_SIZE 2237
typedef struct IdentTable IdentTable;struct IdentTable{Ident*pList;Ident*apTable[IDENT_HASH_SIZE];};typedef struct InFile InFile;struct InFile{char*zSrc;char*zHdr;int flags;InFile*pNext;IdentTable idTable;};typedef struct String String;struct String{int nAlloc;int nUsed;char*zText;};typedef struct GenState GenState;struct GenState{String*pStr;IdentTable*pTable;const char*zIf;int nErr;const char*zFilename;int flags;};const char zTopLine[]="\n""#undef INTERFACE\n";
#define nTopLine(sizeof(zTopLine)-1)
static const char*zFilename;static Ifmacro*ifStack=0;static Include*includeList=0;static Token*blockComment=0;static int doc_flag=0;static int proto_static=0;static Decl*pDeclFirst;static Decl*pDeclLast;
#define DECL_HASH_SIZE 3371
static Decl*apTable[DECL_HASH_SIZE];
#ifndef TEST
# define TEST 0
#endif
#ifdef NOT_USED
#define Assert(X)if(!(X)){CantHappen(__LINE__);}
#define CANT_HAPPEN CantHappen(__LINE__)
static void CantHappen(int iLine){fprintf(stderr,"Assertion failed on line%d\n",iLine);*(char*)1=0;}
#endif
static void*SafeMalloc(int nByte){void*p=malloc(nByte);if(p==0){fprintf(stderr,"Out of memory. Can't allocate%d bytes.\n",nByte);exit(1);}return p;}static void SafeFree(void*pOld){if(pOld){free(pOld);}}static void*SafeRealloc(void*pOld,int nByte){void*p;if(pOld==0){p=SafeMalloc(nByte);}else{p=realloc(pOld,nByte);if(p==0){fprintf(stderr,"Out of memory. Can't enlarge an allocation to%d bytes\n",nByte);exit(1);}}return p;}static char*StrDup(const char*zSrc,int nByte){char*zDest;if(nByte<=0){nByte=strlen(zSrc);}zDest=SafeMalloc(nByte+1);strncpy(zDest,zSrc,nByte);zDest[nByte]=0;return zDest;}
#define ISALNUM(X)((X)=='_'||isalnum(X))
static void StringInit(String*pStr){pStr->nAlloc=0;pStr->nUsed=0;pStr->zText=0;}static void StringReset(String*pStr){SafeFree(pStr->zText);StringInit(pStr);}static void StringAppend(String*pStr,const char*zText,int nByte){if(nByte<=0){nByte=strlen(zText);}if(pStr->nUsed+nByte>=pStr->nAlloc){if(pStr->nAlloc==0){pStr->nAlloc=nByte+100;pStr->zText=SafeMalloc(pStr->nAlloc);}else{pStr->nAlloc=pStr->nAlloc*2+nByte;pStr->zText=SafeRealloc(pStr->zText,pStr->nAlloc);}}strncpy(&pStr->zText[pStr->nUsed],zText,nByte);pStr->nUsed+=nByte;pStr->zText[pStr->nUsed]=0;}
#define StringGet(S)((S)->zText?(S)->zText:"")
static int Hash(const char*z,int n){int h=0;if(n<=0){n=strlen(z);}while(n--){h=h^(h<<5)^*z++;}return h&0x7fffffff;}static Decl*FindDecl(const char*zName,int len){int h;Decl*p;if(len<=0){len=strlen(zName);}h=Hash(zName,len)%DECL_HASH_SIZE;p=apTable[h];while(p&&(strncmp(p->zName,zName,len)!=0||p->zName[len]!=0)){p=p->pSameHash;}return p;}static void InstallDecl(Decl*pDecl){int h;Decl*pOther;h=Hash(pDecl->zName,0)%DECL_HASH_SIZE;pOther=apTable[h];while(pOther&&strcmp(pDecl->zName,pOther->zName)!=0){pOther=pOther->pSameHash;}if(pOther){pDecl->pSameName=pOther->pSameName;pOther->pSameName=pDecl;}else{pDecl->pSameName=0;pDecl->pSameHash=apTable[h];apTable[h]=pDecl;}pDecl->pNext=0;if(pDeclFirst==0){pDeclFirst=pDeclLast=pDecl;}else{pDeclLast->pNext=pDecl;pDeclLast=pDecl;}}static char*GetIfString(void){Ifmacro*pIf;char*zResult=0;int hasIf=0;String str;for(pIf=ifStack;pIf;pIf=pIf->pNext){if(pIf->zCondition==0||*pIf->zCondition==0)continue;if(!hasIf){hasIf=1;StringInit(&str);}else{StringAppend(&str,"&&",4);}StringAppend(&str,pIf->zCondition,0);}if(hasIf){zResult=StrDup(StringGet(&str),0);StringReset(&str);}else{zResult=0;}return zResult;}static Decl*CreateDecl(const char*zName,int nName){Decl*pDecl;pDecl=SafeMalloc(sizeof(Decl)+nName+1);memset(pDecl,0,sizeof(Decl));pDecl->zName=(char*)&pDecl[1];sprintf(pDecl->zName,"%.*s",nName,zName);pDecl->zFile=zFilename;pDecl->pInclude=includeList;pDecl->zIf=GetIfString();InstallDecl(pDecl);return pDecl;}static int IdentTableInsert(IdentTable*pTable,const char*zId,int nId){int h;Ident*pId;if(nId<=0){nId=strlen(zId);}h=Hash(zId,nId)%IDENT_HASH_SIZE;for(pId=pTable->apTable[h];pId;pId=pId->pCollide){if(strncmp(zId,pId->zName,nId)==0&&pId->zName[nId]==0){return 0;}}pId=SafeMalloc(sizeof(Ident)+nId+1);pId->zName=(char*)&pId[1];sprintf(pId->zName,"%.*s",nId,zId);pId->pNext=pTable->pList;pTable->pList=pId;pId->pCollide=pTable->apTable[h];pTable->apTable[h]=pId;return 1;}static int IdentTableTest(IdentTable*pTable,const char*zId,int nId){int h;Ident*pId;if(nId<=0){nId=strlen(zId);}h=Hash(zId,nId)%IDENT_HASH_SIZE;for(pId=pTable->apTable[h];pId;pId=pId->pCollide){if(strncmp(zId,pId->zName,nId)==0&&pId->zName[nId]==0){return 1;}}return 0;}static void IdentTableReset(IdentTable*pTable){Ident*pId,*pNext;for(pId=pTable->pList;pId;pId=pNext){pNext=pId->pNext;SafeFree(pId);}memset(pTable,0,sizeof(IdentTable));}
#ifdef DEBUG
static void IdentTablePrint(IdentTable*pTable,FILE*pOut){Ident*pId;for(pId=pTable->pList;pId;pId=pId->pNext){fprintf(pOut,"%s\n",pId->zName);}}
#endif
static char*ReadFile(const char*zFilename){struct stat sStat;FILE*pIn;char*zBuf;int n;if(stat(zFilename,&sStat)!=0
#ifndef WIN32
||!S_ISREG(sStat.st_mode)
#endif
){return 0;}pIn=fopen(zFilename,"r");if(pIn==0){return 0;}zBuf=SafeMalloc(sStat.st_size+1);n=fread(zBuf,1,sStat.st_size,pIn);zBuf[n]=0;fclose(pIn);return zBuf;}static int WriteFile(const char*zFilename,const char*zOutput){FILE*pOut;pOut=fopen(zFilename,"w");if(pOut==0){return 1;}fwrite(zOutput,1,strlen(zOutput),pOut);fclose(pOut);return 0;}
#define TT_Space 1
#define TT_Id 2
#define TT_Preprocessor 3
#define TT_Comment 4
#define TT_Number 5
#define TT_String 6
#define TT_Braces 7
#define TT_EOF 8
#define TT_Error 9
#define TT_BlockComment 10
#define TT_Other 0
static int GetToken(InStream*pIn,Token*pToken){int i;const char*z;int cStart;int c;int startLine;int nlisc=0;int nErr=0;z=pIn->z;i=pIn->i;pToken->nLine=pIn->nLine;pToken->zText=&z[i];switch(z[i]){case 0:pToken->eType=TT_EOF;pToken->nText=0;break;case '#':if(i==0||z[i-1]=='\n'||(i>1&&z[i-1]=='\r'&&z[i-2]=='\n')){pToken->eType=TT_Preprocessor;i++;while(z[i]!=0&&z[i]!='\n'){if(z[i]=='\\'){i++;if(z[i]=='\n')pIn->nLine++;}i++;}pToken->nText=i-pIn->i;}else{pToken->eType=TT_Other;pToken->nText=1;}break;case ' ':case '\t':case '\r':case '\f':case '\n':while(isspace(z[i])){if(z[i]=='\n')pIn->nLine++;i++;}pToken->eType=TT_Space;pToken->nText=i-pIn->i;break;case '\\':pToken->nText=2;pToken->eType=TT_Other;if(z[i+1]=='\n'){pIn->nLine++;pToken->eType=TT_Space;}else if(z[i+1]==0){pToken->nText=1;}break;case '\'':case '\"':cStart=z[i];startLine=pIn->nLine;do{i++;c=z[i];if(c=='\n'){if(!nlisc){fprintf(stderr,"%s:%d:(warning)Newline in string or character literal.\n",zFilename,pIn->nLine);nlisc=1;}pIn->nLine++;}if(c=='\\'){i++;c=z[i];if(c=='\n'){pIn->nLine++;}}else if(c==cStart){i++;c=0;}else if(c==0){fprintf(stderr,"%s:%d:Unterminated string or character literal.\n",zFilename,startLine);nErr++;}}while(c);pToken->eType=TT_String;pToken->nText=i-pIn->i;break;case '/':if(z[i+1]=='/'){while(z[i]&&z[i]!='\n'){i++;}pToken->eType=TT_Comment;pToken->nText=i-pIn->i;}else if(z[i+1]=='*'){int isBlockComment=i==0||z[i-1]=='\n';i+=2;startLine=pIn->nLine;while(z[i]&&(z[i]!='*'||z[i+1]!='/')){if(z[i]=='\n'){pIn->nLine++;if(isBlockComment){if(z[i+1]=='*'||z[i+2]=='*'){isBlockComment=2;}else{isBlockComment=0;}}}i++;}if(z[i]){i+=2;}else{isBlockComment=0;fprintf(stderr,"%s:%d:Unterminated comment\n",zFilename,startLine);nErr++;}pToken->eType=isBlockComment==2?TT_BlockComment:TT_Comment;pToken->nText=i-pIn->i;}else{pToken->eType=TT_Other;pToken->nText=1+(z[i+1]=='+');}break;case '0':if(z[i+1]=='x'||z[i+1]=='X'){i+=2;while(isxdigit(z[i])){i++;}}else{while(isdigit(z[i])){i++;}}pToken->eType=TT_Number;pToken->nText=i-pIn->i;break;case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':while(isdigit(z[i])){i++;}if((c=z[i])=='.'){i++;while(isdigit(z[i])){i++;}c=z[i];if(c=='e'||c=='E'){i++;if(((c=z[i])=='+'||c=='-')&&isdigit(z[i+1])){i++;}while(isdigit(z[i])){i++;}c=z[i];}if(c=='f'||c=='F'||c=='l'||c=='L'){i++;}}else if(c=='e'||c=='E'){i++;if(((c=z[i])=='+'||c=='-')&&isdigit(z[i+1])){i++;}while(isdigit(z[i])){i++;}}else if(c=='L'||c=='l'){i++;c=z[i];if(c=='u'||c=='U'){i++;}}else if(c=='u'||c=='U'){i++;c=z[i];if(c=='l'||c=='L'){i++;}}pToken->eType=TT_Number;pToken->nText=i-pIn->i;break;case 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h':case 'i':case 'j':case 'k':case 'l':case 'm':case 'n':case 'o':case 'p':case 'q':case 'r':case 's':case 't':case 'u':case 'v':case 'w':case 'x':case 'y':case 'z':case 'A':case 'B':case 'C':case 'D':case 'E':case 'F':case 'G':case 'H':case 'I':case 'J':case 'K':case 'L':case 'M':case 'N':case 'O':case 'P':case 'Q':case 'R':case 'S':case 'T':case 'U':case 'V':case 'W':case 'X':case 'Y':case 'Z':case '_':while(isalnum(z[i])||z[i]=='_'){i++;};pToken->eType=TT_Id;pToken->nText=i-pIn->i;break;case ':':pToken->eType=TT_Other;pToken->nText=1+(z[i+1]==':');break;case '=':case '<':case '>':case '+':case '-':case '*':case '%':case '^':case '&':case '|':pToken->eType=TT_Other;pToken->nText=1+(z[i+1]=='=');break;default:pToken->eType=TT_Other;pToken->nText=1;break;}pIn->i+=pToken->nText;return nErr;}static int GetNonspaceToken(InStream*pIn,Token*pToken){int nIf=0;int inZero=0;const char*z;int value;int startLine;int nErr=0;startLine=pIn->nLine;while(1){nErr+=GetToken(pIn,pToken);pToken->pComment=blockComment;switch(pToken->eType){case TT_Comment:if(strncmp(pToken->zText,"}static void FindIdentifiersInMacro(Token*pToken,IdentTable*pTable){Token sToken;InStream sIn;int go=1;sIn.z=pToken->zText;sIn.i=1;sIn.nLine=1;while(go&&sIn.i<pToken->nText){GetToken(&sIn,&sToken);switch(sToken.eType){case TT_Id:IdentTableInsert(pTable,sToken.zText,sToken.nText);break;case TT_EOF:go=0;break;default:break;}}}static int GetBigToken(InStream*pIn,Token*pToken,IdentTable*pTable){const char*zStart;int iStart;int nBrace;int c;int nLine;int nErr;nErr=GetNonspaceToken(pIn,pToken);switch(pToken->eType){case TT_Id:if(pTable!=0){IdentTableInsert(pTable,pToken->zText,pToken->nText);}return nErr;case TT_Preprocessor:if(pTable!=0){FindIdentifiersInMacro(pToken,pTable);}return nErr;case TT_Other:if(pToken->zText[0]=='{')break;return nErr;default:return nErr;}iStart=pIn->i;zStart=pToken->zText;nLine=pToken->nLine;nBrace=1;while(nBrace){nErr+=GetNonspaceToken(pIn,pToken);switch(pToken->eType){case TT_EOF:fprintf(stderr,"%s:%d:Unterminated \"{\"\n",zFilename,nLine);nErr++;pToken->eType=TT_Error;return nErr;case TT_Id:if(pTable){IdentTableInsert(pTable,pToken->zText,pToken->nText);}break;case TT_Preprocessor:if(pTable!=0){FindIdentifiersInMacro(pToken,pTable);}break;case TT_Other:if((c=pToken->zText[0])=='{'){nBrace++;}else if(c=='}'){nBrace--;}break;default:break;}}pToken->eType=TT_Braces;pToken->nText=1+pIn->i-iStart;pToken->zText=zStart;pToken->nLine=nLine;return nErr;}static void FreeTokenList(Token*pList){Token*pNext;while(pList){pNext=pList->pNext;SafeFree(pList);pList=pNext;}}static Token*TokenizeFile(const char*zFile,IdentTable*pTable){InStream sIn;Token*pFirst=0,*pLast=0,*pNew;int nErr=0;sIn.z=zFile;sIn.i=0;sIn.nLine=1;blockComment=0;while(sIn.z[sIn.i]!=0){pNew=SafeMalloc(sizeof(Token));nErr+=GetBigToken(&sIn,pNew,pTable);debug3(TOKENIZER,"Token on line%d:[%.*s]\n",pNew->nLine,pNew->nText<50?pNew->nText:50,pNew->zText);if(pFirst==0){pFirst=pLast=pNew;pNew->pPrev=0;}else{pLast->pNext=pNew;pNew->pPrev=pLast;pLast=pNew;}if(pNew->eType==TT_EOF)break;}if(pLast)pLast->pNext=0;blockComment=0;if(nErr){FreeTokenList(pFirst);pFirst=0;}return pFirst;}
#if TEST==1
void main(int argc,char**argv){char*zFile;Token*pList,*p;IdentTable sTable;if(argc!=2){fprintf(stderr,"Usage:%s filename\n",*argv);exit(1);}memset(&sTable,0,sizeof(sTable));zFile=ReadFile(argv[1]);if(zFile==0){fprintf(stderr,"Can't read file \"%s\"\n",argv[1]);exit(1);}pList=TokenizeFile(zFile,&sTable);for(p=pList;p;p=p->pNext){int j;switch(p->eType){case TT_Space:printf("%4d:Space\n",p->nLine);break;case TT_Id:printf("%4d:Id%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Preprocessor:printf("%4d:Preprocessor%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Comment:printf("%4d:Comment\n",p->nLine);break;case TT_BlockComment:printf("%4d:Block Comment\n",p->nLine);break;case TT_Number:printf("%4d:Number%.*s\n",p->nLine,p->nText,p->zText);break;case TT_String:printf("%4d:String%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Other:printf("%4d:Other%.*s\n",p->nLine,p->nText,p->zText);break;case TT_Braces:for(j=0;j<p->nText&&j<30&&p->zText[j]!='\n';j++){}printf("%4d:Braces%.*s...}\n",p->nLine,j,p->zText);break;case TT_EOF:printf("%4d:End of file\n",p->nLine);break;default:printf("%4d:type%d\n",p->nLine,p->eType);break;}}FreeTokenList(pList);SafeFree(zFile);IdentTablePrint(&sTable,stdout);}
#endif
#ifdef DEBUG
static void PrintTokens(Token*pFirst,Token*pLast){int needSpace=0;int c;pLast=pLast->pNext;while(pFirst!=pLast){switch(pFirst->eType){case TT_Preprocessor:printf("\n%.*s\n",pFirst->nText,pFirst->zText);needSpace=0;break;case TT_Id:case TT_Number:printf("%s%.*s",needSpace?" ":"",pFirst->nText,pFirst->zText);needSpace=1;break;default:c=pFirst->zText[0];printf("%s%.*s",(needSpace&&(c=='*'||c=='{'))?" ":"",pFirst->nText,pFirst->zText);needSpace=pFirst->zText[0]==',';break;}pFirst=pFirst->pNext;}}
#endif
static char*TokensToString(Token*pFirst,Token*pLast,char*zTerm,Token*pSkip,int nSkip){char*zReturn;String str;int needSpace=0;int c;int iSkip=0;int skipOne=0;StringInit(&str);pLast=pLast->pNext;while(pFirst!=pLast){if(pFirst==pSkip){iSkip=nSkip;}if(iSkip>0){iSkip--;pFirst=pFirst->pNext;continue;}switch(pFirst->eType){case TT_Preprocessor:StringAppend(&str,"\n",1);StringAppend(&str,pFirst->zText,pFirst->nText);StringAppend(&str,"\n",1);needSpace=0;break;case TT_Id:switch(pFirst->zText[0]){case 'E':if(pFirst->nText==6&&strncmp(pFirst->zText,"EXPORT",6)==0){skipOne=1;}break;case 'P':switch(pFirst->nText){case 6:skipOne=!strncmp(pFirst->zText,"PUBLIC",6);break;case 7:skipOne=!strncmp(pFirst->zText,"PRIVATE",7);break;case 9:skipOne=!strncmp(pFirst->zText,"PROTECTED",9);break;default:break;}break;default:break;}if(skipOne){pFirst=pFirst->pNext;skipOne=0;continue;}case TT_Number:if(needSpace){StringAppend(&str," ",1);}StringAppend(&str,pFirst->zText,pFirst->nText);needSpace=1;break;default:c=pFirst->zText[0];if(needSpace&&(c=='*'||c=='{')){StringAppend(&str," ",1);}StringAppend(&str,pFirst->zText,pFirst->nText);needSpace=0;break;}pFirst=pFirst->pNext;}if(zTerm&&*zTerm){StringAppend(&str,zTerm,strlen(zTerm));}zReturn=StrDup(StringGet(&str),0);StringReset(&str);return zReturn;}static int ProcessTypeDecl(Token*pList,int flags,int*pReset){Token*pName,*pEnd;Decl*pDecl;String str;int need_to_collapse=1;int type=0;*pReset=0;if(pList==0||pList->pNext==0||pList->pNext->eType!=TT_Id){return 0;}pName=pList->pNext;if(pName->pNext&&pName->pNext->zText[0]==';'){*pReset=';';return 0;}for(pEnd=pName->pNext;pEnd&&pEnd->eType!=TT_Braces;pEnd=pEnd->pNext){switch(pEnd->zText[0]){case '(':case ')':case '*':case '[':case '=':case ';':return 0;}}if(pEnd==0){return 0;}if(pEnd->pNext==0||pEnd->pNext->zText[0]==';'){*pReset=';';need_to_collapse=0;}else{need_to_collapse=1;}if(proto_static==0&&(flags&(PS_Local|PS_Export|PS_Interface))==0){*pReset=';';return 0;}
#ifdef DEBUG
if(debugMask&PARSER){printf("****Found type:%.*s%.*s...\n",pList->nText,pList->zText,pName->nText,pName->zText);PrintTokens(pList,pEnd);printf(";\n");}
#endif
switch(*pList->zText){case 'c':type=TY_Class;break;case 's':type=TY_Structure;break;case 'e':type=TY_Enumeration;break;case 'u':type=TY_Union;break;default:break;}if(type!=TY_Class){pDecl=0;}else{pDecl=FindDecl(pName->zText,pName->nText);if(pDecl&&(pDecl->flags&type)!=type)pDecl=0;}if(pDecl==0){pDecl=CreateDecl(pName->zText,pName->nText);}if((flags&PS_Static)||!(flags&(PS_Interface|PS_Export))){DeclSetProperty(pDecl,DP_Local);}DeclSetProperty(pDecl,type);if(flags&(PS_Local|PS_Export|PS_Interface)){pDecl->zDecl=TokensToString(pList,pEnd,";\n",0,0);}else{pDecl->zDecl=0;}pDecl->pComment=pList->pComment;StringInit(&str);StringAppend(&str,"typedef ",0);StringAppend(&str,pList->zText,pList->nText);StringAppend(&str," ",0);StringAppend(&str,pName->zText,pName->nText);StringAppend(&str," ",0);StringAppend(&str,pName->zText,pName->nText);StringAppend(&str,";\n",2);pDecl->zFwd=StrDup(StringGet(&str),0);StringReset(&str);StringInit(&str);StringAppend(&str,pList->zText,pList->nText);StringAppend(&str," ",0);StringAppend(&str,pName->zText,pName->nText);StringAppend(&str,";\n",2);pDecl->zFwdCpp=StrDup(StringGet(&str),0);StringReset(&str);if(flags&PS_Export){DeclSetProperty(pDecl,DP_Export);}else if(flags&PS_Local){DeclSetProperty(pDecl,DP_Local);}if(pDecl->zDecl&&DeclHasProperty(pDecl,TY_Enumeration)){StringInit(&str);StringAppend(&str,pDecl->zDecl,0);StringAppend(&str,pDecl->zFwd,0);SafeFree(pDecl->zDecl);SafeFree(pDecl->zFwd);pDecl->zFwd=0;pDecl->zDecl=StrDup(StringGet(&str),0);StringReset(&str);}if(pName->pNext->zText[0]==':'){DeclSetProperty(pDecl,DP_Cplusplus);}if(pName->nText==5&&strncmp(pName->zText,"class",5)==0){DeclSetProperty(pDecl,DP_Cplusplus);}if(need_to_collapse){while(pEnd!=pName){Token*pPrev=pEnd->pPrev;pPrev->pNext=pEnd->pNext;pEnd->pNext->pPrev=pPrev;SafeFree(pEnd);pEnd=pPrev;}}return 0;}static Token*FindDeclName(Token*pFirst,Token*pLast){Token*pName=0;Token*p;int c;if(pFirst==0||pLast==0){return 0;}pLast=pLast->pNext;for(p=pFirst;p&&p!=pLast;p=p->pNext){if(p->eType==TT_Id){static IdentTable sReserved;static int isInit=0;static const char*aWords[]={"char","class","const","double","enum","extern","EXPORT","ET_PROC","float","int","long","PRIVATE","PROTECTED","PUBLIC","register","static","struct","sizeof","signed","typedef","union","volatile","virtual","void",};if(!isInit){int i;for(i=0;i<sizeof(aWords)/sizeof(aWords[0]);i++){IdentTableInsert(&sReserved,aWords[i],0);}isInit=1;}if(!IdentTableTest(&sReserved,p->zText,p->nText)){pName=p;}}else if(p==pFirst){continue;}else if((c=p->zText[0])=='['&&pName){break;}else if(c=='('&&p->pNext&&p->pNext->eType==TT_Id&&pName){break;}else if(c==':'&&p->zText[1]==':'&&pName){break;}}return pName;}static int ProcessMethodDef(Token*pFirst,Token*pLast,int flags){Token*pClass;char*zDecl;Decl*pDecl;String str;int type;pLast=pLast->pPrev;while(pFirst->zText[0]=='P'){int rc=1;switch(pFirst->nText){case 6:rc=strncmp(pFirst->zText,"PUBLIC",6);break;case 7:rc=strncmp(pFirst->zText,"PRIVATE",7);break;case 9:rc=strncmp(pFirst->zText,"PROTECTED",9);break;default:break;}if(rc)break;pFirst=pFirst->pNext;}pClass=FindDeclName(pFirst,pLast);if(pClass==0){fprintf(stderr,"%s:%d:Unable to find the class name for this method\n",zFilename,pFirst->nLine);return 1;}pDecl=FindDecl(pClass->zText,pClass->nText);if(pDecl==0||(pDecl->flags&TY_Class)!=TY_Class){pDecl=CreateDecl(pClass->zText,pClass->nText);DeclSetProperty(pDecl,TY_Class);}StringInit(&str);if(pDecl->zExtra){StringAppend(&str,pDecl->zExtra,0);SafeFree(pDecl->zExtra);pDecl->zExtra=0;}type=flags&PS_PPP;if(pDecl->extraType!=type){if(type&PS_Public){StringAppend(&str,"public:\n",0);pDecl->extraType=PS_Public;}else if(type&PS_Protected){StringAppend(&str,"protected:\n",0);pDecl->extraType=PS_Protected;}else if(type&PS_Private){StringAppend(&str,"private:\n",0);pDecl->extraType=PS_Private;}}StringAppend(&str," ",0);zDecl=TokensToString(pFirst,pLast,";\n",pClass,2);if(strncmp(zDecl,pClass->zText,pClass->nText)==0){char*colon=strchr(zDecl,':');if(colon!=0&&colon[1]!=0){*colon++=';';*colon++='\n';*colon=0;}}StringAppend(&str,zDecl,0);SafeFree(zDecl);pDecl->zExtra=StrDup(StringGet(&str),0);StringReset(&str);return 0;}static int ProcessProcedureDef(Token*pFirst,Token*pLast,int flags){Token*pName;Decl*pDecl;Token*pCode;if(pFirst==0||pLast==0){return 0;}if(flags&PS_Method){if(flags&PS_PPP){return ProcessMethodDef(pFirst,pLast,flags);}else{return 0;}}if((flags&PS_Static)!=0&&!proto_static){return 0;}pCode=pLast;while(pLast&&pLast!=pFirst&&pLast->zText[0]!=')'){pLast=pLast->pPrev;}if(pLast==0||pLast==pFirst||pFirst->pNext==pLast){fprintf(stderr,"%s:%d:Unrecognized syntax.\n",zFilename,pFirst->nLine);return 1;}if(flags&(PS_Interface|PS_Export|PS_Local)){fprintf(stderr,"%s:%d:Missing \"inline\" on function or procedure.\n",zFilename,pFirst->nLine);return 1;}pName=FindDeclName(pFirst,pLast);if(pName==0){fprintf(stderr,"%s:%d:Malformed function or procedure definition.\n",zFilename,pFirst->nLine);return 1;}if(strncmp(pName->zText,"main",pName->nText)==0){return 0;}
#ifdef DEBUG
if(debugMask&PARSER){printf("****Found routine:%.*s on line%d...\n",pName->nText,pName->zText,pFirst->nLine);PrintTokens(pFirst,pLast);printf(";\n");}
#endif
pDecl=CreateDecl(pName->zText,pName->nText);pDecl->pComment=pFirst->pComment;if(pCode&&pCode->eType==TT_Braces){pDecl->tokenCode=*pCode;}DeclSetProperty(pDecl,TY_Subroutine);pDecl->zDecl=TokensToString(pFirst,pLast,";\n",0,0);if((flags&(PS_Static|PS_Local2))!=0){DeclSetProperty(pDecl,DP_Local);}else if((flags&(PS_Export2))!=0){DeclSetProperty(pDecl,DP_Export);}if(flags&DP_Cplusplus){DeclSetProperty(pDecl,DP_Cplusplus);}else{DeclSetProperty(pDecl,DP_ExternCReqd);}return 0;}static int ProcessInlineProc(Token*pFirst,int flags,int*pReset){Token*pName;Token*pEnd;Decl*pDecl;for(pEnd=pFirst;pEnd;pEnd=pEnd->pNext){if(pEnd->zText[0]=='{'||pEnd->zText[0]==';'){*pReset=pEnd->zText[0];break;}}if(pEnd==0){*pReset=';';fprintf(stderr,"%s:%d:incomplete inline procedure definition\n",zFilename,pFirst->nLine);return 1;}pName=FindDeclName(pFirst,pEnd);if(pName==0){fprintf(stderr,"%s:%d:malformed inline procedure definition\n",zFilename,pFirst->nLine);return 1;}
#ifdef DEBUG
if(debugMask&PARSER){printf("****Found inline routine:%.*s on line%d...\n",pName->nText,pName->zText,pFirst->nLine);PrintTokens(pFirst,pEnd);printf("\n");}
#endif
pDecl=CreateDecl(pName->zText,pName->nText);pDecl->pComment=pFirst->pComment;DeclSetProperty(pDecl,TY_Subroutine);pDecl->zDecl=TokensToString(pFirst,pEnd,";\n",0,0);if((flags&(PS_Static|PS_Local|PS_Local2))){DeclSetProperty(pDecl,DP_Local);}else if(flags&(PS_Export|PS_Export2)){DeclSetProperty(pDecl,DP_Export);}if(flags&DP_Cplusplus){DeclSetProperty(pDecl,DP_Cplusplus);}else{DeclSetProperty(pDecl,DP_ExternCReqd);}return 0;}static int isVariableDef(Token*pFirst,Token*pEnd){if(pEnd&&pEnd->zText[0]=='='&&(pEnd->pPrev->nText!=8||strncmp(pEnd->pPrev->zText,"operator",8)!=0)){return 1;}while(pFirst&&pFirst!=pEnd&&pFirst->pNext&&pFirst->pNext!=pEnd){if(pFirst->eType==TT_Id&&pFirst->pNext->zText[0]=='('){return 0;}pFirst=pFirst->pNext;}return 1;}static int isStaticAssert(Token*pFirst){if((pFirst->nText==13&&strncmp(pFirst->zText,"static_assert",13)==0)||(pFirst->nText==14&&strncmp(pFirst->zText,"_Static_assert",14)==0)){return 1;}else{return 0;}}static int ProcessDecl(Token*pFirst,Token*pEnd,int flags){Token*pName;Decl*pDecl;int isLocal=0;int isVar;int nErr=0;if(pFirst==0||pEnd==0){return 0;}if(flags&PS_Typedef){if((flags&(PS_Export2|PS_Local2))!=0){fprintf(stderr,"%s:%d:\"EXPORT\" or \"LOCAL\" ignored before typedef.\n",zFilename,pFirst->nLine);nErr++;}if((flags&(PS_Interface|PS_Export|PS_Local|DP_Cplusplus))==0){return nErr;}if((flags&(PS_Interface|PS_Export|PS_Local))==0&&proto_static==0){return nErr;}if((flags&(PS_Interface|PS_Export))==0){isLocal=1;}}else if(flags&(PS_Static|PS_Local2)){if(proto_static==0&&(flags&PS_Local2)==0){return nErr;}while(pFirst!=0&&pFirst->pNext!=pEnd&&((pFirst->nText==6&&strncmp(pFirst->zText,"static",6)==0)||(pFirst->nText==5&&strncmp(pFirst->zText,"LOCAL",6)==0))){pFirst=pFirst->pNext;isLocal=1;}if(pFirst==0||!isLocal){return nErr;}}else if(flags&PS_Method){return nErr;}else if(isStaticAssert(pFirst)){return 0;}isVar=(flags&(PS_Typedef|PS_Method))==0&&isVariableDef(pFirst,pEnd);if(isVar&&(flags&(PS_Interface|PS_Export|PS_Local))!=0&&(flags&PS_Extern)==0){fprintf(stderr,"%s:%d:Can't define a variable in this context\n",zFilename,pFirst->nLine);nErr++;}pName=FindDeclName(pFirst,pEnd->pPrev);if(pName==0){if(pFirst->nText==4&&strncmp(pFirst->zText,"enum",4)==0){return nErr;}else{fprintf(stderr,"%s:%d:Can't find a name for the object declared here.\n",zFilename,pFirst->nLine);return nErr+1;}}
#ifdef DEBUG
if(debugMask&PARSER){if(flags&PS_Typedef){printf("****Found typedef%.*s at line%d...\n",pName->nText,pName->zText,pName->nLine);}else if(isVar){printf("****Found variable%.*s at line%d...\n",pName->nText,pName->zText,pName->nLine);}else{printf("****Found prototype%.*s at line%d...\n",pName->nText,pName->zText,pName->nLine);}PrintTokens(pFirst,pEnd->pPrev);printf(";\n");}
#endif
pDecl=CreateDecl(pName->zText,pName->nText);if((flags&PS_Typedef)){DeclSetProperty(pDecl,TY_Typedef);}else if(isVar){DeclSetProperty(pDecl,DP_ExternReqd|TY_Variable);if(!(flags&DP_Cplusplus)){DeclSetProperty(pDecl,DP_ExternCReqd);}}else{DeclSetProperty(pDecl,TY_Subroutine);if(!(flags&DP_Cplusplus)){DeclSetProperty(pDecl,DP_ExternCReqd);}}pDecl->pComment=pFirst->pComment;pDecl->zDecl=TokensToString(pFirst,pEnd->pPrev,";\n",0,0);if(isLocal||(flags&(PS_Local|PS_Local2))!=0){DeclSetProperty(pDecl,DP_Local);}else if(flags&(PS_Export|PS_Export2)){DeclSetProperty(pDecl,DP_Export);}if(flags&DP_Cplusplus){DeclSetProperty(pDecl,DP_Cplusplus);}return nErr;}static void PushIfMacro(const char*zPrefix,const char*zText,int nText,int nLine,int flags){Ifmacro*pIf;int nByte;nByte=sizeof(Ifmacro);if(zText){if(zPrefix){nByte+=strlen(zPrefix)+2;}nByte+=nText+1;}pIf=SafeMalloc(nByte);if(zText){pIf->zCondition=(char*)&pIf[1];if(zPrefix){sprintf(pIf->zCondition,"%s(%.*s)",zPrefix,nText,zText);}else{sprintf(pIf->zCondition,"%.*s",nText,zText);}}else{pIf->zCondition=0;}pIf->nLine=nLine;pIf->flags=flags;pIf->pNext=ifStack;ifStack=pIf;}static int ParsePreprocessor(Token*pToken,int flags,int*pPresetFlags){const char*zCmd;int nCmd;const char*zArg;int nArg;int nErr=0;Ifmacro*pIf;zCmd=&pToken->zText[1];while(isspace(*zCmd)&&*zCmd!='\n'){zCmd++;}if(!isalpha(*zCmd)){return 0;}nCmd=1;while(isalpha(zCmd[nCmd])){nCmd++;}if(nCmd==5&&strncmp(zCmd,"endif",5)==0){pIf=ifStack;if(pIf==0){fprintf(stderr,"%s:%d:extra '#endif'.\n",zFilename,pToken->nLine);return 1;}ifStack=pIf->pNext;SafeFree(pIf);}else if(nCmd==6&&strncmp(zCmd,"define",6)==0){Decl*pDecl;if(!(flags&(PS_Local|PS_Interface|PS_Export))){return 0;}zArg=&zCmd[6];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}for(nArg=0;ISALNUM(zArg[nArg]);nArg++){}if(nArg==0){return 0;}pDecl=CreateDecl(zArg,nArg);pDecl->pComment=pToken->pComment;DeclSetProperty(pDecl,TY_Macro);pDecl->zDecl=SafeMalloc(pToken->nText+2);sprintf(pDecl->zDecl,"%.*s\n",pToken->nText,pToken->zText);if(flags&PS_Export){DeclSetProperty(pDecl,DP_Export);}else if(flags&PS_Local){DeclSetProperty(pDecl,DP_Local);}}else if(nCmd==7&&strncmp(zCmd,"include",7)==0){Include*pInclude;char*zIf;if(!(flags&(PS_Interface|PS_Export))){return 0;}zArg=&zCmd[7];while(*zArg&&isspace(*zArg)){zArg++;}for(nArg=0;!isspace(zArg[nArg]);nArg++){}if((zArg[0]=='"'&&zArg[nArg-1]!='"')||(zArg[0]=='<'&&zArg[nArg-1]!='>')){fprintf(stderr,"%s:%d:malformed #include statement.\n",zFilename,pToken->nLine);return 1;}zIf=GetIfString();if(zIf){pInclude=SafeMalloc(sizeof(Include)+nArg*2+strlen(zIf)+10);pInclude->zFile=(char*)&pInclude[1];pInclude->zLabel=&pInclude->zFile[nArg+1];sprintf(pInclude->zFile,"%.*s",nArg,zArg);sprintf(pInclude->zLabel,"%.*s:%s",nArg,zArg,zIf);pInclude->zIf=&pInclude->zLabel[nArg+1];SafeFree(zIf);}else{pInclude=SafeMalloc(sizeof(Include)+nArg+1);pInclude->zFile=(char*)&pInclude[1];sprintf(pInclude->zFile,"%.*s",nArg,zArg);pInclude->zIf=0;pInclude->zLabel=pInclude->zFile;}pInclude->pNext=includeList;includeList=pInclude;}else if(nCmd==2&&strncmp(zCmd,"if",2)==0){zArg=&zCmd[2];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}nArg=pToken->nText+(int)(pToken->zText-zArg);if(nArg==9&&strncmp(zArg,"INTERFACE",9)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Interface);}else if(nArg==16&&strncmp(zArg,"EXPORT_INTERFACE",16)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Export);}else if(nArg==15&&strncmp(zArg,"LOCAL_INTERFACE",15)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Local);}else if(nArg==15&&strncmp(zArg,"MAKEHEADERS_STOPLOCAL_INTERFACE",15)==0){PushIfMacro(0,0,0,pToken->nLine,PS_Local);}else{PushIfMacro(0,zArg,nArg,pToken->nLine,0);}}else if(nCmd==5&&strncmp(zCmd,"ifdef",5)==0){zArg=&zCmd[5];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}nArg=pToken->nText+(int)(pToken->zText-zArg);PushIfMacro("defined",zArg,nArg,pToken->nLine,0);}else if(nCmd==6&&strncmp(zCmd,"ifndef",6)==0){zArg=&zCmd[6];while(*zArg&&isspace(*zArg)&&*zArg!='\n'){zArg++;}if(*zArg==0||*zArg=='\n'){return 0;}nArg=pToken->nText+(int)(pToken->zText-zArg);PushIfMacro("!defined",zArg,nArg,pToken->nLine,0);}else if(nCmd==4&&strncmp(zCmd,"else ",4)==0){if(ifStack==0){fprintf(stderr,"%s:%d:'#else ' without an '#if'\n",zFilename,pToken->nLine);return 1;}pIf=ifStack;if(pIf->zCondition){ifStack=ifStack->pNext;PushIfMacro("!",pIf->zCondition,strlen(pIf->zCondition),pIf->nLine,0);SafeFree(pIf);}else{pIf->flags=0;}}else{return 0;}*pPresetFlags=0;for(pIf=ifStack;pIf;pIf=pIf->pNext){*pPresetFlags|=pIf->flags;}return nErr;}static int ParseFile(Token*pList,int initFlags){int nErr=0;Token*pStart=0;int flags=initFlags;int presetFlags=initFlags;int resetFlag=0;includeList=0;while(pList){switch(pList->eType){case TT_EOF:goto end_of_loop;case TT_Preprocessor:nErr+=ParsePreprocessor(pList,flags,&presetFlags);pStart=0;presetFlags|=initFlags;flags=presetFlags;break;case TT_Other:switch(pList->zText[0]){case ';':nErr+=ProcessDecl(pStart,pList,flags);pStart=0;flags=presetFlags;break;case '=':if(pList->pPrev->nText==8&&strncmp(pList->pPrev->zText,"operator",8)==0){break;}nErr+=ProcessDecl(pStart,pList,flags);pStart=0;while(pList&&pList->zText[0]!=';'){pList=pList->pNext;}if(pList==0)goto end_of_loop;flags=presetFlags;break;case ':':if(pList->zText[1]==':'){flags|=PS_Method;}break;default:break;}break;case TT_Braces:nErr+=ProcessProcedureDef(pStart,pList,flags);pStart=0;flags=presetFlags;break;case TT_Id:if(pStart==0){pStart=pList;flags=presetFlags;}resetFlag=0;switch(pList->zText[0]){case 'c':if(pList->nText==5&&strncmp(pList->zText,"class",5)==0){nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}break;case 'E':if(pList->nText==6&&strncmp(pList->zText,"EXPORT",6)==0){flags|=PS_Export2;}break;case 'e':if(pList->nText==4&&strncmp(pList->zText,"enum",4)==0){if(pList->pNext&&pList->pNext->eType==TT_Braces){pList=pList->pNext;}else{nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}}else if(pList->nText==6&&strncmp(pList->zText,"extern",6)==0){pList=pList->pNext;if(pList&&pList->nText==3&&strncmp(pList->zText,"\"C\"",3)==0){pList=pList->pNext;flags&=~DP_Cplusplus;}else{flags|=PS_Extern;}pStart=pList;}break;case 'i':if(pList->nText==6&&strncmp(pList->zText,"inline",6)==0&&(flags&PS_Static)==0){nErr+=ProcessInlineProc(pList,flags,&resetFlag);}break;case 'L':if(pList->nText==5&&strncmp(pList->zText,"LOCAL",5)==0){flags|=PS_Local2;pStart=pList;}break;case 'P':if(pList->nText==6&&strncmp(pList->zText,"PUBLIC",6)==0){flags|=PS_Public;pStart=pList;}else if(pList->nText==7&&strncmp(pList->zText,"PRIVATE",7)==0){flags|=PS_Private;pStart=pList;}else if(pList->nText==9&&strncmp(pList->zText,"PROTECTED",9)==0){flags|=PS_Protected;pStart=pList;}break;case 's':if(pList->nText==6&&strncmp(pList->zText,"struct",6)==0){if(pList->pNext&&pList->pNext->eType==TT_Braces){pList=pList->pNext;}else{nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}}else if(pList->nText==6&&strncmp(pList->zText,"static",6)==0){flags|=PS_Static;}break;case 't':if(pList->nText==7&&strncmp(pList->zText,"typedef",7)==0){flags|=PS_Typedef;}break;case 'u':if(pList->nText==5&&strncmp(pList->zText,"union",5)==0){if(pList->pNext&&pList->pNext->eType==TT_Braces){pList=pList->pNext;}else{nErr+=ProcessTypeDecl(pList,flags,&resetFlag);}}break;default:break;}if(resetFlag!=0){while(pList&&pList->zText[0]!=resetFlag){pList=pList->pNext;}if(pList==0)goto end_of_loop;pStart=0;flags=presetFlags;}break;case TT_String:case TT_Number:break;default:pStart=pList;flags=presetFlags;break;}pList=pList->pNext;}end_of_loop:while(ifStack){Ifmacro*pIf=ifStack;ifStack=pIf->pNext;fprintf(stderr,"%s:%d:This '#if' has no '#endif'\n",zFilename,pIf->nLine);SafeFree(pIf);}return nErr;}static void InsertExtraDecl(Decl*pDecl){int i;String str;if(pDecl==0||pDecl->zExtra==0||pDecl->zDecl==0)return;i=strlen(pDecl->zDecl)-1;while(i>0&&pDecl->zDecl[i]!='}'){i--;}StringInit(&str);StringAppend(&str,pDecl->zDecl,i);StringAppend(&str,pDecl->zExtra,0);StringAppend(&str,&pDecl->zDecl[i],0);SafeFree(pDecl->zDecl);SafeFree(pDecl->zExtra);pDecl->zDecl=StrDup(StringGet(&str),0);StringReset(&str);pDecl->zExtra=0;}static void ResetDeclFlags(char*zFilename){Decl*pDecl;for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){DeclClearProperty(pDecl,DP_Forward|DP_Declared);if(DeclHasProperty(pDecl,DP_Local)&&pDecl->zFile!=zFilename){DeclSetProperty(pDecl,DP_Forward|DP_Declared);}}}static void ScanText(const char*,GenState*pState);static void ChangeIfContext(const char*zIf,GenState*pState){if(zIf==0){if(pState->zIf==0)return;StringAppend(pState->pStr,"#endif\n",0);pState->zIf=0;}else{if(pState->zIf){if(strcmp(zIf,pState->zIf)==0)return;StringAppend(pState->pStr,"#endif\n",0);pState->zIf=0;}ScanText(zIf,pState);if(pState->zIf!=0){StringAppend(pState->pStr,"#endif\n",0);}StringAppend(pState->pStr,"#if ",0);StringAppend(pState->pStr,zIf,0);StringAppend(pState->pStr,"\n",0);pState->zIf=zIf;}}static void AddIncludes(Include*pInclude,GenState*pState){if(pInclude){if(pInclude->pNext){AddIncludes(pInclude->pNext,pState);}if(IdentTableInsert(pState->pTable,pInclude->zLabel,0)){ChangeIfContext(pInclude->zIf,pState);StringAppend(pState->pStr,"#include ",0);StringAppend(pState->pStr,pInclude->zFile,0);StringAppend(pState->pStr,"\n",1);}}}static void DeclareObject(Decl*pDecl,GenState*pState,int needFullDecl){Decl*p;int flag;int isCpp;int doneTypedef=0;isCpp=(pState->flags&DP_Cplusplus)!=0;for(p=pDecl;p;p=p->pSameName){if(p->zFwd){if(!DeclHasProperty(p,DP_Forward)){DeclSetProperty(p,DP_Forward);if(strncmp(p->zFwd,"typedef",7)==0){if(doneTypedef)continue;doneTypedef=1;}ChangeIfContext(p->zIf,pState);StringAppend(pState->pStr,isCpp?p->zFwdCpp:p->zFwd,0);}}}flag=needFullDecl?DP_Declared|DP_Forward:DP_Forward;for(p=pDecl;p;p=p->pSameName){if(!DeclHasProperty(p,flag))break;}if(p==0){return;}for(p=pDecl;p;p=p->pSameName){AddIncludes(p->pInclude,pState);}for(p=pDecl;p;p=p->pSameName){if(!DeclHasProperty(p,DP_Declared)&&(p->zFwd==0||needFullDecl)&&p->zDecl!=0){DeclSetProperty(p,DP_Forward|DP_Declared|DP_Flag);}else{DeclClearProperty(p,DP_Flag);}}for(p=pDecl;p;p=p->pSameName){if(DeclHasProperty(p,DP_Flag)){if(p->zDecl[0]=='#'){ScanText(&p->zDecl[1],pState);}else{InsertExtraDecl(p);ScanText(p->zDecl,pState);}}}for(p=pDecl;p;p=p->pSameName){if(DeclHasProperty(p,DP_Flag)&&!DeclHasProperty(p,TY_Typedef)){if(DeclHasAnyProperty(p,TY_Enumeration)){if(doneTypedef)continue;doneTypedef=1;}ChangeIfContext(p->zIf,pState);if(!isCpp&&DeclHasAnyProperty(p,DP_ExternReqd)){StringAppend(pState->pStr,"extern ",0);}else if(isCpp&&DeclHasProperty(p,DP_Cplusplus|DP_ExternReqd)){StringAppend(pState->pStr,"extern ",0);}else if(isCpp&&DeclHasAnyProperty(p,DP_ExternCReqd|DP_ExternReqd)){StringAppend(pState->pStr,"extern \"C\" ",0);}InsertExtraDecl(p);StringAppend(pState->pStr,p->zDecl,0);if(!isCpp&&DeclHasProperty(p,DP_Cplusplus)){fprintf(stderr,"%s:C code ought not reference the C++object \"%s\"\n",pState->zFilename,p->zName);pState->nErr++;}DeclClearProperty(p,DP_Flag);}}for(p=pDecl;p&&!doneTypedef;p=p->pSameName){if(DeclHasProperty(p,DP_Flag)){doneTypedef=1;ChangeIfContext(p->zIf,pState);InsertExtraDecl(p);StringAppend(pState->pStr,p->zDecl,0);}}}static void ScanText(const char*zText,GenState*pState){int nextValid=0;InStream sIn;Token sToken;Token sNext;sIn.z=zText;sIn.i=0;sIn.nLine=1;while(sIn.z[sIn.i]!=0){if(nextValid){sToken=sNext;nextValid=0;}else{GetNonspaceToken(&sIn,&sToken);}if(sToken.eType==TT_Id){int needFullDecl;Decl*pDecl;pDecl=FindDecl(sToken.zText,sToken.nText);if(pDecl==0)continue;GetNonspaceToken(&sIn,&sNext);if(sNext.zText[0]=='*'){needFullDecl=0;}else{needFullDecl=1;nextValid=sNext.eType==TT_Id;}DeclareObject(pDecl,pState,needFullDecl);}else if(sToken.eType==TT_Preprocessor){sIn.i-=sToken.nText-1;}}}static void CompleteForwardDeclarations(GenState*pState){Decl*pDecl;int progress;do{progress=0;for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){if(DeclHasProperty(pDecl,DP_Forward)&&!DeclHasProperty(pDecl,DP_Declared)){DeclareObject(pDecl,pState,1);progress=1;assert(DeclHasProperty(pDecl,DP_Declared));}}}while(progress);}static int MakeHeader(InFile*pFile,FILE*report,int nolocal_flag){int nErr=0;GenState sState;String outStr;IdentTable includeTable;Ident*pId;char*zNewVersion;char*zOldVersion;if(pFile->zHdr==0||*pFile->zHdr==0)return 0;sState.pStr=&outStr;StringInit(&outStr);StringAppend(&outStr,zTopLine,nTopLine);sState.pTable=&includeTable;memset(&includeTable,0,sizeof(includeTable));sState.zIf=0;sState.nErr=0;sState.zFilename=pFile->zSrc;sState.flags=pFile->flags&DP_Cplusplus;ResetDeclFlags(nolocal_flag?"no":pFile->zSrc);for(pId=pFile->idTable.pList;pId;pId=pId->pNext){Decl*pDecl=FindDecl(pId->zName,0);if(pDecl){DeclareObject(pDecl,&sState,1);}}CompleteForwardDeclarations(&sState);ChangeIfContext(0,&sState);nErr+=sState.nErr;zOldVersion=ReadFile(pFile->zHdr);zNewVersion=StringGet(&outStr);if(report)fprintf(report,"%s:",pFile->zHdr);if(zOldVersion==0){if(report)fprintf(report,"updated\n");if(WriteFile(pFile->zHdr,zNewVersion)){fprintf(stderr,"%s:Can't write to file\n",pFile->zHdr);nErr++;}}else if(strncmp(zOldVersion,zTopLine,nTopLine)!=0){if(report)fprintf(report,"error!\n");fprintf(stderr,"%s:Can't overwrite this file because it wasn't previously\n""%*s generated by 'makeheaders'.\n",pFile->zHdr,(int)strlen(pFile->zHdr),"");nErr++;}else if(strcmp(zOldVersion,zNewVersion)!=0){if(report)fprintf(report,"updated\n");if(WriteFile(pFile->zHdr,zNewVersion)){fprintf(stderr,"%s:Can't write to file\n",pFile->zHdr);nErr++;}}else if(report){fprintf(report,"unchanged\n");}SafeFree(zOldVersion);IdentTableReset(&includeTable);StringReset(&outStr);return nErr;}static int MakeGlobalHeader(int forExport){GenState sState;String outStr;IdentTable includeTable;Decl*pDecl;sState.pStr=&outStr;StringInit(&outStr);sState.pTable=&includeTable;memset(&includeTable,0,sizeof(includeTable));sState.zIf=0;sState.nErr=0;sState.zFilename="(all)";sState.flags=0;ResetDeclFlags(0);for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){if(forExport==0||DeclHasProperty(pDecl,DP_Export)){DeclareObject(pDecl,&sState,1);}}ChangeIfContext(0,&sState);printf("%s",StringGet(&outStr));IdentTableReset(&includeTable);StringReset(&outStr);return 0;}
#ifdef DEBUG
static int ClipTrailingNewline(char*z){int n=strlen(z);while(n>0&&(z[n-1]=='\n'||z[n-1]=='\r')){n--;}return n;}static void DumpDeclList(void){Decl*pDecl;for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){printf("****%s from file%s****\n",pDecl->zName,pDecl->zFile);if(pDecl->zIf){printf("If:[%.*s]\n",ClipTrailingNewline(pDecl->zIf),pDecl->zIf);}if(pDecl->zFwd){printf("Decl:[%.*s]\n",ClipTrailingNewline(pDecl->zFwd),pDecl->zFwd);}if(pDecl->zDecl){InsertExtraDecl(pDecl);printf("Def:[%.*s]\n",ClipTrailingNewline(pDecl->zDecl),pDecl->zDecl);}if(pDecl->flags){static struct{int mask;char*desc;}flagSet[]={{TY_Class,"class"},{TY_Enumeration,"enum"},{TY_Structure,"struct"},{TY_Union,"union"},{TY_Variable,"variable"},{TY_Subroutine,"function"},{TY_Typedef,"typedef"},{TY_Macro,"macro"},{DP_Export,"export"},{DP_Local,"local"},{DP_Cplusplus,"C++"},};int i;printf("flags:");for(i=0;i<sizeof(flagSet)/sizeof(flagSet[0]);i++){if(flagSet[i].mask&pDecl->flags){printf("%s",flagSet[i].desc);}}printf("\n");}if(pDecl->pInclude){Include*p;printf("includes:");for(p=pDecl->pInclude;p;p=p->pNext){printf("%s",p->zFile);}printf("\n");}}}
#endif
static void DocumentationDump(void){Decl*pDecl;static struct{int mask;char flag;}flagSet[]={{TY_Class,'c'},{TY_Enumeration,'e'},{TY_Structure,'s'},{TY_Union,'u'},{TY_Variable,'v'},{TY_Subroutine,'f'},{TY_Typedef,'t'},{TY_Macro,'m'},{DP_Export,'x'},{DP_Local,'l'},{DP_Cplusplus,'+'},};for(pDecl=pDeclFirst;pDecl;pDecl=pDecl->pNext){int i;int nLabel=0;char*zDecl;char zLabel[50];for(i=0;i<sizeof(flagSet)/sizeof(flagSet[0]);i++){if(DeclHasProperty(pDecl,flagSet[i].mask)){zLabel[nLabel++]=flagSet[i].flag;}}if(nLabel==0)continue;zLabel[nLabel]=0;InsertExtraDecl(pDecl);zDecl=pDecl->zDecl;if(zDecl==0)zDecl=pDecl->zFwd;printf("%s%s%s%p%d%d%d%d%d\n",pDecl->zName,zLabel,pDecl->zFile,pDecl->pComment,pDecl->pComment?pDecl->pComment->nText+1:0,pDecl->zIf?(int)strlen(pDecl->zIf)+1:0,zDecl?(int)strlen(zDecl):0,pDecl->pComment?pDecl->pComment->nLine:0,pDecl->tokenCode.nText?pDecl->tokenCode.nText+1:0);if(pDecl->pComment){printf("%.*s\n",pDecl->pComment->nText,pDecl->pComment->zText);}if(pDecl->zIf){printf("%s\n",pDecl->zIf);}if(zDecl){printf("%s",zDecl);}if(pDecl->tokenCode.nText){printf("%.*s\n",pDecl->tokenCode.nText,pDecl->tokenCode.zText);}}}void PrintModuleRecord(const char*zFile,const char*zFilename){int i;static int addr=5;while(isspace(*zFile)){zFile++;}if(*zFile!='/'||zFile[1]!='*')return;for(i=2;zFile[i]&&(zFile[i-1]!='/'||zFile[i-2]!='*');i++){}if(zFile[i]==0)return;printf("%s M%s%d%d 0 0 0 0\n%.*s\n",zFilename,zFilename,addr,i+1,i,zFile);addr+=4;}static InFile*CreateInFile(char*zArg,int*pnErr){int nSrc;char*zSrc;InFile*pFile;int i;zSrc=zArg;for(nSrc=2;zSrc[nSrc]&&zArg[nSrc]!=':';nSrc++){}pFile=SafeMalloc(sizeof(InFile));memset(pFile,0,sizeof(InFile));pFile->zSrc=StrDup(zSrc,nSrc);if(nSrc>2&&zSrc[nSrc-2]=='.'&&(zSrc[nSrc-1]=='c'||zSrc[nSrc-1]=='h')){pFile->flags&=~DP_Cplusplus;}else{pFile->flags|=DP_Cplusplus;}if(zSrc[nSrc]==':'){int nHdr;char*zHdr;zHdr=&zSrc[nSrc+1];for(nHdr=0;zHdr[nHdr];nHdr++){}pFile->zHdr=StrDup(zHdr,nHdr);}else{int foundC=0;pFile->zHdr=StrDup(zSrc,nSrc);for(i=nSrc-1;i>0&&pFile->zHdr[i]!='.';i--){if(pFile->zHdr[i]=='c'){foundC=1;pFile->zHdr[i]='h';}else if(pFile->zHdr[i]=='C'){foundC=1;pFile->zHdr[i]='H';}}if(!foundC){SafeFree(pFile->zHdr);pFile->zHdr=0;}}pFile->flags|=PS_Interface;for(i=nSrc-1;i>0&&zSrc[i]!='.';i--){if(zSrc[i]=='c'||zSrc[i]=='C'){pFile->flags&=~PS_Interface;break;}}return pFile;}static void AddParameters(int index,int*pArgc,char***pArgv){int argc=*pArgc;char**argv=*pArgv;int newArgc;char**zNew=0;char*zFile;int nNew=0;int nAlloc=0;int i;int n;int c;int startOfLine=1;FILE*in;char zBuf[1000];if(index+1==argc)return;zFile=argv[index+1];in=fopen(zFile,"r");if(in==0){fprintf(stderr,"Can't open input file \"%s\"\n",zFile);exit(1);}c=' ';while(c!=EOF){while(c!=EOF&&isspace(c)){if(c=='\n'){startOfLine=1;}c=getc(in);if(startOfLine&&c=='#'){while(c!=EOF&&c!='\n'){c=getc(in);}}}n=0;while(c!=EOF&&!isspace(c)){if(n<sizeof(zBuf)-1){zBuf[n++]=c;}startOfLine=0;c=getc(in);}zBuf[n]=0;if(n>0){nNew++;if(nNew+argc>nAlloc){if(nAlloc==0){nAlloc=100+argc;zNew=malloc(sizeof(char*)*nAlloc);}else{nAlloc*=2;zNew=realloc(zNew,sizeof(char*)*nAlloc);}}if(zNew){int j=nNew+index;zNew[j]=malloc(n+1);if(zNew[j]){strcpy(zNew[j],zBuf);}}}}fclose(in);newArgc=argc+nNew-1;for(i=0;i<=index;i++){zNew[i]=argv[i];}for(i=nNew+index+1;i<newArgc;i++){zNew[i]=argv[i+1-nNew];}zNew[newArgc]=0;*pArgc=newArgc;*pArgv=zNew;}
#ifdef NOT_USED
static unsigned int ModTime(const char*zFilename){unsigned int mTime=0;struct stat sStat;if(stat(zFilename,&sStat)==0){mTime=sStat.st_mtime;}return mTime;}
#endif
static void Usage(const char*argv0,const char*argvN){fprintf(stderr,"%s:Illegal argument \"%s\"\n",argv0,argvN);fprintf(stderr,"Usage:%s [options] filename...\n""Options:\n""-h Generate a single .h to standard output.\n""-H Like-h,but only output EXPORT declarations.\n""-v(verbose)Write status information to the screen.\n""-doc Generate no header files. Instead,output information\n"" that can be used by an automatic program documentation\n"" and cross-reference generator.\n""-local Generate prototypes for \"static\" functions and\n"" procedures.\n""-f FILE Read additional command-line arguments from the file named\n"" \"FILE\".\n"
#ifdef DEBUG
"-!MASK Set the debugging mask to the number \"MASK\".\n"
#endif
"--Treat all subsequent comment-line parameters as filenames,\n"" even if they begin with \"-\".\n",argv0);}static const char zInit[]="#define INTERFACE 0\n""#define EXPORT_INTERFACE 0\n""#define LOCAL_INTERFACE 0\n""#define EXPORT\n""#define LOCAL static\n""#define PUBLIC\n""#define PRIVATE\n""#define PROTECTED\n";
#if TEST==0
int main(int argc,char**argv){int i;int nErr=0;Token*pList;InFile*pFileList=0;InFile*pTail=0;InFile*pFile;int h_flag=0;int H_flag=0;int v_flag=0;int noMoreFlags;FILE*report;noMoreFlags=0;for(i=1;i<argc;i++){if(argv[i][0]=='-'&&!noMoreFlags){switch(argv[i][1]){case 'h':h_flag=1;break;case 'H':H_flag=1;break;case 'v':v_flag=1;break;case 'd':doc_flag=1;proto_static=1;break;case 'l':proto_static=1;break;case 'f':AddParameters(i,&argc,&argv);break;case '-':noMoreFlags=1;break;
#ifdef DEBUG
case '!':i++;debugMask=strtol(argv[i],0,0);break;
#endif
default:Usage(argv[0],argv[i]);return 1;}}else{pFile=CreateInFile(argv[i],&nErr);if(pFile){if(pFileList){pTail->pNext=pFile;pTail=pFile;}else{pFileList=pTail=pFile;}}}}if(h_flag&&H_flag){h_flag=0;}if(v_flag){report=(h_flag||H_flag)?stderr:stdout;}else{report=0;}if(nErr>0){return nErr;}for(pFile=pFileList;pFile;pFile=pFile->pNext){char*zFile;zFilename=pFile->zSrc;if(zFilename==0)continue;zFile=ReadFile(zFilename);if(zFile==0){fprintf(stderr,"Can't read input file \"%s\"\n",zFilename);nErr++;continue;}if(strncmp(zFile,zTopLine,nTopLine)==0){pFile->zSrc=0;}else{if(report)fprintf(report,"Reading%s...\n",zFilename);pList=TokenizeFile(zFile,&pFile->idTable);if(pList){nErr+=ParseFile(pList,pFile->flags);FreeTokenList(pList);}else if(zFile[0]==0){fprintf(stderr,"Input file \"%s\" is empty.\n",zFilename);nErr++;}else{fprintf(stderr,"Errors while processing \"%s\"\n",zFilename);nErr++;}}if(!doc_flag)SafeFree(zFile);if(doc_flag)PrintModuleRecord(zFile,zFilename);}if(nErr>0){return nErr;}
#ifdef DEBUG
if(debugMask&DECL_DUMP){DumpDeclList();return nErr;}
#endif
if(doc_flag){DocumentationDump();return nErr;}zFilename="--internal--";pList=TokenizeFile(zInit,0);if(pList==0){return nErr+1;}ParseFile(pList,PS_Interface);FreeTokenList(pList);if(h_flag||H_flag){nErr+=MakeGlobalHeader(H_flag);}else{for(pFile=pFileList;pFile;pFile=pFile->pNext){if(pFile->zSrc==0)continue;nErr+=MakeHeader(pFile,report,0);}}return nErr;}
#endif
